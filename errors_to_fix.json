[
  {
    "message": "Unexpected token ARROW at 32204",
    "offset": 32204,
    "line": 1097,
    "column": 13,
    "evidence": {
      "startLine": 1087,
      "endLine": 1107,
      "focusLine": 1097,
      "lines": [
        "    dbGoTo(OldCRec)",
        " //------------------",
        "    IF substr(temp_no,6,4) \u003d\u003d \"0000\" .OR. Len(temp_no)\u003c\u003e9    // did we roll over or die?",
        "      Scn_No(088)                            // maximum number of cases exceeded message",
        "      MsgBox( \"Maximum number of cases exceeded.\"+Chr(13)+ ; // Tell the user the",
        "                \"Call UCS for help...\")                    //   bad news....",
        "      AppQuit( \"Now\" )",
        "    ELSE",
        "      dbSelectArea(\"CLIENT\")",
        "      replace CLIENT-\u003eN_INDEX_NO with temp_no   // store the number for next time",
        "      CLIENT-\u003e(dbCommit())",
        "      USE",
        "    ENDIF",
        "    USE   // insurance",
        "    IF !empty(old_area)",
        "      SELE \u0026old_area",
        "    ENDIF",
        "    RETURN(temp_no)",
        "  ELSE",
        "    //  Client unavailable, wait for fix",
        "    AlertBox TO nOK ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 33375",
    "offset": 33375,
    "line": 1128,
    "column": 5,
    "evidence": {
      "startLine": 1118,
      "endLine": 1138,
      "focusLine": 1128,
      "lines": [
        "    NameLkUp(17,7)     // Report lock failure",
        "    nLoopCnt++",
        "    IniWrite1(\"diagnostics\", \"Index_No_Locked\", Alltrim(Getenv(\"COMPUTERNAME\"))+\"_Registry\",;",
        "                                                  CheckRegistryStatuses() + \" | \" + DtoC(Date()))",
        "    IF nOK \u003d 2 .OR. nLoopCnt \u003e 8  // ~2 minutes",
        "      USE",
        "      IF !empty(old_area)",
        "        SELE \u0026old_area",
        "      ENDIF",
        "      AppQuit( \"Now\" )",
        "    ENDIF",
        "  ENDIF",
        "  USE",
        "ENDDO",
        "RETURN .F.",
        "// EOF case_no",
        "",
        "",
        "*******************************************************************************",
        "* Class \"DataThread\"  used to start thread and open data files",
        "*******************************************************************************"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 33383",
    "offset": 33383,
    "line": 1129,
    "column": 3,
    "evidence": {
      "startLine": 1119,
      "endLine": 1139,
      "focusLine": 1129,
      "lines": [
        "    nLoopCnt++",
        "    IniWrite1(\"diagnostics\", \"Index_No_Locked\", Alltrim(Getenv(\"COMPUTERNAME\"))+\"_Registry\",;",
        "                                                  CheckRegistryStatuses() + \" | \" + DtoC(Date()))",
        "    IF nOK \u003d 2 .OR. nLoopCnt \u003e 8  // ~2 minutes",
        "      USE",
        "      IF !empty(old_area)",
        "        SELE \u0026old_area",
        "      ENDIF",
        "      AppQuit( \"Now\" )",
        "    ENDIF",
        "  ENDIF",
        "  USE",
        "ENDDO",
        "RETURN .F.",
        "// EOF case_no",
        "",
        "",
        "*******************************************************************************",
        "* Class \"DataThread\"  used to start thread and open data files",
        "*******************************************************************************",
        "CLASS DataThread FROM Thread"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after expression at 35342",
    "offset": 35342,
    "line": 1195,
    "column": 32,
    "evidence": {
      "startLine": 1185,
      "endLine": 1205,
      "focusLine": 1195,
      "lines": [
        "",
        "         INLINE METHOD init",
        "            ::Thread:init()",
        "            Sleep(5)",
        "            ::terminated  :\u003d .F.",
        "            ::workCounter :\u003d 0",
        "         RETURN self",
        "",
        "         INLINE METHOD terminate",
        "",
        "         RETURN ( ::terminated :\u003d .T. )",
        "",
        "         METHOD execute, checkTermination, atEnd",
        "   ENDCLASS",
        "",
        "   ** This method is executed in the thread",
        "   METHOD PrintThread:execute",
        "      DO WHILE ::workCounter \u003c 10000000",
        "//         ::workCounter++",
        "         ::checkTermination()",
        "      ENDDO"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 35342",
    "offset": 35342,
    "line": 1195,
    "column": 32,
    "evidence": {
      "startLine": 1185,
      "endLine": 1205,
      "focusLine": 1195,
      "lines": [
        "",
        "         INLINE METHOD init",
        "            ::Thread:init()",
        "            Sleep(5)",
        "            ::terminated  :\u003d .F.",
        "            ::workCounter :\u003d 0",
        "         RETURN self",
        "",
        "         INLINE METHOD terminate",
        "",
        "         RETURN ( ::terminated :\u003d .T. )",
        "",
        "         METHOD execute, checkTermination, atEnd",
        "   ENDCLASS",
        "",
        "   ** This method is executed in the thread",
        "   METHOD PrintThread:execute",
        "      DO WHILE ::workCounter \u003c 10000000",
        "//         ::workCounter++",
        "         ::checkTermination()",
        "      ENDDO"
      ]
    }
  },
  {
    "message": "Unexpected ENDDO at 35591",
    "offset": 35591,
    "line": 1205,
    "column": 7,
    "evidence": {
      "startLine": 1195,
      "endLine": 1215,
      "focusLine": 1205,
      "lines": [
        "         RETURN ( ::terminated :\u003d .T. )",
        "",
        "         METHOD execute, checkTermination, atEnd",
        "   ENDCLASS",
        "",
        "   ** This method is executed in the thread",
        "   METHOD PrintThread:execute",
        "      DO WHILE ::workCounter \u003c 10000000",
        "//         ::workCounter++",
        "         ::checkTermination()",
        "      ENDDO",
        "   RETURN self",
        "",
        "   ** This method checks whether or not the thread must",
        "   ** terminate and cancels it, if necessary",
        "",
        "   METHOD PrintThread:checkTermination",
        "      IF ::terminated",
        "         ::terminated :\u003d .F.",
        "         ::quit()",
        "      ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected token BREAK at 50579",
    "offset": 50579,
    "line": 1631,
    "column": 34,
    "evidence": {
      "startLine": 1621,
      "endLine": 1641,
      "focusLine": 1631,
      "lines": [
        "  Alert_Box(\"REMOVE\")",
        "",
        "  ThreadObject():QUIT()",
        "//  Break()   // We are not going back!",
        "RETURN",
        "// EOP ReportDataError",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE Message2ErrorLog(cMsg)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "LOCAL cErrorLog",
        "LOCAL lPrint, lConsole, cAlternate, lAlternate, lExtra",
        "/* Save current printer related settings, turn printer off */",
        "BEGIN SEQUENCE",
        "lPrint     :\u003d Set( _SET_PRINTER )",
        "lConsole   :\u003d Set( _SET_CONSOLE )",
        "cAlternate :\u003d Set( _SET_ALTFILE )",
        "lAlternate :\u003d Set( _SET_ALTERNATE )",
        "lExtra     :\u003d Set( _SET_EXTRA, .F. )",
        ""
      ]
    }
  },
  {
    "message": "Expected expression in block literal at 50584",
    "offset": 50584,
    "line": 1631,
    "column": 39,
    "evidence": {
      "startLine": 1621,
      "endLine": 1641,
      "focusLine": 1631,
      "lines": [
        "  Alert_Box(\"REMOVE\")",
        "",
        "  ThreadObject():QUIT()",
        "//  Break()   // We are not going back!",
        "RETURN",
        "// EOP ReportDataError",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE Message2ErrorLog(cMsg)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "LOCAL cErrorLog",
        "LOCAL lPrint, lConsole, cAlternate, lAlternate, lExtra",
        "/* Save current printer related settings, turn printer off */",
        "BEGIN SEQUENCE",
        "lPrint     :\u003d Set( _SET_PRINTER )",
        "lConsole   :\u003d Set( _SET_CONSOLE )",
        "cAlternate :\u003d Set( _SET_ALTFILE )",
        "lAlternate :\u003d Set( _SET_ALTERNATE )",
        "lExtra     :\u003d Set( _SET_EXTRA, .F. )",
        ""
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 50584",
    "offset": 50584,
    "line": 1631,
    "column": 39,
    "evidence": {
      "startLine": 1621,
      "endLine": 1641,
      "focusLine": 1631,
      "lines": [
        "  Alert_Box(\"REMOVE\")",
        "",
        "  ThreadObject():QUIT()",
        "//  Break()   // We are not going back!",
        "RETURN",
        "// EOP ReportDataError",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE Message2ErrorLog(cMsg)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "LOCAL cErrorLog",
        "LOCAL lPrint, lConsole, cAlternate, lAlternate, lExtra",
        "/* Save current printer related settings, turn printer off */",
        "BEGIN SEQUENCE",
        "lPrint     :\u003d Set( _SET_PRINTER )",
        "lConsole   :\u003d Set( _SET_CONSOLE )",
        "cAlternate :\u003d Set( _SET_ALTFILE )",
        "lAlternate :\u003d Set( _SET_ALTERNATE )",
        "lExtra     :\u003d Set( _SET_EXTRA, .F. )",
        ""
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 50587",
    "offset": 50587,
    "line": 1631,
    "column": 42,
    "evidence": {
      "startLine": 1621,
      "endLine": 1641,
      "focusLine": 1631,
      "lines": [
        "  Alert_Box(\"REMOVE\")",
        "",
        "  ThreadObject():QUIT()",
        "//  Break()   // We are not going back!",
        "RETURN",
        "// EOP ReportDataError",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE Message2ErrorLog(cMsg)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "LOCAL cErrorLog",
        "LOCAL lPrint, lConsole, cAlternate, lAlternate, lExtra",
        "/* Save current printer related settings, turn printer off */",
        "BEGIN SEQUENCE",
        "lPrint     :\u003d Set( _SET_PRINTER )",
        "lConsole   :\u003d Set( _SET_CONSOLE )",
        "cAlternate :\u003d Set( _SET_ALTFILE )",
        "lAlternate :\u003d Set( _SET_ALTERNATE )",
        "lExtra     :\u003d Set( _SET_EXTRA, .F. )",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token RBRACE at 50587",
    "offset": 50587,
    "line": 1631,
    "column": 42,
    "evidence": {
      "startLine": 1621,
      "endLine": 1641,
      "focusLine": 1631,
      "lines": [
        "  Alert_Box(\"REMOVE\")",
        "",
        "  ThreadObject():QUIT()",
        "//  Break()   // We are not going back!",
        "RETURN",
        "// EOP ReportDataError",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE Message2ErrorLog(cMsg)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "LOCAL cErrorLog",
        "LOCAL lPrint, lConsole, cAlternate, lAlternate, lExtra",
        "/* Save current printer related settings, turn printer off */",
        "BEGIN SEQUENCE",
        "lPrint     :\u003d Set( _SET_PRINTER )",
        "lConsole   :\u003d Set( _SET_CONSOLE )",
        "cAlternate :\u003d Set( _SET_ALTFILE )",
        "lAlternate :\u003d Set( _SET_ALTERNATE )",
        "lExtra     :\u003d Set( _SET_EXTRA, .F. )",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 51048",
    "offset": 51048,
    "line": 1648,
    "column": 1,
    "evidence": {
      "startLine": 1638,
      "endLine": 1658,
      "focusLine": 1648,
      "lines": [
        "cAlternate :\u003d Set( _SET_ALTFILE )",
        "lAlternate :\u003d Set( _SET_ALTERNATE )",
        "lExtra     :\u003d Set( _SET_EXTRA, .F. )",
        "",
        "SET PRINTER OFF",
        "SET CONSOLE ON",
        "",
        "IF SetAppWindow() \u003d\u003d NIL ;",
        "  .OR. .NOT. SetAppWindow():isDerivedFrom( RootCrt() )",
        "   SET CONSOLE OFF",
        "ENDIF",
        "",
        "cErrorLog :\u003d RootPath()+\"PrgError.LOG\"",
        "SET ALTERNATE TO (cErrorLog) ADDITIVE",
        "SET ALTERNATE ON",
        "",
        "? Replicate( \"-\", 70 )",
        "? \u0027ERROR LOG of \"\u0027+ appName(.T.) +\u0027\" Date:\u0027, Date(), Time()",
        "?",
        "? \"Court                : \"+IIF(valtype(mCourt)\u003d\u003d\"C\".AND.!empty(mCourt),mCourt,\"Unknown\")",
        "IF valType(aUser)\u003d\"A\" .AND. len(aUser)\u003e5 .AND. valtype(aUser[5])\u003d\"C\""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 51499",
    "offset": 51499,
    "line": 1661,
    "column": 3,
    "evidence": {
      "startLine": 1651,
      "endLine": 1671,
      "focusLine": 1661,
      "lines": [
        "SET ALTERNATE TO (cErrorLog) ADDITIVE",
        "SET ALTERNATE ON",
        "",
        "? Replicate( \"-\", 70 )",
        "? \u0027ERROR LOG of \"\u0027+ appName(.T.) +\u0027\" Date:\u0027, Date(), Time()",
        "?",
        "? \"Court                : \"+IIF(valtype(mCourt)\u003d\u003d\"C\".AND.!empty(mCourt),mCourt,\"Unknown\")",
        "IF valType(aUser)\u003d\"A\" .AND. len(aUser)\u003e5 .AND. valtype(aUser[5])\u003d\"C\"",
        "  IF valType(aClient)\u003d\"A\" .AND. len(aClient)\u003e1 .AND.valtype(aClient[2])\u003d\"C\"",
        "    ?? \"  --  \"+aClient[2]",
        "  ENDIF",
        "  ? \"Current User         : \"+alltrim(aUser[5])",
        "ENDIF",
        "? \"Operating system     :\" , Os()",
        "? \"CourtRoom Program    :\" , SEI_VERSION(4)",
        "? \"Available Memory     : Process: \"+alltrim(CommaForm(Memory(0),12))+;",
        "             \"KB / System: \"+alltrim(CommaForm(Memory(2), 12))+\"KB\"",
        "? Replicate( \"-\", 70 )",
        "?",
        "DO WHILE \";\"$cMsg",
        "  ? substr(cMsg,1,at(\";\",cMsg)-1)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 51553",
    "offset": 51553,
    "line": 1663,
    "column": 1,
    "evidence": {
      "startLine": 1653,
      "endLine": 1673,
      "focusLine": 1663,
      "lines": [
        "",
        "? Replicate( \"-\", 70 )",
        "? \u0027ERROR LOG of \"\u0027+ appName(.T.) +\u0027\" Date:\u0027, Date(), Time()",
        "?",
        "? \"Court                : \"+IIF(valtype(mCourt)\u003d\u003d\"C\".AND.!empty(mCourt),mCourt,\"Unknown\")",
        "IF valType(aUser)\u003d\"A\" .AND. len(aUser)\u003e5 .AND. valtype(aUser[5])\u003d\"C\"",
        "  IF valType(aClient)\u003d\"A\" .AND. len(aClient)\u003e1 .AND.valtype(aClient[2])\u003d\"C\"",
        "    ?? \"  --  \"+aClient[2]",
        "  ENDIF",
        "  ? \"Current User         : \"+alltrim(aUser[5])",
        "ENDIF",
        "? \"Operating system     :\" , Os()",
        "? \"CourtRoom Program    :\" , SEI_VERSION(4)",
        "? \"Available Memory     : Process: \"+alltrim(CommaForm(Memory(0),12))+;",
        "             \"KB / System: \"+alltrim(CommaForm(Memory(2), 12))+\"KB\"",
        "? Replicate( \"-\", 70 )",
        "?",
        "DO WHILE \";\"$cMsg",
        "  ? substr(cMsg,1,at(\";\",cMsg)-1)",
        "  cMsg :\u003d substr(cMsg,at(\";\",cMsg)+1)",
        "ENDDO"
      ]
    }
  },
  {
    "message": "Unexpected token DO at 51802",
    "offset": 51802,
    "line": 1670,
    "column": 1,
    "evidence": {
      "startLine": 1660,
      "endLine": 1680,
      "focusLine": 1670,
      "lines": [
        "    ?? \"  --  \"+aClient[2]",
        "  ENDIF",
        "  ? \"Current User         : \"+alltrim(aUser[5])",
        "ENDIF",
        "? \"Operating system     :\" , Os()",
        "? \"CourtRoom Program    :\" , SEI_VERSION(4)",
        "? \"Available Memory     : Process: \"+alltrim(CommaForm(Memory(0),12))+;",
        "             \"KB / System: \"+alltrim(CommaForm(Memory(2), 12))+\"KB\"",
        "? Replicate( \"-\", 70 )",
        "?",
        "DO WHILE \";\"$cMsg",
        "  ? substr(cMsg,1,at(\";\",cMsg)-1)",
        "  cMsg :\u003d substr(cMsg,at(\";\",cMsg)+1)",
        "ENDDO",
        "",
        "IF !empty(cMsg)  // last line",
        "  ? cMsg",
        "ENDIF",
        "?",
        "SET ALTERNATE TO",
        "SET ALTERNATE OFF"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027?\u0027 at 51805",
    "offset": 51805,
    "line": 1670,
    "column": 4,
    "evidence": {
      "startLine": 1660,
      "endLine": 1680,
      "focusLine": 1670,
      "lines": [
        "    ?? \"  --  \"+aClient[2]",
        "  ENDIF",
        "  ? \"Current User         : \"+alltrim(aUser[5])",
        "ENDIF",
        "? \"Operating system     :\" , Os()",
        "? \"CourtRoom Program    :\" , SEI_VERSION(4)",
        "? \"Available Memory     : Process: \"+alltrim(CommaForm(Memory(0),12))+;",
        "             \"KB / System: \"+alltrim(CommaForm(Memory(2), 12))+\"KB\"",
        "? Replicate( \"-\", 70 )",
        "?",
        "DO WHILE \";\"$cMsg",
        "  ? substr(cMsg,1,at(\";\",cMsg)-1)",
        "  cMsg :\u003d substr(cMsg,at(\";\",cMsg)+1)",
        "ENDDO",
        "",
        "IF !empty(cMsg)  // last line",
        "  ? cMsg",
        "ENDIF",
        "?",
        "SET ALTERNATE TO",
        "SET ALTERNATE OFF"
      ]
    }
  },
  {
    "message": "Unexpected token TO at 51960",
    "offset": 51960,
    "line": 1679,
    "column": 15,
    "evidence": {
      "startLine": 1669,
      "endLine": 1689,
      "focusLine": 1679,
      "lines": [
        "?",
        "DO WHILE \";\"$cMsg",
        "  ? substr(cMsg,1,at(\";\",cMsg)-1)",
        "  cMsg :\u003d substr(cMsg,at(\";\",cMsg)+1)",
        "ENDDO",
        "",
        "IF !empty(cMsg)  // last line",
        "  ? cMsg",
        "ENDIF",
        "?",
        "SET ALTERNATE TO",
        "SET ALTERNATE OFF",
        "",
        "/* Restore previous settings */",
        "Set( _SET_PRINTER,   lPrint)",
        "Set( _SET_CONSOLE,   lConsole)",
        "Set( _SET_ALTFILE,   cAlternate)",
        "Set( _SET_ALTERNATE, lAlternate)",
        "Set( _SET_EXTRA,     lExtra)",
        "ENDSEQUENCE",
        "ErrorBlock( bError )"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 52606",
    "offset": 52606,
    "line": 1701,
    "column": 7,
    "evidence": {
      "startLine": 1691,
      "endLine": 1711,
      "focusLine": 1701,
      "lines": [
        "// EOP Message2ErrorLog",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION HelpSet(cnHelpRef)",
        "  LOCAL oldVal:\u003d0",
        "  IF IsObject(RootWindow()) .AND. RootWindow():status()\u003dXBP_STAT_CREATE",
        "    IF IsObject(RootWindow():helpLink) .AND. RootWindow():helpLink:status()\u003dXBP_STAT_CREATE",
        "      IF IsMemberVar( RootWindow():helpLink, \"helpID\" )",
        "        oldVal :\u003d RootWindow():helpLink:helpID",
        "      ENDIF",
        "      IF !ValType(cnHelpRef)$\"NC\"",
        "        cnHelpRef:\u003d\"\"",
        "      ENDIF",
        "      RootWindow():helpLink:Configure(cnHelpRef)",
        "    ENDIF",
        "  ENDIF",
        "RETURN oldVal",
        "// EOF HelpSet",
        "",
        "//"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 52733",
    "offset": 52733,
    "line": 1706,
    "column": 5,
    "evidence": {
      "startLine": 1696,
      "endLine": 1716,
      "focusLine": 1706,
      "lines": [
        "  LOCAL oldVal:\u003d0",
        "  IF IsObject(RootWindow()) .AND. RootWindow():status()\u003dXBP_STAT_CREATE",
        "    IF IsObject(RootWindow():helpLink) .AND. RootWindow():helpLink:status()\u003dXBP_STAT_CREATE",
        "      IF IsMemberVar( RootWindow():helpLink, \"helpID\" )",
        "        oldVal :\u003d RootWindow():helpLink:helpID",
        "      ENDIF",
        "      IF !ValType(cnHelpRef)$\"NC\"",
        "        cnHelpRef:\u003d\"\"",
        "      ENDIF",
        "      RootWindow():helpLink:Configure(cnHelpRef)",
        "    ENDIF",
        "  ENDIF",
        "RETURN oldVal",
        "// EOF HelpSet",
        "",
        "//",
        "//-----------------------------------------------",
        "// cxJudge     \u003d Judge initials to test",
        "// cRegBailPrk \u003d \u0027R\u0027/\u0027B\u0027/\u0027P\u0027  for Regular, Bail, or Parking tests",
        "// lZZZOK      \u003d .F. if \u0027ZZZ\u0027 is _NOT_ to match",
        "// lSet        \u003d .T. for new judge setup of static vars"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 52741",
    "offset": 52741,
    "line": 1707,
    "column": 3,
    "evidence": {
      "startLine": 1697,
      "endLine": 1717,
      "focusLine": 1707,
      "lines": [
        "  IF IsObject(RootWindow()) .AND. RootWindow():status()\u003dXBP_STAT_CREATE",
        "    IF IsObject(RootWindow():helpLink) .AND. RootWindow():helpLink:status()\u003dXBP_STAT_CREATE",
        "      IF IsMemberVar( RootWindow():helpLink, \"helpID\" )",
        "        oldVal :\u003d RootWindow():helpLink:helpID",
        "      ENDIF",
        "      IF !ValType(cnHelpRef)$\"NC\"",
        "        cnHelpRef:\u003d\"\"",
        "      ENDIF",
        "      RootWindow():helpLink:Configure(cnHelpRef)",
        "    ENDIF",
        "  ENDIF",
        "RETURN oldVal",
        "// EOF HelpSet",
        "",
        "//",
        "//-----------------------------------------------",
        "// cxJudge     \u003d Judge initials to test",
        "// cRegBailPrk \u003d \u0027R\u0027/\u0027B\u0027/\u0027P\u0027  for Regular, Bail, or Parking tests",
        "// lZZZOK      \u003d .F. if \u0027ZZZ\u0027 is _NOT_ to match",
        "// lSet        \u003d .T. for new judge setup of static vars",
        "//    SameJudge(NIL,NIL,NIL,.T.)  to force setup of all three STATIC JudgeLists"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 56188",
    "offset": 56188,
    "line": 1823,
    "column": 5,
    "evidence": {
      "startLine": 1813,
      "endLine": 1833,
      "focusLine": 1823,
      "lines": [
        "//",
        "// RETURNs The number of scoffable charges on a case.",
        "// Note: Now that failure to pay is not valid, a charge\u0027s dispo STAT/SEC is irrelevant.",
        "//       Only the original STAT/SEC matters.",
        "//-----------------------------------------------",
        "FUNCTION VTLCount(axLocals)",
        "LOCAL x, y:\u003d0",
        "  FOR x :\u003d 1 TO len(aCharge)",
        "    IF IsVTLCharge(axLocals, x)",
        "      y++",
        "    ENDIF",
        "  NEXT",
        "RETURN y",
        "// EOF VTLCount",
        "",
        "//",
        "// The logic to determine if a single charge is a VTL, and also Scoffable.",
        "// This was separated out from VTLCount() so that it could be used to determine if a single charge was Scoffable.",
        "//-----------------------------------------------",
        "FUNCTION IsVTLCharge(axLocals, nChargeIndex)",
        "LOCAL nRet:\u003d.F."
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 56196",
    "offset": 56196,
    "line": 1824,
    "column": 3,
    "evidence": {
      "startLine": 1814,
      "endLine": 1834,
      "focusLine": 1824,
      "lines": [
        "// RETURNs The number of scoffable charges on a case.",
        "// Note: Now that failure to pay is not valid, a charge\u0027s dispo STAT/SEC is irrelevant.",
        "//       Only the original STAT/SEC matters.",
        "//-----------------------------------------------",
        "FUNCTION VTLCount(axLocals)",
        "LOCAL x, y:\u003d0",
        "  FOR x :\u003d 1 TO len(aCharge)",
        "    IF IsVTLCharge(axLocals, x)",
        "      y++",
        "    ENDIF",
        "  NEXT",
        "RETURN y",
        "// EOF VTLCount",
        "",
        "//",
        "// The logic to determine if a single charge is a VTL, and also Scoffable.",
        "// This was separated out from VTLCount() so that it could be used to determine if a single charge was Scoffable.",
        "//-----------------------------------------------",
        "FUNCTION IsVTLCharge(axLocals, nChargeIndex)",
        "LOCAL nRet:\u003d.F.",
        "  IF (aCharge[nChargeIndex,ccOStatute] \u003d\u003d \"VTL\" .OR. aCharge[nChargeIndex,ccOStatute] \u003d\u003d \"TL \";"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 56196",
    "offset": 56196,
    "line": 1824,
    "column": 3,
    "evidence": {
      "startLine": 1814,
      "endLine": 1834,
      "focusLine": 1824,
      "lines": [
        "// RETURNs The number of scoffable charges on a case.",
        "// Note: Now that failure to pay is not valid, a charge\u0027s dispo STAT/SEC is irrelevant.",
        "//       Only the original STAT/SEC matters.",
        "//-----------------------------------------------",
        "FUNCTION VTLCount(axLocals)",
        "LOCAL x, y:\u003d0",
        "  FOR x :\u003d 1 TO len(aCharge)",
        "    IF IsVTLCharge(axLocals, x)",
        "      y++",
        "    ENDIF",
        "  NEXT",
        "RETURN y",
        "// EOF VTLCount",
        "",
        "//",
        "// The logic to determine if a single charge is a VTL, and also Scoffable.",
        "// This was separated out from VTLCount() so that it could be used to determine if a single charge was Scoffable.",
        "//-----------------------------------------------",
        "FUNCTION IsVTLCharge(axLocals, nChargeIndex)",
        "LOCAL nRet:\u003d.F.",
        "  IF (aCharge[nChargeIndex,ccOStatute] \u003d\u003d \"VTL\" .OR. aCharge[nChargeIndex,ccOStatute] \u003d\u003d \"TL \";"
      ]
    }
  },
  {
    "message": "Unexpected token LBRACKET at 61558",
    "offset": 61558,
    "line": 1991,
    "column": 43,
    "evidence": {
      "startLine": 1981,
      "endLine": 2001,
      "focusLine": 1991,
      "lines": [
        "//",
        "//-----------------------------------------------     // cInOut \u003d\u003e (D)ecript or (E)ncript",
        "FUNCTION CriptStr(inStr, cInOut, cRev)                // inStr  \u003d\u003e Character or Memo string",
        "RETURN Shared_CriptStr(@inStr, @cInOut, @cRev)                                   ",
        "// EOF CriptStr",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE MarkField( oXbp, nColor )",
        "",
        "LOCAL oPS, nCol, nRow, nWide, nHigh, aAttr[ GRA_AA_COUNT]",
        "",
        "nCol   :\u003d oXbp:currentpos()[1]",
        "nRow   :\u003d oXbp:currentpos()[2]",
        "nWide  :\u003d oXbp:currentsize()[1]",
        "nHigh  :\u003d oXbp:currentsize()[2]",
        "",
        "oPS :\u003d oXbp:setParent():lockPS()",
        "",
        "aAttr[ GRA_AA_COLOR ] :\u003d nColor",
        "GraSetAttrLine( oPS, aAttr )"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 62200",
    "offset": 62200,
    "line": 2015,
    "column": 1,
    "evidence": {
      "startLine": 2005,
      "endLine": 2025,
      "focusLine": 2015,
      "lines": [
        "RETURN",
        "// EOP MarkField",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE NEWJUDGE()",
        "LOCAL oDlg, oDraw, getList:\u003d{}, x, oldScrn, cJNames:\u003d{}, oChoice, ;",
        "      GetOptions, oldJudge, oldFocus",
        "IF niNumJudge \u003d\u003d 1 .AND. !isCAP()",
        "  RETURN                       // There is only one judge, ignore request",
        "ENDIF",
        "",
        "IF !Level_Chk(5) .AND. !isCAP()",
        "  RETURN",
        "ENDIF",
        "",
        "oldScrn :\u003d Scn_No(045)",
        "oldJudge :\u003d mcJudge",
        "oldFocus :\u003d setAppFocus(RootWindow())",
        "CurReadLev(1)     // update the readlevel indicator  2/11/02",
        "IF isCAP()"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 64483",
    "offset": 64483,
    "line": 2084,
    "column": 40,
    "evidence": {
      "startLine": 2074,
      "endLine": 2094,
      "focusLine": 2084,
      "lines": [
        "              SCREEN 213           ;",
        "              NOWINMENU            ;",
        "              MODAL                ;",
        "              helpref CRP_START",
        "",
        "  oDraw :\u003d oDlg:DrawingArea                          // Reference to base screen",
        "",
        "  IF !empty(cTitle2)",
        "    @  4, 5  DCSAY cTitle2 ;",
        "              SAYSIZE 0    ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT ;",
        "              SAYFONT cStdLargeSay",
        "  ENDIF",
        "  @  5, 1  DCSAY \u0027\u0027  // needed for AUTOFIT to hold left margin",
        "  @  5, 5  DCSAY cTitle ;",
        "            SAYSIZE 0   ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT ;",
        "            SAYFONT cStdLargeSay",
        "  IF ascan(aJudge,{|x|ciJudge1\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge1\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  7, 9  DCSAY cJNames[1] SAYSIZE 40"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 64703",
    "offset": 64703,
    "line": 2090,
    "column": 38,
    "evidence": {
      "startLine": 2080,
      "endLine": 2100,
      "focusLine": 2090,
      "lines": [
        "",
        "  IF !empty(cTitle2)",
        "    @  4, 5  DCSAY cTitle2 ;",
        "              SAYSIZE 0    ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT ;",
        "              SAYFONT cStdLargeSay",
        "  ENDIF",
        "  @  5, 1  DCSAY \u0027\u0027  // needed for AUTOFIT to hold left margin",
        "  @  5, 5  DCSAY cTitle ;",
        "            SAYSIZE 0   ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT ;",
        "            SAYFONT cStdLargeSay",
        "  IF ascan(aJudge,{|x|ciJudge1\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge1\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  7, 9  DCSAY cJNames[1] SAYSIZE 40",
        "  ELSE",
        "    aAdd(cJNames,\u0027\u0027)",
        "  ENDIF",
        "  IF   niNumJudge \u003e 1 .AND. ascan(aJudge,{|x|ciJudge2\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge2\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  8, 9  DCSAY cJNames[2] SAYSIZE 40"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 64940",
    "offset": 64940,
    "line": 2095,
    "column": 3,
    "evidence": {
      "startLine": 2085,
      "endLine": 2105,
      "focusLine": 2095,
      "lines": [
        "              SAYFONT cStdLargeSay",
        "  ENDIF",
        "  @  5, 1  DCSAY \u0027\u0027  // needed for AUTOFIT to hold left margin",
        "  @  5, 5  DCSAY cTitle ;",
        "            SAYSIZE 0   ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT ;",
        "            SAYFONT cStdLargeSay",
        "  IF ascan(aJudge,{|x|ciJudge1\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge1\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  7, 9  DCSAY cJNames[1] SAYSIZE 40",
        "  ELSE",
        "    aAdd(cJNames,\u0027\u0027)",
        "  ENDIF",
        "  IF   niNumJudge \u003e 1 .AND. ascan(aJudge,{|x|ciJudge2\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge2\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  8, 9  DCSAY cJNames[2] SAYSIZE 40",
        "  ELSE",
        "    aAdd(cJNames,\u0027\u0027)",
        "  ENDIF",
        "  IF niNumJudge \u003e 2 .AND. ascan(aJudge,{|x|ciJudge3\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge3\u003d\u003dx[cjInitials]}),cjName]))"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 64968",
    "offset": 64968,
    "line": 2097,
    "column": 3,
    "evidence": {
      "startLine": 2087,
      "endLine": 2107,
      "focusLine": 2097,
      "lines": [
        "  @  5, 1  DCSAY \u0027\u0027  // needed for AUTOFIT to hold left margin",
        "  @  5, 5  DCSAY cTitle ;",
        "            SAYSIZE 0   ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT ;",
        "            SAYFONT cStdLargeSay",
        "  IF ascan(aJudge,{|x|ciJudge1\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge1\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  7, 9  DCSAY cJNames[1] SAYSIZE 40",
        "  ELSE",
        "    aAdd(cJNames,\u0027\u0027)",
        "  ENDIF",
        "  IF   niNumJudge \u003e 1 .AND. ascan(aJudge,{|x|ciJudge2\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge2\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  8, 9  DCSAY cJNames[2] SAYSIZE 40",
        "  ELSE",
        "    aAdd(cJNames,\u0027\u0027)",
        "  ENDIF",
        "  IF niNumJudge \u003e 2 .AND. ascan(aJudge,{|x|ciJudge3\u003d\u003dx[cjInitials]})\u003e0",
        "    aAdd(cJNames,alltrim(aJudge[ascan(aJudge, {|x|ciJudge3\u003d\u003dx[cjInitials]}),cjName]))",
        "    @  9, 9  DCSAY cJNames[3] SAYSIZE 40",
        "  ELSE"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 66336",
    "offset": 66336,
    "line": 2135,
    "column": 11,
    "evidence": {
      "startLine": 2125,
      "endLine": 2145,
      "focusLine": 2135,
      "lines": [
        "  ELSE",
        "    aAdd(cJNames,\u0027\u0027)",
        "  ENDIF",
        "",
        "  FOR x :\u003d 1 to niNumJudge",
        "  @ x+5.85, 5 DCPUSHBUTTON ;",
        "    CAPTION str(x,1)    ;",
        "    TOOLTIP \"Select Judge \"+cJNames[x] ;",
        "    WHEN CkJudge(x,cJNames) ;",
        "    FONT BTN_FONT_B     ;",
        "    SIZE 3, 1           ;",
        "    ACTION BuildBlock(@mchoice, x, @GetList)",
        "  NEXT",
        "  x :\u003d niNumJudge+7.5",
        "",
        "  @ x, 6 DCSAY \"Selection: \" GET mchoice  ;",
        "         PICTURE \u00279\u0027 ;",
        "         SAYFONT BTN_FONT_B ;",
        "         GETOBJECT oChoice  ;",
        "         NOCONFIRM   ;",
        "         SAYRIGHT    ;"
      ]
    }
  },
  {
    "message": "Unexpected token GET at 66456",
    "offset": 66456,
    "line": 2140,
    "column": 30,
    "evidence": {
      "startLine": 2130,
      "endLine": 2150,
      "focusLine": 2140,
      "lines": [
        "  @ x+5.85, 5 DCPUSHBUTTON ;",
        "    CAPTION str(x,1)    ;",
        "    TOOLTIP \"Select Judge \"+cJNames[x] ;",
        "    WHEN CkJudge(x,cJNames) ;",
        "    FONT BTN_FONT_B     ;",
        "    SIZE 3, 1           ;",
        "    ACTION BuildBlock(@mchoice, x, @GetList)",
        "  NEXT",
        "  x :\u003d niNumJudge+7.5",
        "",
        "  @ x, 6 DCSAY \"Selection: \" GET mchoice  ;",
        "         PICTURE \u00279\u0027 ;",
        "         SAYFONT BTN_FONT_B ;",
        "         GETOBJECT oChoice  ;",
        "         NOCONFIRM   ;",
        "         SAYRIGHT    ;",
        "         SAYSIZE 14  ;",
        "         VALID {|| mchoice\u003e0 .AND. mchoice\u003c\u003dniNumJudge .AND. !empty(cJNames[mchoice]) }",
        "  x +\u003d 2",
        "  IF empty(cTitle2)",
        "    @ x, 1 DCPUSHBUTTON ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 67378",
    "offset": 67378,
    "line": 2167,
    "column": 3,
    "evidence": {
      "startLine": 2157,
      "endLine": 2177,
      "focusLine": 2167,
      "lines": [
        "              ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList) }",
        "",
        "    @ x,12 DCPUSHBUTTON ;",
        "              CAPTION \"~CANCEL\" ;",
        "              TOOLTIP \"Quit without selecting a Judge\" ;",
        "              TABSTOP           ;",
        "              ACCELKEY xbeK_CTRL_C ;",
        "              FONT BTN_FONT_B   ;",
        "              SIZE 10, 1.3      ;",
        "              ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_ABORT, GetList) }",
        "  ENDIF",
        "",
        "  DCHOTKEY xbeK_F1 WHEN {||oDlg:getFrameState()\u003c\u003eXBPDLG_FRAMESTAT_MINIMIZED} ;",
        "               ACTION {||HelpObject():showhelp(CRP_BC_WUTCJ) }",
        "",
        "  DCGETOPTIONS  NOMAXBUTTON ;",
        "                SAYFONT BTN_FONT_B ;",
        "                NOMINBUTTON",
        "",
        "  DCREAD GUI TO lOK         ;",
        "         OPTIONS GetOptions ;"
      ]
    }
  },
  {
    "message": "Unexpected token TO at 67637",
    "offset": 67637,
    "line": 2176,
    "column": 14,
    "evidence": {
      "startLine": 2166,
      "endLine": 2186,
      "focusLine": 2176,
      "lines": [
        "              ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_ABORT, GetList) }",
        "  ENDIF",
        "",
        "  DCHOTKEY xbeK_F1 WHEN {||oDlg:getFrameState()\u003c\u003eXBPDLG_FRAMESTAT_MINIMIZED} ;",
        "               ACTION {||HelpObject():showhelp(CRP_BC_WUTCJ) }",
        "",
        "  DCGETOPTIONS  NOMAXBUTTON ;",
        "                SAYFONT BTN_FONT_B ;",
        "                NOMINBUTTON",
        "",
        "  DCREAD GUI TO lOK         ;",
        "         OPTIONS GetOptions ;",
        "         FIT                ;",
        "         PARENT @oDlg       ;",
        "         ENTEREXIT          ;",
        "         EVAL {|oDlg| oDlg:SetPos(CenterScnPos(oDlg:currentSize(),RootWindow())), ;",
        "               SetAppFocus(oDlg),;",
        "               SetAppFocus(oChoice),;",
        "               LockSize(oDlg) }                 //  IIF(!Ok2Resize(),LockSize(oDlg),NIL),;",
        "  GetList:\u003d{}",
        "  oDlg:setModalState(XBP_DISP_MODELESS)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 68165",
    "offset": 68165,
    "line": 2192,
    "column": 3,
    "evidence": {
      "startLine": 2182,
      "endLine": 2202,
      "focusLine": 2192,
      "lines": [
        "               SetAppFocus(oDlg),;",
        "               SetAppFocus(oChoice),;",
        "               LockSize(oDlg) }                 //  IIF(!Ok2Resize(),LockSize(oDlg),NIL),;",
        "  GetList:\u003d{}",
        "  oDlg:setModalState(XBP_DISP_MODELESS)",
        "  DestroyAll( @oDlg )",
        "  oDlg       :\u003d NIL",
        "",
        "  IF lOK",
        "    newJdg :\u003d JudgeFromNo(mChoice)",
        "  ENDIF",
        "  Scn_No(oldScn)",
        "RETURN newJdg",
        "// EOF PickJudge",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION JudgeFromNo(mChoice)",
        "v_valtype(@mChoice,1)",
        "IF mChoice\u003c1 .OR. mChoice\u003eniNumJudge",
        "  mChoice :\u003d 1"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 69449",
    "offset": 69449,
    "line": 2240,
    "column": 20,
    "evidence": {
      "startLine": 2230,
      "endLine": 2250,
      "focusLine": 2240,
      "lines": [
        "",
        "  axJudge[cjOptions] :\u003d cOptions",
        "RETURN NIL",
        "// EOF SetcjOptions",
        "",
        "//",
        "//-----------------------------------------------",
        "// You need to anchor each value of x by creating detached codeblocks, like this:",
        "// BTW - Don\u0027t forget to pass GetList to DC_ReadGuiEvent().",
        "FUNCTION BuildBlock( mChoice, x, GetList )",
        "RETURN {|| mChoice :\u003d x, DC_GetRefresh(GetList),;",
        "           DC_ReadGuiEvent(DCGUI_EXIT_OK,GetList) }",
        "// EOF BuildBlock",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION ShortJudge(xJudge)",
        "LOCAL RetJudge",
        "  v_valType(@xJudge, mcJudge)",
        "  RetJudge :\u003d IIF(xjudge\u003d\u003dciJudge1,\u00271\u0027,IIF(xjudge\u003d\u003dciJudge2,\u00272\u0027,;",
        "              IIF(xjudge\u003d\u003dciJudge3,\u00273\u0027,IIF(xjudge\u003d\u003dciJudge4,\u00274\u0027,;"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 69449",
    "offset": 69449,
    "line": 2240,
    "column": 20,
    "evidence": {
      "startLine": 2230,
      "endLine": 2250,
      "focusLine": 2240,
      "lines": [
        "",
        "  axJudge[cjOptions] :\u003d cOptions",
        "RETURN NIL",
        "// EOF SetcjOptions",
        "",
        "//",
        "//-----------------------------------------------",
        "// You need to anchor each value of x by creating detached codeblocks, like this:",
        "// BTW - Don\u0027t forget to pass GetList to DC_ReadGuiEvent().",
        "FUNCTION BuildBlock( mChoice, x, GetList )",
        "RETURN {|| mChoice :\u003d x, DC_GetRefresh(GetList),;",
        "           DC_ReadGuiEvent(DCGUI_EXIT_OK,GetList) }",
        "// EOF BuildBlock",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION ShortJudge(xJudge)",
        "LOCAL RetJudge",
        "  v_valType(@xJudge, mcJudge)",
        "  RetJudge :\u003d IIF(xjudge\u003d\u003dciJudge1,\u00271\u0027,IIF(xjudge\u003d\u003dciJudge2,\u00272\u0027,;",
        "              IIF(xjudge\u003d\u003dciJudge3,\u00273\u0027,IIF(xjudge\u003d\u003dciJudge4,\u00274\u0027,;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 69913",
    "offset": 69913,
    "line": 2254,
    "column": 3,
    "evidence": {
      "startLine": 2244,
      "endLine": 2264,
      "focusLine": 2254,
      "lines": [
        "//",
        "//-----------------------------------------------",
        "FUNCTION ShortJudge(xJudge)",
        "LOCAL RetJudge",
        "  v_valType(@xJudge, mcJudge)",
        "  RetJudge :\u003d IIF(xjudge\u003d\u003dciJudge1,\u00271\u0027,IIF(xjudge\u003d\u003dciJudge2,\u00272\u0027,;",
        "              IIF(xjudge\u003d\u003dciJudge3,\u00273\u0027,IIF(xjudge\u003d\u003dciJudge4,\u00274\u0027,;",
        "              IIF(xjudge\u003d\u003dciJudge5,\u00275\u0027, \u00276\u0027)))))",
        "  IF val(RetJudge) \u003e len(aJudge)",
        "    RetJudge :\u003d \u00271\u0027",
        "  ENDIF",
        "RETURN RetJudge",
        "//EOF ShortJudge",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION JudgeNum(xJudge)",
        "  v_valType(@xJudge, mcJudge)",
        "RETURN val(ShortJudge(xJudge))",
        "//EOF JudgeNum",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 75020",
    "offset": 75020,
    "line": 2393,
    "column": 1,
    "evidence": {
      "startLine": 2383,
      "endLine": 2403,
      "focusLine": 2393,
      "lines": [
        "RETURN",
        "// EOP ErrCorruptPrsFile",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE add_field( new_fn,new_ft,new_fl,new_dp )",
        "appe blank",
        "repl field_name WITH new_fn, field_type WITH new_ft",
        "IF pcount()\u003e2",
        " repl field_len WITH new_fl",
        "ENDIF",
        "IF pcount()\u003e3",
        " repl field_dec WITH new_dp",
        "ENDIF",
        "RETURN",
        "// EOP add_field",
        "",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION GetJudge(Jinitials, nItem, lTrim)   // GetJudge(\u0027ABC\u0027,cjName,.T.)--\u003e \u0027Alex B. Carr\u0027"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 79337",
    "offset": 79337,
    "line": 2549,
    "column": 47,
    "evidence": {
      "startLine": 2539,
      "endLine": 2559,
      "focusLine": 2549,
      "lines": [
        "IF Ok2Resize()",
        "  DCGETOPTIONS ICON ICON_GAVEL ;",
        "               SAYHEIGHT 18 GETHEIGHT 18 ;",
        "               NOCONFIRM ;",
        "               SAYOPTIONS XBPSTATIC_TEXT_BOTTOM ;",
        "               TABSTOP ;",
        "               CHECKGET ;",
        "               DISABLEDCOLOR GRA_CLR_BACKGROUND ;",
        "               GETFONT cStdGetFont ;",
        "               SAYFONT cStdSayFont ;",
        "               TOOLTIPCOLOR XBPSYSCLR_INFOTEXT, XBPSYSCLR_INFOBACKGROUND  ;",
        "               COLORGETS {{GRA_CLR_WHITE, GRA_CLR_RED},;",
        "                          {GRA_CLR_WHITE,GRA_CLR_DARKCYAN} } ;",
        "               RESIZE    ;",
        "               RESIZEDEFAULT DCGUI_RESIZE_AUTORESIZE_SCALEFONT",
        "ELSE",
        "  DCGETOPTIONS ICON ICON_GAVEL ;",
        "               SAYHEIGHT 18 GETHEIGHT 18 ;",
        "               NOCONFIRM ;",
        "               SAYOPTIONS XBPSTATIC_TEXT_BOTTOM ;",
        "               TABSTOP ;"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 79956",
    "offset": 79956,
    "line": 2564,
    "column": 47,
    "evidence": {
      "startLine": 2554,
      "endLine": 2574,
      "focusLine": 2564,
      "lines": [
        "ELSE",
        "  DCGETOPTIONS ICON ICON_GAVEL ;",
        "               SAYHEIGHT 18 GETHEIGHT 18 ;",
        "               NOCONFIRM ;",
        "               SAYOPTIONS XBPSTATIC_TEXT_BOTTOM ;",
        "               TABSTOP ;",
        "               CHECKGET ;",
        "               DISABLEDCOLOR GRA_CLR_BACKGROUND ;",
        "               GETFONT cStdGetFont ;",
        "               SAYFONT cStdSayFont ;",
        "               TOOLTIPCOLOR XBPSYSCLR_INFOTEXT, XBPSYSCLR_INFOBACKGROUND  ;",
        "               COLORGETS {{GRA_CLR_WHITE, GRA_CLR_RED},;",
        "                          {GRA_CLR_WHITE,GRA_CLR_DARKCYAN} } ;",
        "               NORESIZE  ;",
        "               RESIZEDEFAULT DCGUI_RESIZE_NONE",
        "ENDIF",
        "DC_GetOptDefault( GetOptions )",
        "",
        "RETURN",
        "// EOP GetOptionSetup",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token LBRACKET at 80392",
    "offset": 80392,
    "line": 2578,
    "column": 43,
    "evidence": {
      "startLine": 2568,
      "endLine": 2588,
      "focusLine": 2578,
      "lines": [
        "               RESIZEDEFAULT DCGUI_RESIZE_NONE",
        "ENDIF",
        "DC_GetOptDefault( GetOptions )",
        "",
        "RETURN",
        "// EOP GetOptionSetup",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE ReHiLite( o, nMode, nColor, baseColor)",
        "LOCAL oPS, nCol, nRow, nWide, nHigh, aAttr[ GRA_AL_COUNT]",
        "",
        "DEFAULT nColor TO GRA_CLR_RED, baseColor TO XBPSYSCLR_DIALOGBACKGROUND",
        "",
        "IF Empty(nColor) .OR. o:status() \u003c\u003d 0",
        "  RETURN",
        "ENDIF",
        "",
        "IF o:isderivedfrom(\u0027XBPCOMBOBOX\u0027)",
        "  nWide :\u003d o:XbpSle:currentsize()[1]",
        "  IF o:type # XBPCOMBO_SIMPLE"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 80528",
    "offset": 80528,
    "line": 2584,
    "column": 1,
    "evidence": {
      "startLine": 2574,
      "endLine": 2594,
      "focusLine": 2584,
      "lines": [
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE ReHiLite( o, nMode, nColor, baseColor)",
        "LOCAL oPS, nCol, nRow, nWide, nHigh, aAttr[ GRA_AL_COUNT]",
        "",
        "DEFAULT nColor TO GRA_CLR_RED, baseColor TO XBPSYSCLR_DIALOGBACKGROUND",
        "",
        "IF Empty(nColor) .OR. o:status() \u003c\u003d 0",
        "  RETURN",
        "ENDIF",
        "",
        "IF o:isderivedfrom(\u0027XBPCOMBOBOX\u0027)",
        "  nWide :\u003d o:XbpSle:currentsize()[1]",
        "  IF o:type # XBPCOMBO_SIMPLE",
        "    nHigh :\u003d 20",
        "    nCol :\u003d o:currentpos()[1]",
        "    nRow :\u003d o:currentpos()[2] + o:currentsize()[2] - 20",
        "  ELSE",
        "    nHigh :\u003d o:currentsize()[2]",
        "    nCol :\u003d o:currentpos()[1]"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 86370",
    "offset": 86370,
    "line": 2779,
    "column": 3,
    "evidence": {
      "startLine": 2769,
      "endLine": 2789,
      "focusLine": 2779,
      "lines": [
        "asort(aChkBk2,,,{|aX,aY|dtos(aX[dcbBankDate])+aX[ccbReceiptNo]+str(aX[ncbRecNo],7,0)\u003e;",
        "                        dtos(aY[dcbBankDate])+aY[ccbReceiptNo]+str(aY[ncbRecNo],7,0)})",
        "SetaOpenChgs( @axLocals )",
        "aVoidCB :\u003d {}",
        "IF SecureOK()",
        "  FillVoidCB( @aVoidCB, cmIndex9 )",
        "ENDIF",
        "FOR x :\u003d 1 to len(aCharge)",
        "  IF aCharge[x,lcScoffedChg]",
        "    nScoffCount++",
        "  ENDIF",
        "NEXT",
        "RETURN",
        "//EOP GetACase",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE SetaOpenChgs()",
        "LOCAL aFoundList:\u003d{}, oldOrder, oldRec, oldArea:\u003dSELE()",
        "PARAMETERS axLocals",
        "dbSelectArea(\"CHARGES\")"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 86376",
    "offset": 86376,
    "line": 2780,
    "column": 1,
    "evidence": {
      "startLine": 2770,
      "endLine": 2790,
      "focusLine": 2780,
      "lines": [
        "                        dtos(aY[dcbBankDate])+aY[ccbReceiptNo]+str(aY[ncbRecNo],7,0)})",
        "SetaOpenChgs( @axLocals )",
        "aVoidCB :\u003d {}",
        "IF SecureOK()",
        "  FillVoidCB( @aVoidCB, cmIndex9 )",
        "ENDIF",
        "FOR x :\u003d 1 to len(aCharge)",
        "  IF aCharge[x,lcScoffedChg]",
        "    nScoffCount++",
        "  ENDIF",
        "NEXT",
        "RETURN",
        "//EOP GetACase",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE SetaOpenChgs()",
        "LOCAL aFoundList:\u003d{}, oldOrder, oldRec, oldArea:\u003dSELE()",
        "PARAMETERS axLocals",
        "dbSelectArea(\"CHARGES\")",
        "oldOrder :\u003d OrdNumber()"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 86376",
    "offset": 86376,
    "line": 2780,
    "column": 1,
    "evidence": {
      "startLine": 2770,
      "endLine": 2790,
      "focusLine": 2780,
      "lines": [
        "                        dtos(aY[dcbBankDate])+aY[ccbReceiptNo]+str(aY[ncbRecNo],7,0)})",
        "SetaOpenChgs( @axLocals )",
        "aVoidCB :\u003d {}",
        "IF SecureOK()",
        "  FillVoidCB( @aVoidCB, cmIndex9 )",
        "ENDIF",
        "FOR x :\u003d 1 to len(aCharge)",
        "  IF aCharge[x,lcScoffedChg]",
        "    nScoffCount++",
        "  ENDIF",
        "NEXT",
        "RETURN",
        "//EOP GetACase",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE SetaOpenChgs()",
        "LOCAL aFoundList:\u003d{}, oldOrder, oldRec, oldArea:\u003dSELE()",
        "PARAMETERS axLocals",
        "dbSelectArea(\"CHARGES\")",
        "oldOrder :\u003d OrdNumber()"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 88964",
    "offset": 88964,
    "line": 2874,
    "column": 20,
    "evidence": {
      "startLine": 2864,
      "endLine": 2884,
      "focusLine": 2874,
      "lines": [
        "ENDIF",
        "",
        "RETURN",
        "// EOP GetRptCase",
        "",
        "//",
        "// NOTE: GetChkBook sets nAmtDue by calling ReFigAmtDue.",
        "//-----------------------------------------------",
        "PROCEDURE GetChkBook(axLocals)",
        "LOCAL nHidFine, nHidCivFee",
        "  nTotFine:\u003dnTotFee:\u003dnTotCivFee:\u003dnTotBail:\u003dnTotOther:\u003d0",
        "  nHidFine:\u003dnHidCivFee:\u003d0",
        "  lHiddenFine:\u003dlHiddenFee:\u003dlHiddenCivFee:\u003d.F.",
        "  lHiddenBail:\u003dlHiddenOther:\u003dlBailByOther:\u003d.F.",
        "",
        "  aSize(aChkBk2,0)",
        "  SELE CHKBOOK",
        "  FillChkBook( @aChkBk2, cmIndex9 )",
        "  AEval(aChkBk2, {|x,i|;",
        "          nTotFine  +\u003d IIF(x[ccbSpecial]\u003d\" \",x[ncbFine],0),; //  x[ncbFine],     ;",
        "          nHidFine  +\u003d IIF(x[ccbSpecial]\u003c\u003e\" \",x[ncbFine],0),;"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 93068",
    "offset": 93068,
    "line": 2973,
    "column": 3,
    "evidence": {
      "startLine": 2963,
      "endLine": 2983,
      "focusLine": 2973,
      "lines": [
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE ChkCivJudgment(axLocals, dAppear, lACsetOk)   // IF all charges are Civ Judgment close case",
        "LOCAL x, lOK:\u003d.F., dxxDate",
        "",
        "FOR x:\u003d1 TO len(aCharge)",
        "  IF \"CIV\"$upper(aCharge[x,ccDispTxt]) .AND. \"JUD\"$upper(aCharge[x,ccDispTxt]) .AND. !empty(aCharge[x,dcDispDate])",
        "    lOK :\u003d .T.",
        "    dxxDate :\u003d aCharge[x,dcDispDate]",
        "  ELSE",
        "    lOK :\u003d .F.",
        "    EXIT",
        "  ENDIF",
        "NEXT",
        "IF lOK",
        "  ccdCode  :\u003d cdxClosedCode",
        "  dAppear  :\u003d dxxDate",
        "  lACsetOk :\u003d .F.",
        "ENDIF",
        "RETURN"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 93099",
    "offset": 93099,
    "line": 2976,
    "column": 3,
    "evidence": {
      "startLine": 2966,
      "endLine": 2986,
      "focusLine": 2976,
      "lines": [
        "PROCEDURE ChkCivJudgment(axLocals, dAppear, lACsetOk)   // IF all charges are Civ Judgment close case",
        "LOCAL x, lOK:\u003d.F., dxxDate",
        "",
        "FOR x:\u003d1 TO len(aCharge)",
        "  IF \"CIV\"$upper(aCharge[x,ccDispTxt]) .AND. \"JUD\"$upper(aCharge[x,ccDispTxt]) .AND. !empty(aCharge[x,dcDispDate])",
        "    lOK :\u003d .T.",
        "    dxxDate :\u003d aCharge[x,dcDispDate]",
        "  ELSE",
        "    lOK :\u003d .F.",
        "    EXIT",
        "  ENDIF",
        "NEXT",
        "IF lOK",
        "  ccdCode  :\u003d cdxClosedCode",
        "  dAppear  :\u003d dxxDate",
        "  lACsetOk :\u003d .F.",
        "ENDIF",
        "RETURN",
        "// EOP ChkCivJudgment",
        "",
        "//"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 93105",
    "offset": 93105,
    "line": 2977,
    "column": 1,
    "evidence": {
      "startLine": 2967,
      "endLine": 2987,
      "focusLine": 2977,
      "lines": [
        "LOCAL x, lOK:\u003d.F., dxxDate",
        "",
        "FOR x:\u003d1 TO len(aCharge)",
        "  IF \"CIV\"$upper(aCharge[x,ccDispTxt]) .AND. \"JUD\"$upper(aCharge[x,ccDispTxt]) .AND. !empty(aCharge[x,dcDispDate])",
        "    lOK :\u003d .T.",
        "    dxxDate :\u003d aCharge[x,dcDispDate]",
        "  ELSE",
        "    lOK :\u003d .F.",
        "    EXIT",
        "  ENDIF",
        "NEXT",
        "IF lOK",
        "  ccdCode  :\u003d cdxClosedCode",
        "  dAppear  :\u003d dxxDate",
        "  lACsetOk :\u003d .F.",
        "ENDIF",
        "RETURN",
        "// EOP ChkCivJudgment",
        "",
        "//",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 95205",
    "offset": 95205,
    "line": 3031,
    "column": 1,
    "evidence": {
      "startLine": 3021,
      "endLine": 3041,
      "focusLine": 3031,
      "lines": [
        "         TITLE \"SEARCHING\"                             ;",
        "         SHOWPROGRESS",
        "",
        "dbSelectArea(\"CHARGES\")      // Save the old environment",
        "oldChgOrder :\u003d OrdNumber()",
        "oldChgRec   :\u003d RecNo()",
        "IF IsObject(oAlertBox[3])",
        "  oAlertBox[3]:current :\u003d 1                // oAlertBox[3] is oProgress bar object",
        "  oAlertBox[3]:maximum :\u003d recCount()",
        "  lInProgress :\u003d .T.",
        "ENDIF",
        "dbSelectArea(\"CHKBOOK\")",
        "oldChkOrder :\u003d OrdNumber()",
        "oldChkRec   :\u003d RecNo()",
        "OrderSet(\"D1B1\")      // ChkBook and Charges in index_no order",
        "DbSelectArea(\"Charges\")",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  IF len(alltrim(charges-\u003eindex_no))\u003d12 .AND. ;",
        "         !(charges-\u003eindex_no\u003d\u00270M\u0027) .AND. ;         // avoid misc civil and parking",
        "         IIF(!empty(cJudge), charges-\u003ejudge\u003d\u003dcJudge, .T.) .AND.  ;  // correct judge"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 99354",
    "offset": 99354,
    "line": 3138,
    "column": 26,
    "evidence": {
      "startLine": 3128,
      "endLine": 3148,
      "focusLine": 3138,
      "lines": [
        "//",
        "FUNCTION PaymentDueReport(p_cJudge, p_lNoPPOnly, p_lPPOnly, p_aActionCodes, p_cFilter)",
        "LOCAL aCreditCases:\u003d{}, oldArea:\u003dSELE(), oAlertBox,;",
        "      nFineDue, nCivDue, nSCDue, nTotalCaseFees,;",
        "      oldChkRec, oldChgRec, oldChkOrder, oldChgOrder, oldNamesOrder, oldNamesRec,;",
        "      aSFPPB_Booleans, aSFD_SFDefaults, nCurrentCharge,;",
        "      oldCDayOrder, oldCDayRec, oldDMVXOrder, oldDMVXRec,;",
        "      aFPD_SFFeesPaidsDues, nCurrentChgRec, bLimitByActionCode, cCaseAC,;",
        "      nSFDue, lSFUnknown, nChargeCount, nPassedCount, lFilterSeeksDone,;",
        "      aWaivedFFS",
        "PRIVATE axLocals[ncx_Len], nLLSFee:\u003d0, nLLSPaid:\u003d0",
        "",
        "DEFAULT p_lNoPPOnly TO .F.,;",
        "        p_lPPOnly TO .F.,;",
        "        p_cJudge TO \"\",;",
        "        p_aActionCodes TO NIL,;",
        "        p_cFilter TO \".T.\"",
        "",
        "AlertBox TO oAlertBox ;",
        "         TEXT \u0027;Searching for cases with money due..;\u0027               ;",
        "         BUTTONS {\"NONE\"}                              ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 101550",
    "offset": 101550,
    "line": 3199,
    "column": 1,
    "evidence": {
      "startLine": 3189,
      "endLine": 3209,
      "focusLine": 3199,
      "lines": [
        "      IIF(p_aActionCodes[1] \u003c\u003d cCaseAC .AND. cCaseAC \u003c\u003d p_aActionCodes[2],;",
        "        .T.,;",
        "        .F.)),;",
        "    .T.)}",
        "",
        "IF IsObject(oAlertBox[3])",
        "  oAlertBox[3]:current :\u003d 1                // oAlertBox[3] is oProgress bar object",
        "  dbGoTop()",
        "  oAlertBox[3]:maximum :\u003d RecCount()",
        "  lInProgress :\u003d .T.",
        "ENDIF",
        "",
        "dbSelectArea(\"CHKBOOK\")",
        "oldChkOrder :\u003d OrdNumber()",
        "oldChkRec   :\u003d RecNo()",
        "OrderSet(\"D1B1\")      // ChkBook and Charges in index_no order",
        "DbSelectArea(\"COURTDAY\")",
        "oldCDayOrder :\u003d OrdNumber()",
        "oldCDayRec   :\u003d RecNo()",
        "OrderSet(\"C1\")     // sele courtday set order to index_no",
        "DbSelectArea(\"NAMES\")"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 110826",
    "offset": 110826,
    "line": 3462,
    "column": 3,
    "evidence": {
      "startLine": 3452,
      "endLine": 3472,
      "focusLine": 3462,
      "lines": [
        "          SYSICON \"!\" ;    //",
        "          FONT FONT_TIMES_MEDIUM ;",
        "          TITLE \u0027Error\u0027 ;",
        "          DEFAULTBUTTON 1",
        "    IF nReturn\u003d\u003d2",
        "      IF IsMemvar( \"lSkipChk\" )",
        "        lSkipChk :\u003d .T.",
        "      ENDIF",
        "      RETURN(.T.)",
        "    ENDIF",
        "  ENDIF",
        "  RETURN(.F.)",
        "ENDIF",
        "RETURN(.T.)",
        "// EOF Ck_NYClid",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION CDR_inchk( cdr2chk )",
        "IF empty(cdr2chk)",
        "  RETURN .T."
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 110846",
    "offset": 110846,
    "line": 3464,
    "column": 1,
    "evidence": {
      "startLine": 3454,
      "endLine": 3474,
      "focusLine": 3464,
      "lines": [
        "          TITLE \u0027Error\u0027 ;",
        "          DEFAULTBUTTON 1",
        "    IF nReturn\u003d\u003d2",
        "      IF IsMemvar( \"lSkipChk\" )",
        "        lSkipChk :\u003d .T.",
        "      ENDIF",
        "      RETURN(.T.)",
        "    ENDIF",
        "  ENDIF",
        "  RETURN(.F.)",
        "ENDIF",
        "RETURN(.T.)",
        "// EOF Ck_NYClid",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION CDR_inchk( cdr2chk )",
        "IF empty(cdr2chk)",
        "  RETURN .T.",
        "ENDIF",
        "RETURN CDR_CK_Nine(cdr2chk)"
      ]
    }
  },
  {
    "message": "Unexpected token ELSE at 117579",
    "offset": 117579,
    "line": 3678,
    "column": 5,
    "evidence": {
      "startLine": 3668,
      "endLine": 3688,
      "focusLine": 3678,
      "lines": [
        "DbSelectArea(\"CHARGES\")",
        "oldrec:\u003drecNo()",
        "DO CASE",
        "  CASE direction\u003d\u003d\u0027T\u0027   // GoTop",
        "    xCase:\u003d2",
        "  CASE direction\u003d\u003d\u0027B\u0027   // GoBottom",
        "    xCase:\u003d len(aCurCal)",
        "  CASE direction\u003d\u003d\u0027N\u0027   // Skip",
        "    IF xCase \u003c Len(aCurCal)",
        "      xCase++",
        "    ELSE",
        "      xCase:\u003dlen(aCurCal)",
        "    ENDIF",
        "  CASE direction\u003d\u003d\u0027P\u0027   // Skip -1",
        "    IF xCase \u003e 2",
        "      xCase--",
        "    ELSE",
        "      xCase:\u003d2",
        "    ENDIF",
        "ENDCASE",
        "AtBot:\u003dIIF(len(aCurCal)\u003exCase,.F.,.T.)"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 117590",
    "offset": 117590,
    "line": 3679,
    "column": 7,
    "evidence": {
      "startLine": 3669,
      "endLine": 3689,
      "focusLine": 3679,
      "lines": [
        "oldrec:\u003drecNo()",
        "DO CASE",
        "  CASE direction\u003d\u003d\u0027T\u0027   // GoTop",
        "    xCase:\u003d2",
        "  CASE direction\u003d\u003d\u0027B\u0027   // GoBottom",
        "    xCase:\u003d len(aCurCal)",
        "  CASE direction\u003d\u003d\u0027N\u0027   // Skip",
        "    IF xCase \u003c Len(aCurCal)",
        "      xCase++",
        "    ELSE",
        "      xCase:\u003dlen(aCurCal)",
        "    ENDIF",
        "  CASE direction\u003d\u003d\u0027P\u0027   // Skip -1",
        "    IF xCase \u003e 2",
        "      xCase--",
        "    ELSE",
        "      xCase:\u003d2",
        "    ENDIF",
        "ENDCASE",
        "AtBot:\u003dIIF(len(aCurCal)\u003exCase,.F.,.T.)",
        "AtTop:\u003dIIF(xCase\u003e2,.F.,.T.)"
      ]
    }
  },
  {
    "message": "Unexpected token ELSE at 117690",
    "offset": 117690,
    "line": 3684,
    "column": 5,
    "evidence": {
      "startLine": 3674,
      "endLine": 3694,
      "focusLine": 3684,
      "lines": [
        "    xCase:\u003d len(aCurCal)",
        "  CASE direction\u003d\u003d\u0027N\u0027   // Skip",
        "    IF xCase \u003c Len(aCurCal)",
        "      xCase++",
        "    ELSE",
        "      xCase:\u003dlen(aCurCal)",
        "    ENDIF",
        "  CASE direction\u003d\u003d\u0027P\u0027   // Skip -1",
        "    IF xCase \u003e 2",
        "      xCase--",
        "    ELSE",
        "      xCase:\u003d2",
        "    ENDIF",
        "ENDCASE",
        "AtBot:\u003dIIF(len(aCurCal)\u003exCase,.F.,.T.)",
        "AtTop:\u003dIIF(xCase\u003e2,.F.,.T.)",
        "OrderSet(\"B1\")",
        "SEEK aCurCal[xCase, ccalIndexNo]",
        "IF !FOUND()",
        "  dbGoTo(oldrec)",
        "ENDIF"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027-\u0027 at 117701",
    "offset": 117701,
    "line": 3685,
    "column": 7,
    "evidence": {
      "startLine": 3675,
      "endLine": 3695,
      "focusLine": 3685,
      "lines": [
        "  CASE direction\u003d\u003d\u0027N\u0027   // Skip",
        "    IF xCase \u003c Len(aCurCal)",
        "      xCase++",
        "    ELSE",
        "      xCase:\u003dlen(aCurCal)",
        "    ENDIF",
        "  CASE direction\u003d\u003d\u0027P\u0027   // Skip -1",
        "    IF xCase \u003e 2",
        "      xCase--",
        "    ELSE",
        "      xCase:\u003d2",
        "    ENDIF",
        "ENDCASE",
        "AtBot:\u003dIIF(len(aCurCal)\u003exCase,.F.,.T.)",
        "AtTop:\u003dIIF(xCase\u003e2,.F.,.T.)",
        "OrderSet(\"B1\")",
        "SEEK aCurCal[xCase, ccalIndexNo]",
        "IF !FOUND()",
        "  dbGoTo(oldrec)",
        "ENDIF",
        "RETURN"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 118267",
    "offset": 118267,
    "line": 3704,
    "column": 19,
    "evidence": {
      "startLine": 3694,
      "endLine": 3714,
      "focusLine": 3704,
      "lines": [
        "ENDIF",
        "RETURN",
        "// EOP CalMove",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION SelectOne(cDTitle, aTitle, aInLines, ScnNum, xHelpRef, nBtnOffset, BGColor, lSort)",
        "LOCAL SelType, RetType:\u003d0, GetList:\u003d{}, oChoice, lExit:\u003d.F., oStatic, ;",
        "      oAlertBox, GetOptions, oDlg1, oFocus:\u003dSetAppFocus(), x, nxtLn:\u003d0, ;",
        "      LastLn, nnMax:\u003d20, aRetVal:\u003d{}, aLines:\u003d{}, L1, L2",
        "PRIVATE nScroll:\u003d0, oVertScroll, nVertOffset:\u003d0, nLines",
        "",
        "DEFAULT nBtnOffset TO 12",
        "v_ValType(@lSort,.F.,@cDTitle,\"PICK\")",
        "",
        "aLines :\u003d aClone(aInLines)         // Do not mess with the original!",
        "IF !valtype(aLines)\u003d\u003d\"A\" .OR. len(aLines)\u003c1",
        "  RETURN 0",
        "ENDIF",
        "",
        "FOR x:\u003d1 TO len(aLines)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 118494",
    "offset": 118494,
    "line": 3712,
    "column": 1,
    "evidence": {
      "startLine": 3702,
      "endLine": 3722,
      "focusLine": 3712,
      "lines": [
        "      oAlertBox, GetOptions, oDlg1, oFocus:\u003dSetAppFocus(), x, nxtLn:\u003d0, ;",
        "      LastLn, nnMax:\u003d20, aRetVal:\u003d{}, aLines:\u003d{}, L1, L2",
        "PRIVATE nScroll:\u003d0, oVertScroll, nVertOffset:\u003d0, nLines",
        "",
        "DEFAULT nBtnOffset TO 12",
        "v_ValType(@lSort,.F.,@cDTitle,\"PICK\")",
        "",
        "aLines :\u003d aClone(aInLines)         // Do not mess with the original!",
        "IF !valtype(aLines)\u003d\u003d\"A\" .OR. len(aLines)\u003c1",
        "  RETURN 0",
        "ENDIF",
        "",
        "FOR x:\u003d1 TO len(aLines)",
        "  IF valtype(aLines[x])\u003d\"C\"",
        "    aLines[x] :\u003d {aLines[x],x}",
        "  ENDIF",
        "NEXT",
        "",
        "IF lSort .AND. valtype(aLines) \u003d\u003d \"A\" .AND. len(aLines)\u003e1 .AND. len(aLines[1]) \u003d\u003d 2",
        "  aSort(aLines,,,{|x,y| UPPER(x[1])\u003cUPPER(y[1])})",
        "ENDIF"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 119489",
    "offset": 119489,
    "line": 3756,
    "column": 47,
    "evidence": {
      "startLine": 3746,
      "endLine": 3766,
      "focusLine": 3756,
      "lines": [
        "                TITLE cDTitle        ;",
        "                SIZE {720,440}       ;",
        "                SCREEN ScnNum        ;",
        "                STOREGETLIST GetList ;",
        "                NOWINMENU            ;",
        "                MODAL                ;",
        "                HELPREF xHelpRef",
        "",
        "  oDlg1:setDisplayFocus :\u003d {|| SetAppFocus(oChoice) }",
        "",
        "  oDlg1:reSize :\u003d {|a,b,o|o:drawingArea:hide(), ;",
        "                       DC_AutoResize(a,b,o,GetList), ;",
        "                       o:drawingArea:show()}",
        "",
        "  IF valType(BGColor)\u003d\"N\"",
        "    oDlg1:drawingArea:setColorBG( BGColor )",
        "    oDlg1:bgColor :\u003d BGColor",
        "  ENDIF",
        "  IF nLines \u003e 9",
        "    SelType:\u003d\" 0\"",
        "  ELSE"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 119489",
    "offset": 119489,
    "line": 3756,
    "column": 47,
    "evidence": {
      "startLine": 3746,
      "endLine": 3766,
      "focusLine": 3756,
      "lines": [
        "                TITLE cDTitle        ;",
        "                SIZE {720,440}       ;",
        "                SCREEN ScnNum        ;",
        "                STOREGETLIST GetList ;",
        "                NOWINMENU            ;",
        "                MODAL                ;",
        "                HELPREF xHelpRef",
        "",
        "  oDlg1:setDisplayFocus :\u003d {|| SetAppFocus(oChoice) }",
        "",
        "  oDlg1:reSize :\u003d {|a,b,o|o:drawingArea:hide(), ;",
        "                       DC_AutoResize(a,b,o,GetList), ;",
        "                       o:drawingArea:show()}",
        "",
        "  IF valType(BGColor)\u003d\"N\"",
        "    oDlg1:drawingArea:setColorBG( BGColor )",
        "    oDlg1:bgColor :\u003d BGColor",
        "  ENDIF",
        "  IF nLines \u003e 9",
        "    SelType:\u003d\" 0\"",
        "  ELSE"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 119695",
    "offset": 119695,
    "line": 3763,
    "column": 3,
    "evidence": {
      "startLine": 3753,
      "endLine": 3773,
      "focusLine": 3763,
      "lines": [
        "",
        "  oDlg1:setDisplayFocus :\u003d {|| SetAppFocus(oChoice) }",
        "",
        "  oDlg1:reSize :\u003d {|a,b,o|o:drawingArea:hide(), ;",
        "                       DC_AutoResize(a,b,o,GetList), ;",
        "                       o:drawingArea:show()}",
        "",
        "  IF valType(BGColor)\u003d\"N\"",
        "    oDlg1:drawingArea:setColorBG( BGColor )",
        "    oDlg1:bgColor :\u003d BGColor",
        "  ENDIF",
        "  IF nLines \u003e 9",
        "    SelType:\u003d\" 0\"",
        "  ELSE",
        "    SelType:\u003d\"0\"",
        "  ENDIF",
        "  @  0, 1 DCSAY \u0027\u0027  // needed for AUTOFIT to hold left margin",
        "  IF nLines \u003e 12",
        "    FOR x:\u003d1 TO nLines",
        "      nnMax :\u003d MAX(nnMax,len(aLines[x])*1.12)",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 120023",
    "offset": 120023,
    "line": 3778,
    "column": 22,
    "evidence": {
      "startLine": 3768,
      "endLine": 3788,
      "focusLine": 3778,
      "lines": [
        "  ENDIF",
        "  @  0, 1 DCSAY \u0027\u0027  // needed for AUTOFIT to hold left margin",
        "  IF nLines \u003e 12",
        "    FOR x:\u003d1 TO nLines",
        "      nnMax :\u003d MAX(nnMax,len(aLines[x])*1.12)",
        "    NEXT",
        "    nnMax +\u003d12",
        "    @ 0,nnMax+5 DCSAY \u0027 \u0027",
        "  ENDIF",
        "  @  0, 4 DCSAY aTitle[1]  ;",
        "            SAYSIZE 0,1.2 ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "            SAYFONT cStdLargeSay",
        "  IF Len(aTitle)\u003e1",
        "    @  1, 4 DCSAY aTitle[2]  ;",
        "              SAYSIZE 0,1.2 ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "              SAYFONT cStdLargeSay",
        "    nxtLn:\u003d1",
        "  ENDIF",
        "  IF Len(aTitle)\u003e2"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 120321",
    "offset": 120321,
    "line": 3787,
    "column": 3,
    "evidence": {
      "startLine": 3777,
      "endLine": 3797,
      "focusLine": 3787,
      "lines": [
        "  @  0, 4 DCSAY aTitle[1]  ;",
        "            SAYSIZE 0,1.2 ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "            SAYFONT cStdLargeSay",
        "  IF Len(aTitle)\u003e1",
        "    @  1, 4 DCSAY aTitle[2]  ;",
        "              SAYSIZE 0,1.2 ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "              SAYFONT cStdLargeSay",
        "    nxtLn:\u003d1",
        "  ENDIF",
        "  IF Len(aTitle)\u003e2",
        "    @  2, 4 DCSAY aTitle[3]  ;",
        "              SAYSIZE 0,1.2 ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "              SAYFONT cStdLargeSay",
        "    nxtLn:\u003d2",
        "  ENDIF",
        "",
        "  IF nLines \u003c 13",
        "    FOR x:\u003d1 TO nLines"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 120400",
    "offset": 120400,
    "line": 3790,
    "column": 24,
    "evidence": {
      "startLine": 3780,
      "endLine": 3800,
      "focusLine": 3790,
      "lines": [
        "            SAYFONT cStdLargeSay",
        "  IF Len(aTitle)\u003e1",
        "    @  1, 4 DCSAY aTitle[2]  ;",
        "              SAYSIZE 0,1.2 ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "              SAYFONT cStdLargeSay",
        "    nxtLn:\u003d1",
        "  ENDIF",
        "  IF Len(aTitle)\u003e2",
        "    @  2, 4 DCSAY aTitle[3]  ;",
        "              SAYSIZE 0,1.2 ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "              SAYFONT cStdLargeSay",
        "    nxtLn:\u003d2",
        "  ENDIF",
        "",
        "  IF nLines \u003c 13",
        "    FOR x:\u003d1 TO nLines",
        "      @ nxtLn+(1.5*x),nBtnOffset DCPUSHBUTTON CAPTION str(x,IIF(nLines\u003e9,2,1))  ;",
        "                SIZE IIF(nLines\u003e9,3,2.5), 1.5 ;",
        "                ACTION setX(x,@RetType,@GetList) ;"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 120691",
    "offset": 120691,
    "line": 3799,
    "column": 41,
    "evidence": {
      "startLine": 3789,
      "endLine": 3809,
      "focusLine": 3799,
      "lines": [
        "    @  2, 4 DCSAY aTitle[3]  ;",
        "              SAYSIZE 0,1.2 ;",
        "              SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "              SAYFONT cStdLargeSay",
        "    nxtLn:\u003d2",
        "  ENDIF",
        "",
        "  IF nLines \u003c 13",
        "    FOR x:\u003d1 TO nLines",
        "      @ nxtLn+(1.5*x),nBtnOffset DCPUSHBUTTON CAPTION str(x,IIF(nLines\u003e9,2,1))  ;",
        "                SIZE IIF(nLines\u003e9,3,2.5), 1.5 ;",
        "                ACTION setX(x,@RetType,@GetList) ;",
        "                FONT BTN_FONT_B",
        "",
        "      @ nxtLn+0.4+(1.5*x),nBtnOffset+IIF(nLines\u003e9,3.5,3) DCSAY aLines[x] ;",
        "                  SAYSIZE (len(aLines[x])*1.5)+1 ;",
        "                  SAYFONT cStdLargeSay ;",
        "                  SAYOPTION XBPSTATIC_TEXT_VCENTER",
        "    NEXT",
        "  ELSE",
        "    nBtnOffset :\u003d 5"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 121104",
    "offset": 121104,
    "line": 3811,
    "column": 67,
    "evidence": {
      "startLine": 3801,
      "endLine": 3821,
      "focusLine": 3811,
      "lines": [
        "                FONT BTN_FONT_B",
        "",
        "      @ nxtLn+0.4+(1.5*x),nBtnOffset+IIF(nLines\u003e9,3.5,3) DCSAY aLines[x] ;",
        "                  SAYSIZE (len(aLines[x])*1.5)+1 ;",
        "                  SAYFONT cStdLargeSay ;",
        "                  SAYOPTION XBPSTATIC_TEXT_VCENTER",
        "    NEXT",
        "  ELSE",
        "    nBtnOffset :\u003d 5",
        "",
        "    @ nxtLn+1.5,1 DCSTATIC TYPE XBPSTATIC_TYPE_BGNDRECT SIZE nnMax,18 ;",
        "          RESIZE { {|x,y,o,x1,y1,x2,y2|IIF(lBuilt,{x1*x2,y1*y2},o:origPos)}, ;",
        "                 {|x,y,o,x1,y1,x2,y2|IIF(lBuilt,{x1*x2,y1*y2},o:origSize)} } ;",
        "          EVAL {|o| o:wheel :\u003d {|a,b,c|IIF(b[2]\u003c0,SelectScrollDown(),SelectScrollUp())}} ;",
        "          OBJECT oStatic PARENT oDlg1:drawingArea",
        "",
        "    @ nxtLn+1.5, nnMax+1.2 DCSCROLLBAR DATA nScroll SIZE 3,18 ;",
        "          TYPE XBPSCROLL_VERTICAL RANGE 0,nLines-10 ;",
        "          AUTOTRACK PARENT oDlg1:drawingArea ;",
        "          EVAL {|o| o:wheel :\u003d {|a,b,c|IIF(b[2]\u003c0,SelectScrollDown(),SelectScrollUp())}} ;",
        "          OBJECT oVertScroll ;"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 122462",
    "offset": 122462,
    "line": 3841,
    "column": 5,
    "evidence": {
      "startLine": 3831,
      "endLine": 3851,
      "focusLine": 3841,
      "lines": [
        "                SIZE IIF(nLines\u003e9,3,2.5), 1.5 ;",
        "                ACTION setX(x,@RetType,@GetList) ;",
        "                EVAL {|o|o:cargo[3]:\u003do:currentPos()} ;",
        "                FONT BTN_FONT_B",
        "",
        "      @ 0.4+(1.5*(x-1)),nBtnOffset+IIF(nLines\u003e9,3.5,3) DCSAY aLines[x] ;",
        "                  SAYSIZE (len(aLines[x])*1.5)+1 ;",
        "                  SAYFONT cStdLargeSay ;",
        "                  SAYEVAL {|o|o:cargo[3]:\u003do:currentPos()} ;",
        "                  SAYOPTION XBPSTATIC_TEXT_VCENTER",
        "    NEXT",
        "    LastLn :\u003d nxtLn+19",
        "  ENDIF",
        "",
        "  DCSETPARENT TO",
        "  nxtLn +\u003d LastLn+0.6",
        "  @ nxtLn+0.2, 4 DCSAY \"Selection: \" GET SelType  ;",
        "            PICTURE {||IIF(nLines\u003e9,\u002799\u0027,\u00279\u0027)}  ;",
        "            SAYFONT BTN_FONT_B ;",
        "            GETOBJECT oChoice  ;",
        "         ; //   NOCONFIRM   ;"
      ]
    }
  },
  {
    "message": "Unexpected token TO at 122513",
    "offset": 122513,
    "line": 3845,
    "column": 15,
    "evidence": {
      "startLine": 3835,
      "endLine": 3855,
      "focusLine": 3845,
      "lines": [
        "",
        "      @ 0.4+(1.5*(x-1)),nBtnOffset+IIF(nLines\u003e9,3.5,3) DCSAY aLines[x] ;",
        "                  SAYSIZE (len(aLines[x])*1.5)+1 ;",
        "                  SAYFONT cStdLargeSay ;",
        "                  SAYEVAL {|o|o:cargo[3]:\u003do:currentPos()} ;",
        "                  SAYOPTION XBPSTATIC_TEXT_VCENTER",
        "    NEXT",
        "    LastLn :\u003d nxtLn+19",
        "  ENDIF",
        "",
        "  DCSETPARENT TO",
        "  nxtLn +\u003d LastLn+0.6",
        "  @ nxtLn+0.2, 4 DCSAY \"Selection: \" GET SelType  ;",
        "            PICTURE {||IIF(nLines\u003e9,\u002799\u0027,\u00279\u0027)}  ;",
        "            SAYFONT BTN_FONT_B ;",
        "            GETOBJECT oChoice  ;",
        "         ; //   NOCONFIRM   ;",
        "            SAYRIGHT    ;",
        "            SAYSIZE 14  ;",
        "            VALID {|o| Val(SelType)\u003c\u003dnLines }",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 123119",
    "offset": 123119,
    "line": 3862,
    "column": 3,
    "evidence": {
      "startLine": 3852,
      "endLine": 3872,
      "focusLine": 3862,
      "lines": [
        "            SAYRIGHT    ;",
        "            SAYSIZE 14  ;",
        "            VALID {|o| Val(SelType)\u003c\u003dnLines }",
        "",
        "  IF nLines \u003e 9",
        "    @ nxtLn, 25 DCPUSHBUTTON CAPTION \"~OK\"  SIZE 8,1.3 ;",
        "                 ACCELKEY xbeK_CTRL_O ;",
        "                 TOOLTIP \"Select the option;\"+cDTitle ;",
        "                 TABSTOP FONT BTN_FONT_B ;",
        "                 ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList) }",
        "  ENDIF",
        "  @ nxtLn, 46 DCSAY \" \"",
        "  @ nxtLn, 34 DCPUSHBUTTON CAPTION \"~Quit\"   SIZE 8,1.3  ;",
        "               ACCELKEY  xbeK_CTRL_Q ;",
        "               ACTION {||DC_ReadGuiEvent(DCGUI_EXIT_ABORT, GetList)} ;",
        "               TOOLTIP \"Quit option selection;\"+cDTitle  ;",
        "               FONT BTN_FONT_B",
        "",
        "  DCHOTKEY xbeK_F1 WHEN {||oDlg1:getFrameState()\u003c\u003eXBPDLG_FRAMESTAT_MINIMIZED} ;",
        "        ACTION {|uNIL1,uNIL2,oXbp|HelpObject():showhelp(xHelpRef) }",
        "  DCHOTKEY xbeK_CTRL_DOWN WHEN {||nLines\u003e12};"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 123200",
    "offset": 123200,
    "line": 3864,
    "column": 52,
    "evidence": {
      "startLine": 3854,
      "endLine": 3874,
      "focusLine": 3864,
      "lines": [
        "            VALID {|o| Val(SelType)\u003c\u003dnLines }",
        "",
        "  IF nLines \u003e 9",
        "    @ nxtLn, 25 DCPUSHBUTTON CAPTION \"~OK\"  SIZE 8,1.3 ;",
        "                 ACCELKEY xbeK_CTRL_O ;",
        "                 TOOLTIP \"Select the option;\"+cDTitle ;",
        "                 TABSTOP FONT BTN_FONT_B ;",
        "                 ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList) }",
        "  ENDIF",
        "  @ nxtLn, 46 DCSAY \" \"",
        "  @ nxtLn, 34 DCPUSHBUTTON CAPTION \"~Quit\"   SIZE 8,1.3  ;",
        "               ACCELKEY  xbeK_CTRL_Q ;",
        "               ACTION {||DC_ReadGuiEvent(DCGUI_EXIT_ABORT, GetList)} ;",
        "               TOOLTIP \"Quit option selection;\"+cDTitle  ;",
        "               FONT BTN_FONT_B",
        "",
        "  DCHOTKEY xbeK_F1 WHEN {||oDlg1:getFrameState()\u003c\u003eXBPDLG_FRAMESTAT_MINIMIZED} ;",
        "        ACTION {|uNIL1,uNIL2,oXbp|HelpObject():showhelp(xHelpRef) }",
        "  DCHOTKEY xbeK_CTRL_DOWN WHEN {||nLines\u003e12};",
        "        ACTION {||SelectScrollDown()}",
        "  DCHOTKEY xbeK_CTRL_UP WHEN {||nLines\u003e12};"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 124328",
    "offset": 124328,
    "line": 3894,
    "column": 3,
    "evidence": {
      "startLine": 3884,
      "endLine": 3904,
      "focusLine": 3894,
      "lines": [
        "          FIT                 ;",
        "          EVAL {|oDlg1| IIF(!Ok2Resize(),LockSize(oDlg1),NIL),;",
        "                        oDlg1:SetPos(CenterScnPos(oDlg1:currentSize(),RootWindow())), ;",
        "                        SetAppFocus(oDlg1),;",
        "                        SetAppFocus(oChoice)}",
        "",
        "  GetList:\u003d{}",
        "  oDlg1:setModalState( XBP_DISP_MODELESS )",
        "  IF IsObject(oFocus) .AND. oFocus:status()\u003dXBP_STAT_CREATE",
        "    SetAppFocus( oFocus )",
        "  ELSE",
        "    SetAppFocus( RootWindow() )",
        "  ENDIF",
        "  DestroyAll( @oDlg1 )",
        "  oDlg1 :\u003d NIL",
        "  Scn_No(0)",
        "  IF  Val(SelType)\u003e0 .AND. Val(SelType)\u003c\u003dnLines",
        "    RetType:\u003dVal(SelType)",
        "  ENDIF",
        "  IF RetType \u003e 0 .AND. RetType \u003c\u003d len(aRetVal)",
        "    RetType :\u003d aRetVal[RetType]"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 124367",
    "offset": 124367,
    "line": 3896,
    "column": 3,
    "evidence": {
      "startLine": 3886,
      "endLine": 3906,
      "focusLine": 3896,
      "lines": [
        "                        oDlg1:SetPos(CenterScnPos(oDlg1:currentSize(),RootWindow())), ;",
        "                        SetAppFocus(oDlg1),;",
        "                        SetAppFocus(oChoice)}",
        "",
        "  GetList:\u003d{}",
        "  oDlg1:setModalState( XBP_DISP_MODELESS )",
        "  IF IsObject(oFocus) .AND. oFocus:status()\u003dXBP_STAT_CREATE",
        "    SetAppFocus( oFocus )",
        "  ELSE",
        "    SetAppFocus( RootWindow() )",
        "  ENDIF",
        "  DestroyAll( @oDlg1 )",
        "  oDlg1 :\u003d NIL",
        "  Scn_No(0)",
        "  IF  Val(SelType)\u003e0 .AND. Val(SelType)\u003c\u003dnLines",
        "    RetType:\u003dVal(SelType)",
        "  ENDIF",
        "  IF RetType \u003e 0 .AND. RetType \u003c\u003d len(aRetVal)",
        "    RetType :\u003d aRetVal[RetType]",
        "  ENDIF",
        "RETURN  RetType"
      ]
    }
  },
  {
    "message": "Expected identifier after LOCAL at 124686",
    "offset": 124686,
    "line": 3911,
    "column": 8,
    "evidence": {
      "startLine": 3901,
      "endLine": 3921,
      "focusLine": 3911,
      "lines": [
        "    RetType:\u003dVal(SelType)",
        "  ENDIF",
        "  IF RetType \u003e 0 .AND. RetType \u003c\u003d len(aRetVal)",
        "    RetType :\u003d aRetVal[RetType]",
        "  ENDIF",
        "RETURN  RetType",
        "// EOF SelectOne",
        "",
        "//",
        "//-----------------------------------------------",
        "STATIC PROCEDURE SelectScroll( oStatic, nVertOffset )",
        "",
        "LOCAL aChildren :\u003d oStatic:ChildList(), i, aCargo, nRow, nCol",
        "",
        "oStatic:lockUpdate(.T.)",
        "FOR i :\u003d 1 TO LEN(aChildren)",
        "  aCargo :\u003d aChildren[i]:cargo[3]",
        "  nCol :\u003d aCargo[1]",
        "  nRow :\u003d aCargo[2]",
        "  aChildren[i]:setPos({nCol,nRow+nVertOffset})",
        "NEXT"
      ]
    }
  },
  {
    "message": "Expected identifier after LOCAL at 125088",
    "offset": 125088,
    "line": 3928,
    "column": 8,
    "evidence": {
      "startLine": 3918,
      "endLine": 3938,
      "focusLine": 3928,
      "lines": [
        "  nCol :\u003d aCargo[1]",
        "  nRow :\u003d aCargo[2]",
        "  aChildren[i]:setPos({nCol,nRow+nVertOffset})",
        "NEXT",
        "oStatic:lockUpdate(.F.)",
        "RETURN",
        "// EOP SelectScroll",
        "",
        "//",
        "//-----------------------------------------------",
        "STATIC PROCEDURE SelectScrollDown()",
        "  IF nScroll \u003c nLines-10",
        "    nVertOffset+\u003d30",
        "    nScroll:\u003dnVertOffset/30",
        "    PostAppEvent(xbeSB_Scroll,{nScroll,XBPSB_NEXTPOS},nil,oVertScroll)",
        "    oVertScroll:SetData(nScroll)",
        "  ENDIF",
        "RETURN",
        "// EOP SelectScrollDown",
        "",
        "//"
      ]
    }
  },
  {
    "message": "Expected identifier after LOCAL at 125394",
    "offset": 125394,
    "line": 3940,
    "column": 8,
    "evidence": {
      "startLine": 3930,
      "endLine": 3950,
      "focusLine": 3940,
      "lines": [
        "    nVertOffset+\u003d30",
        "    nScroll:\u003dnVertOffset/30",
        "    PostAppEvent(xbeSB_Scroll,{nScroll,XBPSB_NEXTPOS},nil,oVertScroll)",
        "    oVertScroll:SetData(nScroll)",
        "  ENDIF",
        "RETURN",
        "// EOP SelectScrollDown",
        "",
        "//",
        "//-----------------------------------------------",
        "STATIC PROCEDURE SelectScrollUp()",
        "  IF nScroll\u003e0",
        "    nVertOffset -\u003d 30",
        "    nScroll:\u003dnVertOffset/30",
        "    PostAppEvent(xbeSB_Scroll,{nScroll,XBPSB_PREVPOS},nil,oVertScroll)",
        "    oVertScroll:SetData(nScroll)",
        "  ENDIF",
        "RETURN",
        "// EOP SelectScrollUp",
        "",
        "//"
      ]
    }
  },
  {
    "message": "Expected identifier after LOCAL at 125688",
    "offset": 125688,
    "line": 3952,
    "column": 8,
    "evidence": {
      "startLine": 3942,
      "endLine": 3962,
      "focusLine": 3952,
      "lines": [
        "    nVertOffset -\u003d 30",
        "    nScroll:\u003dnVertOffset/30",
        "    PostAppEvent(xbeSB_Scroll,{nScroll,XBPSB_PREVPOS},nil,oVertScroll)",
        "    oVertScroll:SetData(nScroll)",
        "  ENDIF",
        "RETURN",
        "// EOP SelectScrollUp",
        "",
        "//",
        "//-----------------------------------------------",
        "STATIC FUNCTION setX(x,RetType,GetList)",
        "RETURN {|| RetType:\u003dx, DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList)}",
        "// EOF setX",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION HasAttorney(aAttName,attnPos)  // axLocals must be a public or private",
        "LOCAL lOK:\u003d.F., y:\u003d0                    //  since we need aCharge",
        "v_ValType(@attnPos,ccAttorney)                    // works for ccAttorney,",
        "  y :\u003d Ascan(aCharge,{|x|!empty(x[attnPos])})     //           ccDist_Att,",
        "  IF y\u003e0                                          //           ccOfficer"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 125739",
    "offset": 125739,
    "line": 3953,
    "column": 19,
    "evidence": {
      "startLine": 3943,
      "endLine": 3963,
      "focusLine": 3953,
      "lines": [
        "    nScroll:\u003dnVertOffset/30",
        "    PostAppEvent(xbeSB_Scroll,{nScroll,XBPSB_PREVPOS},nil,oVertScroll)",
        "    oVertScroll:SetData(nScroll)",
        "  ENDIF",
        "RETURN",
        "// EOP SelectScrollUp",
        "",
        "//",
        "//-----------------------------------------------",
        "STATIC FUNCTION setX(x,RetType,GetList)",
        "RETURN {|| RetType:\u003dx, DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList)}",
        "// EOF setX",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION HasAttorney(aAttName,attnPos)  // axLocals must be a public or private",
        "LOCAL lOK:\u003d.F., y:\u003d0                    //  since we need aCharge",
        "v_ValType(@attnPos,ccAttorney)                    // works for ccAttorney,",
        "  y :\u003d Ascan(aCharge,{|x|!empty(x[attnPos])})     //           ccDist_Att,",
        "  IF y\u003e0                                          //           ccOfficer",
        "    OrderSet(\"A3\")  //  Names in nameNo order"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 125739",
    "offset": 125739,
    "line": 3953,
    "column": 19,
    "evidence": {
      "startLine": 3943,
      "endLine": 3963,
      "focusLine": 3953,
      "lines": [
        "    nScroll:\u003dnVertOffset/30",
        "    PostAppEvent(xbeSB_Scroll,{nScroll,XBPSB_PREVPOS},nil,oVertScroll)",
        "    oVertScroll:SetData(nScroll)",
        "  ENDIF",
        "RETURN",
        "// EOP SelectScrollUp",
        "",
        "//",
        "//-----------------------------------------------",
        "STATIC FUNCTION setX(x,RetType,GetList)",
        "RETURN {|| RetType:\u003dx, DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList)}",
        "// EOF setX",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION HasAttorney(aAttName,attnPos)  // axLocals must be a public or private",
        "LOCAL lOK:\u003d.F., y:\u003d0                    //  since we need aCharge",
        "v_ValType(@attnPos,ccAttorney)                    // works for ccAttorney,",
        "  y :\u003d Ascan(aCharge,{|x|!empty(x[attnPos])})     //           ccDist_Att,",
        "  IF y\u003e0                                          //           ccOfficer",
        "    OrderSet(\"A3\")  //  Names in nameNo order"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 126354",
    "offset": 126354,
    "line": 3966,
    "column": 5,
    "evidence": {
      "startLine": 3956,
      "endLine": 3976,
      "focusLine": 3966,
      "lines": [
        "//",
        "//-----------------------------------------------",
        "FUNCTION HasAttorney(aAttName,attnPos)  // axLocals must be a public or private",
        "LOCAL lOK:\u003d.F., y:\u003d0                    //  since we need aCharge",
        "v_ValType(@attnPos,ccAttorney)                    // works for ccAttorney,",
        "  y :\u003d Ascan(aCharge,{|x|!empty(x[attnPos])})     //           ccDist_Att,",
        "  IF y\u003e0                                          //           ccOfficer",
        "    OrderSet(\"A3\")  //  Names in nameNo order",
        "    IF len(alltrim(aCharge[y,attnPos])) \u003d\u003d 7",
        "      seek alltrim(aCharge[y,attnPos])",
        "    ELSE",
        "      seek substr(aCharge[y,attnPos],2,7)",
        "    ENDIF",
        "    IF OAFound()",
        "      FillName(@aAttName)",
        "      lOK:\u003d.T.",
        "    ENDIF",
        "  ENDIF",
        "RETURN lOK",
        "// EOF HasAttorney",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 126405",
    "offset": 126405,
    "line": 3968,
    "column": 5,
    "evidence": {
      "startLine": 3958,
      "endLine": 3978,
      "focusLine": 3968,
      "lines": [
        "FUNCTION HasAttorney(aAttName,attnPos)  // axLocals must be a public or private",
        "LOCAL lOK:\u003d.F., y:\u003d0                    //  since we need aCharge",
        "v_ValType(@attnPos,ccAttorney)                    // works for ccAttorney,",
        "  y :\u003d Ascan(aCharge,{|x|!empty(x[attnPos])})     //           ccDist_Att,",
        "  IF y\u003e0                                          //           ccOfficer",
        "    OrderSet(\"A3\")  //  Names in nameNo order",
        "    IF len(alltrim(aCharge[y,attnPos])) \u003d\u003d 7",
        "      seek alltrim(aCharge[y,attnPos])",
        "    ELSE",
        "      seek substr(aCharge[y,attnPos],2,7)",
        "    ENDIF",
        "    IF OAFound()",
        "      FillName(@aAttName)",
        "      lOK:\u003d.T.",
        "    ENDIF",
        "  ENDIF",
        "RETURN lOK",
        "// EOF HasAttorney",
        "",
        "//",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 126481",
    "offset": 126481,
    "line": 3973,
    "column": 3,
    "evidence": {
      "startLine": 3963,
      "endLine": 3983,
      "focusLine": 3973,
      "lines": [
        "    OrderSet(\"A3\")  //  Names in nameNo order",
        "    IF len(alltrim(aCharge[y,attnPos])) \u003d\u003d 7",
        "      seek alltrim(aCharge[y,attnPos])",
        "    ELSE",
        "      seek substr(aCharge[y,attnPos],2,7)",
        "    ENDIF",
        "    IF OAFound()",
        "      FillName(@aAttName)",
        "      lOK:\u003d.T.",
        "    ENDIF",
        "  ENDIF",
        "RETURN lOK",
        "// EOF HasAttorney",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE EndOfGet(oXbp, GetOptions,lPlusOne) // lPlusOne\u003d.T. for space at the end",
        "LOCAL x                                       //    of the get, this is the default",
        "",
        "  v_ValType(@lPlusOne,.T.)",
        "  x :\u003d Len(alltrim(oXbp:getdata()))+IIF(lPlusOne,2,1)"
      ]
    }
  },
  {
    "message": "Expected member name after \u0027:\u0027 at 127072",
    "offset": 127072,
    "line": 3989,
    "column": 8,
    "evidence": {
      "startLine": 3979,
      "endLine": 3999,
      "focusLine": 3989,
      "lines": [
        "PROCEDURE EndOfGet(oXbp, GetOptions,lPlusOne) // lPlusOne\u003d.T. for space at the end",
        "LOCAL x                                       //    of the get, this is the default",
        "",
        "  v_ValType(@lPlusOne,.T.)",
        "  x :\u003d Len(alltrim(oXbp:getdata()))+IIF(lPlusOne,2,1)",
        "  IF valtype(oXbp:getdata())\u003d\"C\" .AND. oXbp:getdata() \u003d \"  \"  // empty character field w/ date or numeric picture clause?",
        "    x :\u003d 0",
        "  ENDIF",
        "  Re_ColorGets(oXbp,1,GetOptions)",
        "  x :\u003d IIF(x\u003cIIF(lPlusOne,3,2), 1, x)     // If empty goto position 1",
        "  oXbp:Get:Pos :\u003d x",
        "  oXbp:setMarked({x,x})                   //   put cursor at end of text",
        "RETURN",
        "// EOP EndOFGet",
        "",
        "// SetDefaultCursorPosition:",
        "// 1.9 Version of xbase always focus cursor at the left most position.",
        "// 2.0 Version of xbase always focus cursor at the position where user clicked into field.",
        "// This method sets focus back to left most position.",
        "// See: http://bb.donnay-software.com/donnay/viewtopic.php?f\u003d15\u0026t\u003d2579\u0026p\u003d15323\u0026hilit\u003dcursor+beginning#p15323",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Unexpected token GET at 127072",
    "offset": 127072,
    "line": 3989,
    "column": 8,
    "evidence": {
      "startLine": 3979,
      "endLine": 3999,
      "focusLine": 3989,
      "lines": [
        "PROCEDURE EndOfGet(oXbp, GetOptions,lPlusOne) // lPlusOne\u003d.T. for space at the end",
        "LOCAL x                                       //    of the get, this is the default",
        "",
        "  v_ValType(@lPlusOne,.T.)",
        "  x :\u003d Len(alltrim(oXbp:getdata()))+IIF(lPlusOne,2,1)",
        "  IF valtype(oXbp:getdata())\u003d\"C\" .AND. oXbp:getdata() \u003d \"  \"  // empty character field w/ date or numeric picture clause?",
        "    x :\u003d 0",
        "  ENDIF",
        "  Re_ColorGets(oXbp,1,GetOptions)",
        "  x :\u003d IIF(x\u003cIIF(lPlusOne,3,2), 1, x)     // If empty goto position 1",
        "  oXbp:Get:Pos :\u003d x",
        "  oXbp:setMarked({x,x})                   //   put cursor at end of text",
        "RETURN",
        "// EOP EndOFGet",
        "",
        "// SetDefaultCursorPosition:",
        "// 1.9 Version of xbase always focus cursor at the left most position.",
        "// 2.0 Version of xbase always focus cursor at the position where user clicked into field.",
        "// This method sets focus back to left most position.",
        "// See: http://bb.donnay-software.com/donnay/viewtopic.php?f\u003d15\u0026t\u003d2579\u0026p\u003d15323\u0026hilit\u003dcursor+beginning#p15323",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 128189",
    "offset": 128189,
    "line": 4017,
    "column": 1,
    "evidence": {
      "startLine": 4007,
      "endLine": 4027,
      "focusLine": 4017,
      "lines": [
        "                nil} )",
        "RETURN",
        "// EOP SetDefaultCursorPosition",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION DC_PopupButtonShow( oGet, lShow )",
        "",
        "IF !DC_GetPopupAutoHide() .OR. Empty(oGet:popupButton)",
        "  RETURN nil",
        "ENDIF",
        "IF lShow",
        "  oGet:popupButton:show()",
        "ELSEIF SetAppFocus() # oGet:popupButton",
        "  oGet:popupButton:hide()",
        "ENDIF",
        "",
        "RETURN nil",
        "",
        "//",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Expected TO in FOR statement at 130415",
    "offset": 130415,
    "line": 4104,
    "column": 5,
    "evidence": {
      "startLine": 4094,
      "endLine": 4114,
      "focusLine": 4104,
      "lines": [
        "  IF !fExists(datapath()+\"CLETTERS.DBF\") .OR. !net_use(\u0027cletters\u0027,.F.,5)",
        "    InfoBox(\"Letters Database not available, try again later!...\",;",
        "               \"CLETTERS.DBF PROBLEM\")",
        "    LtrDBFOK:\u003d.F.",
        "  ENDIF",
        "",
        "  FOR x :\u003d 1 TO len(a1)",
        "    rawltr_no :\u003d val(substr(a1[x],1,3))",
        "    IF LtrDBFOK",
        "      locate FOR letter_no \u003d rawltr_no",
        "    ENDIF",
        "    IF LtrDBFOK .AND. !eof()",
        "      a1[x] :\u003d dtoc(DatePack(substr(a1[x],4)))+;",
        "                      \u0027  \u0027+alltrim(cLetters-\u003ename)+\u0027  (\u0027+strZero(rawltr_no,3)+\u0027)\u0027",
        "    ELSE",
        "      a1[x] :\u003d dtoc(DatePack(substr(a1[x],4)))+;",
        "                      \u0027  Unknown letter sent  (\u0027+strZero(rawltr_no,3)+\u0027)\u0027",
        "    ENDIF",
        "  NEXT x",
        "  USE",
        "  SELECT(oldArea)  // get back to original area"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 130415",
    "offset": 130415,
    "line": 4104,
    "column": 5,
    "evidence": {
      "startLine": 4094,
      "endLine": 4114,
      "focusLine": 4104,
      "lines": [
        "  IF !fExists(datapath()+\"CLETTERS.DBF\") .OR. !net_use(\u0027cletters\u0027,.F.,5)",
        "    InfoBox(\"Letters Database not available, try again later!...\",;",
        "               \"CLETTERS.DBF PROBLEM\")",
        "    LtrDBFOK:\u003d.F.",
        "  ENDIF",
        "",
        "  FOR x :\u003d 1 TO len(a1)",
        "    rawltr_no :\u003d val(substr(a1[x],1,3))",
        "    IF LtrDBFOK",
        "      locate FOR letter_no \u003d rawltr_no",
        "    ENDIF",
        "    IF LtrDBFOK .AND. !eof()",
        "      a1[x] :\u003d dtoc(DatePack(substr(a1[x],4)))+;",
        "                      \u0027  \u0027+alltrim(cLetters-\u003ename)+\u0027  (\u0027+strZero(rawltr_no,3)+\u0027)\u0027",
        "    ELSE",
        "      a1[x] :\u003d dtoc(DatePack(substr(a1[x],4)))+;",
        "                      \u0027  Unknown letter sent  (\u0027+strZero(rawltr_no,3)+\u0027)\u0027",
        "    ENDIF",
        "  NEXT x",
        "  USE",
        "  SELECT(oldArea)  // get back to original area"
      ]
    }
  },
  {
    "message": "Expected end expression after TO at 130425",
    "offset": 130425,
    "line": 4105,
    "column": 5,
    "evidence": {
      "startLine": 4095,
      "endLine": 4115,
      "focusLine": 4105,
      "lines": [
        "    InfoBox(\"Letters Database not available, try again later!...\",;",
        "               \"CLETTERS.DBF PROBLEM\")",
        "    LtrDBFOK:\u003d.F.",
        "  ENDIF",
        "",
        "  FOR x :\u003d 1 TO len(a1)",
        "    rawltr_no :\u003d val(substr(a1[x],1,3))",
        "    IF LtrDBFOK",
        "      locate FOR letter_no \u003d rawltr_no",
        "    ENDIF",
        "    IF LtrDBFOK .AND. !eof()",
        "      a1[x] :\u003d dtoc(DatePack(substr(a1[x],4)))+;",
        "                      \u0027  \u0027+alltrim(cLetters-\u003ename)+\u0027  (\u0027+strZero(rawltr_no,3)+\u0027)\u0027",
        "    ELSE",
        "      a1[x] :\u003d dtoc(DatePack(substr(a1[x],4)))+;",
        "                      \u0027  Unknown letter sent  (\u0027+strZero(rawltr_no,3)+\u0027)\u0027",
        "    ENDIF",
        "  NEXT x",
        "  USE",
        "  SELECT(oldArea)  // get back to original area",
        "ELSE"
      ]
    }
  },
  {
    "message": "Expected TO in FOR statement at 132422",
    "offset": 132422,
    "line": 4166,
    "column": 7,
    "evidence": {
      "startLine": 4156,
      "endLine": 4176,
      "focusLine": 4166,
      "lines": [
        "//",
        "//------------------------------------------------",
        "FUNCTION LtrNameFromCode(ltrCode)",
        "LOCAL cLtrName:\u003d\"\", oldarea:\u003dSELE(), ltr_no",
        "IF ! empty(LtrCode)",
        "  dbSelectArea(0)",
        "  IF fExists(datapath()+\"CLETTERS.DBF\") .AND. net_use(\u0027cletters\u0027,.F.,5)",
        "    ltr_no :\u003d val(ltrCode)",
        "    IF ltr_no \u003e 0 .AND. ltr_no \u003c 1000",
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\""
      ]
    }
  },
  {
    "message": "Unexpected token IF at 132422",
    "offset": 132422,
    "line": 4166,
    "column": 7,
    "evidence": {
      "startLine": 4156,
      "endLine": 4176,
      "focusLine": 4166,
      "lines": [
        "//",
        "//------------------------------------------------",
        "FUNCTION LtrNameFromCode(ltrCode)",
        "LOCAL cLtrName:\u003d\"\", oldarea:\u003dSELE(), ltr_no",
        "IF ! empty(LtrCode)",
        "  dbSelectArea(0)",
        "  IF fExists(datapath()+\"CLETTERS.DBF\") .AND. net_use(\u0027cletters\u0027,.F.,5)",
        "    ltr_no :\u003d val(ltrCode)",
        "    IF ltr_no \u003e 0 .AND. ltr_no \u003c 1000",
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\""
      ]
    }
  },
  {
    "message": "Expected end expression after TO at 132425",
    "offset": 132425,
    "line": 4166,
    "column": 10,
    "evidence": {
      "startLine": 4156,
      "endLine": 4176,
      "focusLine": 4166,
      "lines": [
        "//",
        "//------------------------------------------------",
        "FUNCTION LtrNameFromCode(ltrCode)",
        "LOCAL cLtrName:\u003d\"\", oldarea:\u003dSELE(), ltr_no",
        "IF ! empty(LtrCode)",
        "  dbSelectArea(0)",
        "  IF fExists(datapath()+\"CLETTERS.DBF\") .AND. net_use(\u0027cletters\u0027,.F.,5)",
        "    ltr_no :\u003d val(ltrCode)",
        "    IF ltr_no \u003e 0 .AND. ltr_no \u003c 1000",
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\""
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 132504",
    "offset": 132504,
    "line": 4168,
    "column": 7,
    "evidence": {
      "startLine": 4158,
      "endLine": 4178,
      "focusLine": 4168,
      "lines": [
        "FUNCTION LtrNameFromCode(ltrCode)",
        "LOCAL cLtrName:\u003d\"\", oldarea:\u003dSELE(), ltr_no",
        "IF ! empty(LtrCode)",
        "  dbSelectArea(0)",
        "  IF fExists(datapath()+\"CLETTERS.DBF\") .AND. net_use(\u0027cletters\u0027,.F.,5)",
        "    ltr_no :\u003d val(ltrCode)",
        "    IF ltr_no \u003e 0 .AND. ltr_no \u003c 1000",
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\"",
        "ENDIF",
        "RETURN cLtrName"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 132552",
    "offset": 132552,
    "line": 4170,
    "column": 7,
    "evidence": {
      "startLine": 4160,
      "endLine": 4180,
      "focusLine": 4170,
      "lines": [
        "IF ! empty(LtrCode)",
        "  dbSelectArea(0)",
        "  IF fExists(datapath()+\"CLETTERS.DBF\") .AND. net_use(\u0027cletters\u0027,.F.,5)",
        "    ltr_no :\u003d val(ltrCode)",
        "    IF ltr_no \u003e 0 .AND. ltr_no \u003c 1000",
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\"",
        "ENDIF",
        "RETURN cLtrName",
        "//EOF LtrNameFromCode",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 132562",
    "offset": 132562,
    "line": 4171,
    "column": 5,
    "evidence": {
      "startLine": 4161,
      "endLine": 4181,
      "focusLine": 4171,
      "lines": [
        "  dbSelectArea(0)",
        "  IF fExists(datapath()+\"CLETTERS.DBF\") .AND. net_use(\u0027cletters\u0027,.F.,5)",
        "    ltr_no :\u003d val(ltrCode)",
        "    IF ltr_no \u003e 0 .AND. ltr_no \u003c 1000",
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\"",
        "ENDIF",
        "RETURN cLtrName",
        "//EOF LtrNameFromCode",
        "",
        "   //"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 132628",
    "offset": 132628,
    "line": 4174,
    "column": 3,
    "evidence": {
      "startLine": 4164,
      "endLine": 4184,
      "focusLine": 4174,
      "lines": [
        "    IF ltr_no \u003e 0 .AND. ltr_no \u003c 1000",
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\"",
        "ENDIF",
        "RETURN cLtrName",
        "//EOF LtrNameFromCode",
        "",
        "   //",
        "//------------------------------------------------",
        "FUNCTION AddLtrHistory(cInTxt,cNew, cIndex8)    // NEED TO DO   putNote(aCrtDay,aFilePos[3])  after AddLtrHistory in moving",
        "LOCAL cTxt:\u003d\"\", xTop, xBot            // Maybe pass aCrtDay to here then we can write it out..."
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 132634",
    "offset": 132634,
    "line": 4175,
    "column": 1,
    "evidence": {
      "startLine": 4165,
      "endLine": 4185,
      "focusLine": 4175,
      "lines": [
        "      locate FOR letter_no \u003d ltr_no",
        "      IF cLetters-\u003eLETTER_NO \u003d ltr_no",
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\"",
        "ENDIF",
        "RETURN cLtrName",
        "//EOF LtrNameFromCode",
        "",
        "   //",
        "//------------------------------------------------",
        "FUNCTION AddLtrHistory(cInTxt,cNew, cIndex8)    // NEED TO DO   putNote(aCrtDay,aFilePos[3])  after AddLtrHistory in moving",
        "LOCAL cTxt:\u003d\"\", xTop, xBot            // Maybe pass aCrtDay to here then we can write it out...",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 132656",
    "offset": 132656,
    "line": 4177,
    "column": 1,
    "evidence": {
      "startLine": 4167,
      "endLine": 4187,
      "focusLine": 4177,
      "lines": [
        "        cLtrName :\u003d alltrim(cLetters-\u003ename)",
        "      ELSE",
        "        cLtrName :\u003d \u0027Unknown letter\u0027",
        "      ENDIF",
        "    ENDIF",
        "    USE",
        "    SELECT(oldArea)  // get back to original area",
        "  ENDIF",
        "ELSE",
        "  cLtrName :\u003d \"\"",
        "ENDIF",
        "RETURN cLtrName",
        "//EOF LtrNameFromCode",
        "",
        "   //",
        "//------------------------------------------------",
        "FUNCTION AddLtrHistory(cInTxt,cNew, cIndex8)    // NEED TO DO   putNote(aCrtDay,aFilePos[3])  after AddLtrHistory in moving",
        "LOCAL cTxt:\u003d\"\", xTop, xBot            // Maybe pass aCrtDay to here then we can write it out...",
        "",
        "IF \"********* OLD LETTERS *********\"$cInTxt .AND. \"******* END OLD LETTERS *******\"$cInTxt",
        "  xTop :\u003d substr(cInTxt,1,at(\"******* END OLD LETTERS *******\",cInTxt)-1)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 143067",
    "offset": 143067,
    "line": 4485,
    "column": 1,
    "evidence": {
      "startLine": 4475,
      "endLine": 4495,
      "focusLine": 4485,
      "lines": [
        "             SYSICON XBPSTATIC_SYSICON_ICONWARNING ;",
        "             TITLE \"ENTRY ERROR\"",
        "    IF nChoice \u003c\u003e 2",
        "      lRet :\u003d .F.",
        "    ENDIF",
        "  ENDIF",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(OldRec)",
        "  SELE(oldArea)",
        "  RETURN lRet",
        "ENDIF",
        "",
        "IF nRBP \u003d\u003d 0",
        "  IF len(cTrigger)\u003d1 .AND. cTrigger$\".*?\"",
        "    uhoh()",
        "    RETURN .F.",
        "  ELSE",
        "    RETURN .T.",
        "  ENDIF",
        "ENDIF",
        "IF nRBP \u003e 6 .OR. nRBP \u003c 1    // Should never happen, but why not check it anyway?"
      ]
    }
  },
  {
    "message": "Expected \u0027:\u003d\u0027 after FOR iterator at 151619",
    "offset": 151619,
    "line": 4787,
    "column": 21,
    "evidence": {
      "startLine": 4777,
      "endLine": 4797,
      "focusLine": 4787,
      "lines": [
        "aTemp[5] :\u003d client-\u003eBAIL_RECT",
        "aTemp[6] :\u003d client-\u003ePRK_RECT",
        "aTemp[7] :\u003d CriptStr(\"None      x\",\"E\")",
        "CLOSE Client",
        "net_use(\u0027JUDGES\u0027,.F.,10)",
        "FOR x:\u003d1 TO niNumJudge",
        "  a1Rect :\u003d array(5)    // {Name, NextFineRec, NextBailRec, NextParkRec, src}",
        "  cCurJudge :\u003d substr(cJudgeList,2,3)",
        "  cJudgeList :\u003d substr(cJudgeList,5)",
        "",
        "  LOCATE FOR  Judges-\u003eINITIALS \u003d\u003d cCurJudge",
        "  IF found()",
        "    aTemp[1] :\u003d Judges-\u003eRECT_NO",
        "    aTemp[2] :\u003d Judges-\u003eBAIL_RECT",
        "    aTemp[3] :\u003d Judges-\u003ePRK_RECT",
        "    _fSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,1,1))",
        "    _bSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,2,1))",
        "    _pSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,3,1))",
        "    _fSrc :\u003d IIF(_fSrc\u003d0, 7, _fSrc)",
        "    _bSrc :\u003d IIF(_bSrc\u003d0, 7, _bSrc)",
        "    _pSrc :\u003d IIF(_pSrc\u003d0, 7, _pSrc)"
      ]
    }
  },
  {
    "message": "Unexpected token ARROW at 151619",
    "offset": 151619,
    "line": 4787,
    "column": 21,
    "evidence": {
      "startLine": 4777,
      "endLine": 4797,
      "focusLine": 4787,
      "lines": [
        "aTemp[5] :\u003d client-\u003eBAIL_RECT",
        "aTemp[6] :\u003d client-\u003ePRK_RECT",
        "aTemp[7] :\u003d CriptStr(\"None      x\",\"E\")",
        "CLOSE Client",
        "net_use(\u0027JUDGES\u0027,.F.,10)",
        "FOR x:\u003d1 TO niNumJudge",
        "  a1Rect :\u003d array(5)    // {Name, NextFineRec, NextBailRec, NextParkRec, src}",
        "  cCurJudge :\u003d substr(cJudgeList,2,3)",
        "  cJudgeList :\u003d substr(cJudgeList,5)",
        "",
        "  LOCATE FOR  Judges-\u003eINITIALS \u003d\u003d cCurJudge",
        "  IF found()",
        "    aTemp[1] :\u003d Judges-\u003eRECT_NO",
        "    aTemp[2] :\u003d Judges-\u003eBAIL_RECT",
        "    aTemp[3] :\u003d Judges-\u003ePRK_RECT",
        "    _fSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,1,1))",
        "    _bSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,2,1))",
        "    _pSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,3,1))",
        "    _fSrc :\u003d IIF(_fSrc\u003d0, 7, _fSrc)",
        "    _bSrc :\u003d IIF(_bSrc\u003d0, 7, _bSrc)",
        "    _pSrc :\u003d IIF(_pSrc\u003d0, 7, _pSrc)"
      ]
    }
  },
  {
    "message": "Expected start expression after \u0027:\u003d\u0027 at 151621",
    "offset": 151621,
    "line": 4787,
    "column": 23,
    "evidence": {
      "startLine": 4777,
      "endLine": 4797,
      "focusLine": 4787,
      "lines": [
        "aTemp[5] :\u003d client-\u003eBAIL_RECT",
        "aTemp[6] :\u003d client-\u003ePRK_RECT",
        "aTemp[7] :\u003d CriptStr(\"None      x\",\"E\")",
        "CLOSE Client",
        "net_use(\u0027JUDGES\u0027,.F.,10)",
        "FOR x:\u003d1 TO niNumJudge",
        "  a1Rect :\u003d array(5)    // {Name, NextFineRec, NextBailRec, NextParkRec, src}",
        "  cCurJudge :\u003d substr(cJudgeList,2,3)",
        "  cJudgeList :\u003d substr(cJudgeList,5)",
        "",
        "  LOCATE FOR  Judges-\u003eINITIALS \u003d\u003d cCurJudge",
        "  IF found()",
        "    aTemp[1] :\u003d Judges-\u003eRECT_NO",
        "    aTemp[2] :\u003d Judges-\u003eBAIL_RECT",
        "    aTemp[3] :\u003d Judges-\u003ePRK_RECT",
        "    _fSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,1,1))",
        "    _bSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,2,1))",
        "    _pSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,3,1))",
        "    _fSrc :\u003d IIF(_fSrc\u003d0, 7, _fSrc)",
        "    _bSrc :\u003d IIF(_bSrc\u003d0, 7, _bSrc)",
        "    _pSrc :\u003d IIF(_pSrc\u003d0, 7, _pSrc)"
      ]
    }
  },
  {
    "message": "Expected TO in FOR statement at 151621",
    "offset": 151621,
    "line": 4787,
    "column": 23,
    "evidence": {
      "startLine": 4777,
      "endLine": 4797,
      "focusLine": 4787,
      "lines": [
        "aTemp[5] :\u003d client-\u003eBAIL_RECT",
        "aTemp[6] :\u003d client-\u003ePRK_RECT",
        "aTemp[7] :\u003d CriptStr(\"None      x\",\"E\")",
        "CLOSE Client",
        "net_use(\u0027JUDGES\u0027,.F.,10)",
        "FOR x:\u003d1 TO niNumJudge",
        "  a1Rect :\u003d array(5)    // {Name, NextFineRec, NextBailRec, NextParkRec, src}",
        "  cCurJudge :\u003d substr(cJudgeList,2,3)",
        "  cJudgeList :\u003d substr(cJudgeList,5)",
        "",
        "  LOCATE FOR  Judges-\u003eINITIALS \u003d\u003d cCurJudge",
        "  IF found()",
        "    aTemp[1] :\u003d Judges-\u003eRECT_NO",
        "    aTemp[2] :\u003d Judges-\u003eBAIL_RECT",
        "    aTemp[3] :\u003d Judges-\u003ePRK_RECT",
        "    _fSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,1,1))",
        "    _bSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,2,1))",
        "    _pSrc :\u003d val(substr(Judges-\u003eREC_SOURCE,3,1))",
        "    _fSrc :\u003d IIF(_fSrc\u003d0, 7, _fSrc)",
        "    _bSrc :\u003d IIF(_bSrc\u003d0, 7, _bSrc)",
        "    _pSrc :\u003d IIF(_pSrc\u003d0, 7, _pSrc)"
      ]
    }
  },
  {
    "message": "Unexpected token ENDDO at 156745",
    "offset": 156745,
    "line": 4950,
    "column": 3,
    "evidence": {
      "startLine": 4940,
      "endLine": 4960,
      "focusLine": 4950,
      "lines": [
        "DO WHILE x\u003c\u003dlen(aTemp).AND.valType(aTemp[x])\u003c\u003e\"U\"",
        "  i:\u003dx+1",
        "  DO WHILE i\u003c\u003dlen(aTemp) .AND. aTemp[x,1,2]\u003d\u003daTemp[i,1,2]  // are keys the same?",
        "    FOR z:\u003d1 to len(aTemp[x,2])         // If yes then sum all numeric elements",
        "      IF valType(aTemp[x,2,z])\u003d\u003d\"N\" .AND. valType(aTemp[i,2,z])\u003d\u003d\"N\"",
        "        aTemp[x,2,z] +\u003d aTemp[i,2,z]    // Sum the two elements",
        "      ENDIF",
        "    NEXT",
        "    aTemp[i,1,1]:\u003d0",
        "    i++",
        "  ENDDO",
        "  aLen:\u003dx                                 // x accumulates only good records",
        "  x:\u003di",
        "ENDDO",
        "",
        "aSort(aTemp,,, {|aX,aY| aX[1,1] \u003c aY[1,1] } ) // put array back into original order",
        "aSize(aTarget,0)",
        "FOR x:\u003d1 to len(aTemp)",
        "  IF aTemp[x,1,1]\u003e0",
        "    aAdd(aTarget,aTemp[x,2])",
        "  ENDIF"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 156753",
    "offset": 156753,
    "line": 4951,
    "column": 3,
    "evidence": {
      "startLine": 4941,
      "endLine": 4961,
      "focusLine": 4951,
      "lines": [
        "  i:\u003dx+1",
        "  DO WHILE i\u003c\u003dlen(aTemp) .AND. aTemp[x,1,2]\u003d\u003daTemp[i,1,2]  // are keys the same?",
        "    FOR z:\u003d1 to len(aTemp[x,2])         // If yes then sum all numeric elements",
        "      IF valType(aTemp[x,2,z])\u003d\u003d\"N\" .AND. valType(aTemp[i,2,z])\u003d\u003d\"N\"",
        "        aTemp[x,2,z] +\u003d aTemp[i,2,z]    // Sum the two elements",
        "      ENDIF",
        "    NEXT",
        "    aTemp[i,1,1]:\u003d0",
        "    i++",
        "  ENDDO",
        "  aLen:\u003dx                                 // x accumulates only good records",
        "  x:\u003di",
        "ENDDO",
        "",
        "aSort(aTemp,,, {|aX,aY| aX[1,1] \u003c aY[1,1] } ) // put array back into original order",
        "aSize(aTarget,0)",
        "FOR x:\u003d1 to len(aTemp)",
        "  IF aTemp[x,1,1]\u003e0",
        "    aAdd(aTarget,aTemp[x,2])",
        "  ENDIF",
        "NEXT"
      ]
    }
  },
  {
    "message": "Unexpected token ENDDO at 164089",
    "offset": 164089,
    "line": 5206,
    "column": 3,
    "evidence": {
      "startLine": 5196,
      "endLine": 5216,
      "focusLine": 5206,
      "lines": [
        "    ENDIF",
        "    IF \"^#\"$obj:getData()",
        "      cText :\u003d obj:getData()           // ^# marks landing spot for cursor after insert!",
        "      t :\u003d at(\"^#\",cText)",
        "      cText :\u003d strtran(cText,\"^#\",\"\")",
        "      obj:setData(cText)",
        "      obj:setFirstChar(IIF(lAtTop,1,t))",
        "      obj:setMarked({t,t})",
        "    ENDIF",
        "    nLoop++",
        "  ENDDO",
        "ENDIF",
        "ENDSEQUENCE               // END OF SEQUENCE FOR ERROR TRAPPING",
        "error_trap :\u003d \"\"",
        "RETURN",
        "// EOP AddBoiler",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION GetAltBoiler(cx)",
        "LOCAL ct, cTop"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 164095",
    "offset": 164095,
    "line": 5207,
    "column": 1,
    "evidence": {
      "startLine": 5197,
      "endLine": 5217,
      "focusLine": 5207,
      "lines": [
        "    IF \"^#\"$obj:getData()",
        "      cText :\u003d obj:getData()           // ^# marks landing spot for cursor after insert!",
        "      t :\u003d at(\"^#\",cText)",
        "      cText :\u003d strtran(cText,\"^#\",\"\")",
        "      obj:setData(cText)",
        "      obj:setFirstChar(IIF(lAtTop,1,t))",
        "      obj:setMarked({t,t})",
        "    ENDIF",
        "    nLoop++",
        "  ENDDO",
        "ENDIF",
        "ENDSEQUENCE               // END OF SEQUENCE FOR ERROR TRAPPING",
        "error_trap :\u003d \"\"",
        "RETURN",
        "// EOP AddBoiler",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION GetAltBoiler(cx)",
        "LOCAL ct, cTop",
        "ct :\u003d cx"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 164095",
    "offset": 164095,
    "line": 5207,
    "column": 1,
    "evidence": {
      "startLine": 5197,
      "endLine": 5217,
      "focusLine": 5207,
      "lines": [
        "    IF \"^#\"$obj:getData()",
        "      cText :\u003d obj:getData()           // ^# marks landing spot for cursor after insert!",
        "      t :\u003d at(\"^#\",cText)",
        "      cText :\u003d strtran(cText,\"^#\",\"\")",
        "      obj:setData(cText)",
        "      obj:setFirstChar(IIF(lAtTop,1,t))",
        "      obj:setMarked({t,t})",
        "    ENDIF",
        "    nLoop++",
        "  ENDDO",
        "ENDIF",
        "ENDSEQUENCE               // END OF SEQUENCE FOR ERROR TRAPPING",
        "error_trap :\u003d \"\"",
        "RETURN",
        "// EOP AddBoiler",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION GetAltBoiler(cx)",
        "LOCAL ct, cTop",
        "ct :\u003d cx"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 167741",
    "offset": 167741,
    "line": 5320,
    "column": 23,
    "evidence": {
      "startLine": 5310,
      "endLine": 5330,
      "focusLine": 5320,
      "lines": [
        "    aLines[x,2] :\u003d substr(aLines[x,2]+space(60),1,60)",
        "  NEXT",
        "  SEIStdDialog oDlg   ;",
        "              TITLE \"EDIT\"         ;",
        "              SIZE {580,440}       ;",
        "              STOREGETLIST GetList ;",
        "              WINMENU",
        "",
        "  @  0, 1 DCSAY \u0027\u0027  // needed for AUTOFIT to hold left margin",
        "  @  0, 4 DCSAY \"Note ClipBoard Variables\"  ;",
        "            SAYSIZE 40,1.2 ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "            SAYFONT cStdLargeSay",
        "",
        "  FOR x:\u003d1 to Len(aLines)",
        "",
        "    @ 0.5+(1.2*x),1 DCSAY aLines[x,1] GET aLines[x,2] ;",
        "         SAYRIGHT ;",
        "         SAYSIZE 10 ;",
        "         GETSIZE 35 ;",
        "         PICT \u0027@S35\u0027"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 168015",
    "offset": 168015,
    "line": 5331,
    "column": 3,
    "evidence": {
      "startLine": 5321,
      "endLine": 5341,
      "focusLine": 5331,
      "lines": [
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "            SAYFONT cStdLargeSay",
        "",
        "  FOR x:\u003d1 to Len(aLines)",
        "",
        "    @ 0.5+(1.2*x),1 DCSAY aLines[x,1] GET aLines[x,2] ;",
        "         SAYRIGHT ;",
        "         SAYSIZE 10 ;",
        "         GETSIZE 35 ;",
        "         PICT \u0027@S35\u0027",
        "  NEXT",
        "",
        "  @ LastLn,4 DCPUSHBUTTON CAPTION \"OK\" SIZE 10,1.5  ;",
        "             ACCELKEY xbeK_CTRL_O ;",
        "             TOOLTIP \"Store any changes\" ;",
        "             TABSTOP FONT BTN_FONT_B ;",
        "             ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList) }",
        "",
        "  @ LastLn,15 DCPUSHBUTTON CAPTION \"CANCEL\" SIZE 10,1.5 ;",
        "             ACCELKEY xbeK_CTRL_C ;",
        "             TOOLTIP \"Quit without saving\" ;"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 168067",
    "offset": 168067,
    "line": 5333,
    "column": 47,
    "evidence": {
      "startLine": 5323,
      "endLine": 5343,
      "focusLine": 5333,
      "lines": [
        "",
        "  FOR x:\u003d1 to Len(aLines)",
        "",
        "    @ 0.5+(1.2*x),1 DCSAY aLines[x,1] GET aLines[x,2] ;",
        "         SAYRIGHT ;",
        "         SAYSIZE 10 ;",
        "         GETSIZE 35 ;",
        "         PICT \u0027@S35\u0027",
        "  NEXT",
        "",
        "  @ LastLn,4 DCPUSHBUTTON CAPTION \"OK\" SIZE 10,1.5  ;",
        "             ACCELKEY xbeK_CTRL_O ;",
        "             TOOLTIP \"Store any changes\" ;",
        "             TABSTOP FONT BTN_FONT_B ;",
        "             ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList) }",
        "",
        "  @ LastLn,15 DCPUSHBUTTON CAPTION \"CANCEL\" SIZE 10,1.5 ;",
        "             ACCELKEY xbeK_CTRL_C ;",
        "             TOOLTIP \"Quit without saving\" ;",
        "             CARGO \u0027CANCEL\u0027 ;",
        "             TABSTOP FONT BTN_FONT_B  ;"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 169293",
    "offset": 169293,
    "line": 5368,
    "column": 3,
    "evidence": {
      "startLine": 5358,
      "endLine": 5378,
      "focusLine": 5368,
      "lines": [
        "          PARENT @oDlg       ;",
        "          FIT                 ;",
        "          EVAL {|oDlg| IIF(!Ok2Resize(),LockSize(oDlg),NIL),;",
        "                        oDlg:show(),;",
        "                        SetAppFocus(oDlg)}",
        "  GetList:\u003d{}",
        "  DestroyAll( @oDlg )",
        "  oDlg :\u003d NIL",
        "  FOR x:\u003d1 to Len(aLines)",
        "    aLines[x,2] :\u003d alltrim(aLines[x,2])",
        "  NEXT",
        "//    IF .F. //lAddVar",
        "//      //  So add one!",
        "//    ENDIF",
        "RETURN lOK                 // call EditBoilerVars with a do while loop so EditBoilerVars will be reEntrant!",
        "// EOF EditBoilerVars",
        "",
        "// Creates a dialog by pressing F6 on a Note screen.  The dialog allows the user to enter Payment Plan",
        "//  information.  The Payment Plan information is then inserted into the notes for the court\u0027s records.",
        "//  Some of the data is also inserted into charge-\u003eflags[3].",
        "//  The dialog will also update the the Payment Plan options based on what State Fees the user enters."
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 171139",
    "offset": 171139,
    "line": 5397,
    "column": 36,
    "evidence": {
      "startLine": 5387,
      "endLine": 5407,
      "focusLine": 5397,
      "lines": [
        "// RETURNs: lRetPersisted -  Returns TRUE if new data was persisted or if no data needs to be persisted.",
        "//  If data needs to be persisted, but p_lPersistPP was FALSE, then the function returns FALSE.",
        "FUNCTION PaymentPlanNotes(obj, p_lPersistPP)",
        "LOCAL GetList:\u003d{}, oPPDlg, GetOptions, lOK, nAutoSetFinalDate,;",
        "      bAutoDateAlertBox, oFirstPaymentDate, cSLFMessage, lRetPersisted:\u003d.T.,;",
        "      cLessThanMinimumPaymentWarning, lPPLetter:\u003d.F., oLetterThread,;",
        "      cFinalDateTooSoon, cFinalDateTooLate, cScoffAlreadyPaidMessage,;",
        "      cScoffAlreadyPaidMoreMessage, lStateFeesDue, nScoffTotalPaid,;",
        "      nSFCurrentPay:\u003d0, aAllCourtDayScofflawedDesc, bScoffAddCheck,;",
        "      aWaivedFFS",
        "PRIVATE dFirstPaymentDate:\u003dCtoD(\"\"), nInstallmentAmount:\u003d25.00, dFinalDate:\u003dCtoD(\"\"),;",
        "        nScoffFee:\u003d0, nSexOffenderFee:\u003d0, nDNARegistryFee:\u003d0, nSexOffenseVictimFee:\u003d0,;",
        "        nTotalDueWithStateFees:\u003d0, bTotalDueWithStateFees, lEditProtect:\u003d.T.,;",
        "        aSFD_SFDefaults:\u003d{}, bNoStateFeeDefaultMessage, aFPD_SFFeesPaidsDues,;",
        "        bCheckScoffDefault, bCheckSOFDefault, bCheckDNADefault, bCheckSOVFDefault,;",
        "        cNotDefaultTooltip, cNotDefaultMessage, oSFNotDefault,;",
        "        nChargeAlreadyPaid, nTotalAlreadyPaid, cPaymentsAlreadyMade,;",
        "        aSFPPB_Booleans, cSFAndPPIndicator, aPaymentPlanDialogValues, oFinalDateSkipDateVal,;",
        "        dFinalDateExact, lRemove:\u003d.F., nScoffableCharges, cNoEligibleScoffsMsg,;",
        "        bNoStateFeeOnCaseMessage, lUsingDefaultStateFees:\u003d.T., lDefaultPermission:\u003d(GetLevel(84)\u003c\u003e\"D\"),;",
        "        bScoffPartialWaiveMesage"
      ]
    }
  },
  {
    "message": "Unexpected ELSEIF at 172965",
    "offset": 172965,
    "line": 5425,
    "column": 3,
    "evidence": {
      "startLine": 5415,
      "endLine": 5435,
      "focusLine": 5425,
      "lines": [
        "  aWaivedFFS :\u003d GetWaivedFFS(aCharge[1,ccFlags], aCharge[1,ncSpare4])",
        "",
        "  // If there already is a PP set up, we can grab the options from it.",
        "  aSFPPB_Booleans :\u003d GetSFAndPPBits(aChg[ccFlags,cCF_SF_PAYPLAN])",
        "  // If at least one State Fee is already set, use the current aSFPPB_Booleans[lSFPPB_SFD] value.",
        "  //  Otherwise, if there is not currently a Payment Plan, set aSFPPB_Booleans[lSFPPB_SFD] to TRUE.",
        "  //  Note: aSFPPB_Booleans[lSFPPB_SFD] represents the SFDefault value when the dialog is first opened.",
        "  //        lUsingDefaultStateFees represents the current SFDault value.",
        "  IF Eval(bIsThereAtLeastOneSF)",
        "    lUsingDefaultStateFees :\u003d aSFPPB_Booleans[lSFPPB_SFD]   ",
        "  ELSEIF !aSFPPB_Booleans[lSFPPB_PAYPLAN]",
        "    aSFPPB_Booleans[lSFPPB_SFD] :\u003d .T.",
        "  ENDIF",
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already."
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 173046",
    "offset": 173046,
    "line": 5427,
    "column": 3,
    "evidence": {
      "startLine": 5417,
      "endLine": 5437,
      "focusLine": 5427,
      "lines": [
        "  // If there already is a PP set up, we can grab the options from it.",
        "  aSFPPB_Booleans :\u003d GetSFAndPPBits(aChg[ccFlags,cCF_SF_PAYPLAN])",
        "  // If at least one State Fee is already set, use the current aSFPPB_Booleans[lSFPPB_SFD] value.",
        "  //  Otherwise, if there is not currently a Payment Plan, set aSFPPB_Booleans[lSFPPB_SFD] to TRUE.",
        "  //  Note: aSFPPB_Booleans[lSFPPB_SFD] represents the SFDefault value when the dialog is first opened.",
        "  //        lUsingDefaultStateFees represents the current SFDault value.",
        "  IF Eval(bIsThereAtLeastOneSF)",
        "    lUsingDefaultStateFees :\u003d aSFPPB_Booleans[lSFPPB_SFD]   ",
        "  ELSEIF !aSFPPB_Booleans[lSFPPB_PAYPLAN]",
        "    aSFPPB_Booleans[lSFPPB_SFD] :\u003d .T.",
        "  ENDIF",
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already.",
        "  nTotalAlreadyPaid :\u003d nChargeAlreadyPaid",
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already."
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 173820",
    "offset": 173820,
    "line": 5438,
    "column": 78,
    "evidence": {
      "startLine": 5428,
      "endLine": 5448,
      "focusLine": 5438,
      "lines": [
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already.",
        "  nTotalAlreadyPaid :\u003d nChargeAlreadyPaid",
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already.",
        "  AEval(aFPD_SFFeesPaidsDues, {|x,i| IIF(!Empty(x[nSF_PAID]), nSFCurrentPay +\u003d x[nSF_PAID], NIL)})",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  // If SLF due is greater than the CAP (currently 400), set it to 400, ",
        "  // since that is the max for a Payment Plan.",
        "  IF ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\";",
        "            .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] \u003e aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] :\u003d aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] :\u003d ;",
        "                aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] - aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]",
        "  ENDIF",
        "  nTotalAlreadyPaid +\u003d nSFCurrentPay"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 173822",
    "offset": 173822,
    "line": 5438,
    "column": 80,
    "evidence": {
      "startLine": 5428,
      "endLine": 5448,
      "focusLine": 5438,
      "lines": [
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already.",
        "  nTotalAlreadyPaid :\u003d nChargeAlreadyPaid",
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already.",
        "  AEval(aFPD_SFFeesPaidsDues, {|x,i| IIF(!Empty(x[nSF_PAID]), nSFCurrentPay +\u003d x[nSF_PAID], NIL)})",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  // If SLF due is greater than the CAP (currently 400), set it to 400, ",
        "  // since that is the max for a Payment Plan.",
        "  IF ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\";",
        "            .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] \u003e aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] :\u003d aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] :\u003d ;",
        "                aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] - aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]",
        "  ENDIF",
        "  nTotalAlreadyPaid +\u003d nSFCurrentPay"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 173822",
    "offset": 173822,
    "line": 5438,
    "column": 80,
    "evidence": {
      "startLine": 5428,
      "endLine": 5448,
      "focusLine": 5438,
      "lines": [
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already.",
        "  nTotalAlreadyPaid :\u003d nChargeAlreadyPaid",
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already.",
        "  AEval(aFPD_SFFeesPaidsDues, {|x,i| IIF(!Empty(x[nSF_PAID]), nSFCurrentPay +\u003d x[nSF_PAID], NIL)})",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  // If SLF due is greater than the CAP (currently 400), set it to 400, ",
        "  // since that is the max for a Payment Plan.",
        "  IF ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\";",
        "            .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] \u003e aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] :\u003d aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] :\u003d ;",
        "                aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] - aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]",
        "  ENDIF",
        "  nTotalAlreadyPaid +\u003d nSFCurrentPay"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 173822",
    "offset": 173822,
    "line": 5438,
    "column": 80,
    "evidence": {
      "startLine": 5428,
      "endLine": 5448,
      "focusLine": 5438,
      "lines": [
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already.",
        "  nTotalAlreadyPaid :\u003d nChargeAlreadyPaid",
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already.",
        "  AEval(aFPD_SFFeesPaidsDues, {|x,i| IIF(!Empty(x[nSF_PAID]), nSFCurrentPay +\u003d x[nSF_PAID], NIL)})",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  // If SLF due is greater than the CAP (currently 400), set it to 400, ",
        "  // since that is the max for a Payment Plan.",
        "  IF ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\";",
        "            .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] \u003e aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] :\u003d aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] :\u003d ;",
        "                aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] - aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]",
        "  ENDIF",
        "  nTotalAlreadyPaid +\u003d nSFCurrentPay"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 173822",
    "offset": 173822,
    "line": 5438,
    "column": 80,
    "evidence": {
      "startLine": 5428,
      "endLine": 5448,
      "focusLine": 5438,
      "lines": [
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already.",
        "  nTotalAlreadyPaid :\u003d nChargeAlreadyPaid",
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already.",
        "  AEval(aFPD_SFFeesPaidsDues, {|x,i| IIF(!Empty(x[nSF_PAID]), nSFCurrentPay +\u003d x[nSF_PAID], NIL)})",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  // If SLF due is greater than the CAP (currently 400), set it to 400, ",
        "  // since that is the max for a Payment Plan.",
        "  IF ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\";",
        "            .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] \u003e aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] :\u003d aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] :\u003d ;",
        "                aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] - aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]",
        "  ENDIF",
        "  nTotalAlreadyPaid +\u003d nSFCurrentPay"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 173833",
    "offset": 173833,
    "line": 5438,
    "column": 91,
    "evidence": {
      "startLine": 5428,
      "endLine": 5448,
      "focusLine": 5438,
      "lines": [
        "  // Does the original Scoff Lift Fee calculations",
        "  lStateFeesDue :\u003d GetStateFeesCaseData(axLocals, @cSLFMessage, .T., /*4*/,;",
        "                                          @nScoffableCharges, @aAllCourtDayScofflawedDesc, /*7*/,;",
        "                                          .T., /*9*/, @aFPD_SFFeesPaidsDues)",
        "  // The total amount paid for Scoff Lift Fees, not just current.",
        "  nScoffTotalPaid :\u003d (GetCurrentSFAmountsPaid(axLocals))[nSFD_SCOFF_FEE]",
        "  nChargeAlreadyPaid :\u003d nTotFine + nTotFee + nTotCivFee",
        "  // The total of all payments made on the case already.",
        "  nTotalAlreadyPaid :\u003d nChargeAlreadyPaid",
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already.",
        "  AEval(aFPD_SFFeesPaidsDues, {|x,i| IIF(!Empty(x[nSF_PAID]), nSFCurrentPay +\u003d x[nSF_PAID], NIL)})",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  // If SLF due is greater than the CAP (currently 400), set it to 400, ",
        "  // since that is the max for a Payment Plan.",
        "  IF ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\";",
        "            .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] \u003e aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] :\u003d aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] :\u003d ;",
        "                aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] - aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]",
        "  ENDIF",
        "  nTotalAlreadyPaid +\u003d nSFCurrentPay"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 174454",
    "offset": 174454,
    "line": 5447,
    "column": 3,
    "evidence": {
      "startLine": 5437,
      "endLine": 5457,
      "focusLine": 5447,
      "lines": [
        "  // Add the total of all (only current SLF, not total) State Fees paid on the case already.",
        "  AEval(aFPD_SFFeesPaidsDues, {|x,i| IIF(!Empty(x[nSF_PAID]), nSFCurrentPay +\u003d x[nSF_PAID], NIL)})",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  // If SLF due is greater than the CAP (currently 400), set it to 400, ",
        "  // since that is the max for a Payment Plan.",
        "  IF ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\";",
        "            .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] \u003e aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] :\u003d aSFD_SFDefaults[nSFD_SCOFF_CAP]",
        "    aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE] :\u003d ;",
        "                aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE] - aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]",
        "  ENDIF",
        "  nTotalAlreadyPaid +\u003d nSFCurrentPay",
        "  // The message to display if the user enters a value less than the minimum Installment Amount.",
        "  cLessThanMinimumPaymentWarning :\u003d \"WARNING: The minimum payment per; month is supposed to be at least $25.\"",
        "  // Let the user know the Final Date they chose may be too soon.",
        "  cFinalDateTooSoon :\u003d \"WARNING: The date you selected may be too soon to allow the defendant\";",
        "                        + \" to fully pay.;;\"+;",
        "                       \"Consider making the Final Date later or increasing the Installment Amount.\"",
        "  cFinalDateTooLate :\u003d \"WARNING: The date you selected may be too late based on how much the\";",
        "                        + \" defendant is paying each month.;;\"+;",
        "                       \"Consider making the Final Date earlier or decreasing the Installment Amount.\""
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 175591",
    "offset": 175591,
    "line": 5461,
    "column": 51,
    "evidence": {
      "startLine": 5451,
      "endLine": 5471,
      "focusLine": 5461,
      "lines": [
        "  // Let the user know the Final Date they chose may be too soon.",
        "  cFinalDateTooSoon :\u003d \"WARNING: The date you selected may be too soon to allow the defendant\";",
        "                        + \" to fully pay.;;\"+;",
        "                       \"Consider making the Final Date later or increasing the Installment Amount.\"",
        "  cFinalDateTooLate :\u003d \"WARNING: The date you selected may be too late based on how much the\";",
        "                        + \" defendant is paying each month.;;\"+;",
        "                       \"Consider making the Final Date earlier or decreasing the Installment Amount.\"",
        "  // The following code checks to see if there were already payments made on the case, and if there",
        "  //  were, shows the \u0027! !\u0027 icon and adds the already paid amounts to the tooltip.",
        "  cPaymentsAlreadyMade :\u003d \"There has already been a payment(s) made on this case:\"",
        "  IIF(nChargeAlreadyPaid\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Charges: $\"+Var2Char(nChargeAlreadyPaid))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Scoff:   $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOF:     $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";DNA:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOFV:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]))",
        "",
        "  // Called from the Final Date Popup, asking the user if they want the date automatically calulated."
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 175592",
    "offset": 175592,
    "line": 5461,
    "column": 52,
    "evidence": {
      "startLine": 5451,
      "endLine": 5471,
      "focusLine": 5461,
      "lines": [
        "  // Let the user know the Final Date they chose may be too soon.",
        "  cFinalDateTooSoon :\u003d \"WARNING: The date you selected may be too soon to allow the defendant\";",
        "                        + \" to fully pay.;;\"+;",
        "                       \"Consider making the Final Date later or increasing the Installment Amount.\"",
        "  cFinalDateTooLate :\u003d \"WARNING: The date you selected may be too late based on how much the\";",
        "                        + \" defendant is paying each month.;;\"+;",
        "                       \"Consider making the Final Date earlier or decreasing the Installment Amount.\"",
        "  // The following code checks to see if there were already payments made on the case, and if there",
        "  //  were, shows the \u0027! !\u0027 icon and adds the already paid amounts to the tooltip.",
        "  cPaymentsAlreadyMade :\u003d \"There has already been a payment(s) made on this case:\"",
        "  IIF(nChargeAlreadyPaid\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Charges: $\"+Var2Char(nChargeAlreadyPaid))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Scoff:   $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOF:     $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";DNA:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOFV:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]))",
        "",
        "  // Called from the Final Date Popup, asking the user if they want the date automatically calulated."
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 175592",
    "offset": 175592,
    "line": 5461,
    "column": 52,
    "evidence": {
      "startLine": 5451,
      "endLine": 5471,
      "focusLine": 5461,
      "lines": [
        "  // Let the user know the Final Date they chose may be too soon.",
        "  cFinalDateTooSoon :\u003d \"WARNING: The date you selected may be too soon to allow the defendant\";",
        "                        + \" to fully pay.;;\"+;",
        "                       \"Consider making the Final Date later or increasing the Installment Amount.\"",
        "  cFinalDateTooLate :\u003d \"WARNING: The date you selected may be too late based on how much the\";",
        "                        + \" defendant is paying each month.;;\"+;",
        "                       \"Consider making the Final Date earlier or decreasing the Installment Amount.\"",
        "  // The following code checks to see if there were already payments made on the case, and if there",
        "  //  were, shows the \u0027! !\u0027 icon and adds the already paid amounts to the tooltip.",
        "  cPaymentsAlreadyMade :\u003d \"There has already been a payment(s) made on this case:\"",
        "  IIF(nChargeAlreadyPaid\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Charges: $\"+Var2Char(nChargeAlreadyPaid))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Scoff:   $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOF:     $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";DNA:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOFV:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]))",
        "",
        "  // Called from the Final Date Popup, asking the user if they want the date automatically calulated."
      ]
    }
  },
  {
    "message": "Unexpected token RPAREN at 175634",
    "offset": 175634,
    "line": 5461,
    "column": 94,
    "evidence": {
      "startLine": 5451,
      "endLine": 5471,
      "focusLine": 5461,
      "lines": [
        "  // Let the user know the Final Date they chose may be too soon.",
        "  cFinalDateTooSoon :\u003d \"WARNING: The date you selected may be too soon to allow the defendant\";",
        "                        + \" to fully pay.;;\"+;",
        "                       \"Consider making the Final Date later or increasing the Installment Amount.\"",
        "  cFinalDateTooLate :\u003d \"WARNING: The date you selected may be too late based on how much the\";",
        "                        + \" defendant is paying each month.;;\"+;",
        "                       \"Consider making the Final Date earlier or decreasing the Installment Amount.\"",
        "  // The following code checks to see if there were already payments made on the case, and if there",
        "  //  were, shows the \u0027! !\u0027 icon and adds the already paid amounts to the tooltip.",
        "  cPaymentsAlreadyMade :\u003d \"There has already been a payment(s) made on this case:\"",
        "  IIF(nChargeAlreadyPaid\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Charges: $\"+Var2Char(nChargeAlreadyPaid))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";Scoff:   $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOF:     $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";DNA:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID]))",
        "  IIF(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]\u003d\u003d0,,cPaymentsAlreadyMade+\u003d\";SOFV:    $\"+;",
        "                                      Var2Char(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID]))",
        "",
        "  // Called from the Final Date Popup, asking the user if they want the date automatically calulated."
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 182066",
    "offset": 182066,
    "line": 5547,
    "column": 3,
    "evidence": {
      "startLine": 5537,
      "endLine": 5557,
      "focusLine": 5547,
      "lines": [
        "  // Called when the user clicks the button to remove the Payment Plan from a case.",
        "  bConfirmDelete :\u003d {|x| x :\u003d Alert_Box(/*oOwner*/,;",
        "                    \"*R*Are you sure you want REMOVE the Payment Plan from this case?\",;",
        "                    {\" YES \",\" NO \"},0,\"REMOVE PAYMENT PLAN\",/*timeout*/,/*esc_default*/,;",
        "                    /*aLOpt_array*/,/*lProgress*/,/*cPlayWave*/,/*lPacify*/,/*cFont*/,/*cButtonFont*/)}",
        "                    ",
        "  // Start of the Tooltip for when the court has default State Fees that are not being used on this case.",
        "  IF aSFPPB_Booleans[lSFPPB_SFD]",
        "    cNotDefaultMessage :\u003d cNotDefaultTooltip :\u003d;",
        "      \"This case is NOT using default State Fee values set for this court.\"",
        "  ELSE",
        "    cNotDefaultMessage :\u003d cNotDefaultTooltip :\u003d;",
        "      \"The case was previously marked to avoid using the set default values.\"",
        "",
        "  ENDIF",
        "  ",
        "  // The following code blocks check to see if the State Fee values in the GET boxes are what they should",
        "  //  be if the court has default State Fees turned on.  For every State Fee that is set to a non default",
        "  //  number, it is added to the tooltip of the Not Using State Fee Defaults SAY object on the screen.",
        "  bCheckScoffDefault :\u003d {|| (nScoffFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE];"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 182116",
    "offset": 182116,
    "line": 5548,
    "column": 46,
    "evidence": {
      "startLine": 5538,
      "endLine": 5558,
      "focusLine": 5548,
      "lines": [
        "  bConfirmDelete :\u003d {|x| x :\u003d Alert_Box(/*oOwner*/,;",
        "                    \"*R*Are you sure you want REMOVE the Payment Plan from this case?\",;",
        "                    {\" YES \",\" NO \"},0,\"REMOVE PAYMENT PLAN\",/*timeout*/,/*esc_default*/,;",
        "                    /*aLOpt_array*/,/*lProgress*/,/*cPlayWave*/,/*lPacify*/,/*cFont*/,/*cButtonFont*/)}",
        "                    ",
        "  // Start of the Tooltip for when the court has default State Fees that are not being used on this case.",
        "  IF aSFPPB_Booleans[lSFPPB_SFD]",
        "    cNotDefaultMessage :\u003d cNotDefaultTooltip :\u003d;",
        "      \"This case is NOT using default State Fee values set for this court.\"",
        "  ELSE",
        "    cNotDefaultMessage :\u003d cNotDefaultTooltip :\u003d;",
        "      \"The case was previously marked to avoid using the set default values.\"",
        "",
        "  ENDIF",
        "  ",
        "  // The following code blocks check to see if the State Fee values in the GET boxes are what they should",
        "  //  be if the court has default State Fees turned on.  For every State Fee that is set to a non default",
        "  //  number, it is added to the tooltip of the Not Using State Fee Defaults SAY object on the screen.",
        "  bCheckScoffDefault :\u003d {|| (nScoffFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE];",
        "            \u003d\u003d (nScoffFee + aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]);"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 182201",
    "offset": 182201,
    "line": 5551,
    "column": 3,
    "evidence": {
      "startLine": 5541,
      "endLine": 5561,
      "focusLine": 5551,
      "lines": [
        "                    /*aLOpt_array*/,/*lProgress*/,/*cPlayWave*/,/*lPacify*/,/*cFont*/,/*cButtonFont*/)}",
        "                    ",
        "  // Start of the Tooltip for when the court has default State Fees that are not being used on this case.",
        "  IF aSFPPB_Booleans[lSFPPB_SFD]",
        "    cNotDefaultMessage :\u003d cNotDefaultTooltip :\u003d;",
        "      \"This case is NOT using default State Fee values set for this court.\"",
        "  ELSE",
        "    cNotDefaultMessage :\u003d cNotDefaultTooltip :\u003d;",
        "      \"The case was previously marked to avoid using the set default values.\"",
        "",
        "  ENDIF",
        "  ",
        "  // The following code blocks check to see if the State Fee values in the GET boxes are what they should",
        "  //  be if the court has default State Fees turned on.  For every State Fee that is set to a non default",
        "  //  number, it is added to the tooltip of the Not Using State Fee Defaults SAY object on the screen.",
        "  bCheckScoffDefault :\u003d {|| (nScoffFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE];",
        "            \u003d\u003d (nScoffFee + aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID]);",
        "     .OR. IsPartialWaived(aWaivedFFS[nWFS_SCOFF])}",
        "  bCheckSOFDefault :\u003d {|| (nSexOffenderFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_FEE];"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after expression at 183647",
    "offset": 183647,
    "line": 5571,
    "column": 32,
    "evidence": {
      "startLine": 5561,
      "endLine": 5581,
      "focusLine": 5571,
      "lines": [
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_FEE];",
        "            \u003d\u003d (nSexOffenderFee + aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID])}",
        "  bCheckDNADefault :\u003d {|| (nDNARegistryFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_FEE];",
        "            \u003d\u003d (nDNARegistryFee + aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID])}",
        "  bCheckSOVFDefault :\u003d {|| (nSexOffenseVictimFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_FEE];",
        "                                    \u003d\u003d (nSexOffenseVictimFee + aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID])}",
        "  bCheckDefaultStateFees:\u003d;",
        "    {|| IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "          ( cNotDefaultTooltip :\u003d cNotDefaultMessage,;",
        "          IIF(aSFPPB_Booleans[lSFPPB_SFD],;",
        "            ( lUsingDefaultStateFees:\u003d.T.,;",
        "              IIF(EVAL(bCheckScoffDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Scoff: \";",
        "                    + IIF(aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM] \u003c\u003e \"A\",\"(\"+aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM]+\") \",\"\");",
        "                    + Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE]))),;",
        "              IIF(EVAL(bCheckSOFDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Sex Offender Fee: \"+Var2Char(aSFD_SFDefaults[nSFD_SOF]))),;"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 183647",
    "offset": 183647,
    "line": 5571,
    "column": 32,
    "evidence": {
      "startLine": 5561,
      "endLine": 5581,
      "focusLine": 5571,
      "lines": [
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_FEE];",
        "            \u003d\u003d (nSexOffenderFee + aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID])}",
        "  bCheckDNADefault :\u003d {|| (nDNARegistryFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_FEE];",
        "            \u003d\u003d (nDNARegistryFee + aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID])}",
        "  bCheckSOVFDefault :\u003d {|| (nSexOffenseVictimFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_FEE];",
        "                                    \u003d\u003d (nSexOffenseVictimFee + aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID])}",
        "  bCheckDefaultStateFees:\u003d;",
        "    {|| IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "          ( cNotDefaultTooltip :\u003d cNotDefaultMessage,;",
        "          IIF(aSFPPB_Booleans[lSFPPB_SFD],;",
        "            ( lUsingDefaultStateFees:\u003d.T.,;",
        "              IIF(EVAL(bCheckScoffDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Scoff: \";",
        "                    + IIF(aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM] \u003c\u003e \"A\",\"(\"+aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM]+\") \",\"\");",
        "                    + Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE]))),;",
        "              IIF(EVAL(bCheckSOFDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Sex Offender Fee: \"+Var2Char(aSFD_SFDefaults[nSFD_SOF]))),;"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 183647",
    "offset": 183647,
    "line": 5571,
    "column": 32,
    "evidence": {
      "startLine": 5561,
      "endLine": 5581,
      "focusLine": 5571,
      "lines": [
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_FEE];",
        "            \u003d\u003d (nSexOffenderFee + aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID])}",
        "  bCheckDNADefault :\u003d {|| (nDNARegistryFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_FEE];",
        "            \u003d\u003d (nDNARegistryFee + aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID])}",
        "  bCheckSOVFDefault :\u003d {|| (nSexOffenseVictimFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_FEE];",
        "                                    \u003d\u003d (nSexOffenseVictimFee + aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID])}",
        "  bCheckDefaultStateFees:\u003d;",
        "    {|| IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "          ( cNotDefaultTooltip :\u003d cNotDefaultMessage,;",
        "          IIF(aSFPPB_Booleans[lSFPPB_SFD],;",
        "            ( lUsingDefaultStateFees:\u003d.T.,;",
        "              IIF(EVAL(bCheckScoffDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Scoff: \";",
        "                    + IIF(aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM] \u003c\u003e \"A\",\"(\"+aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM]+\") \",\"\");",
        "                    + Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE]))),;",
        "              IIF(EVAL(bCheckSOFDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Sex Offender Fee: \"+Var2Char(aSFD_SFDefaults[nSFD_SOF]))),;"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 183647",
    "offset": 183647,
    "line": 5571,
    "column": 32,
    "evidence": {
      "startLine": 5561,
      "endLine": 5581,
      "focusLine": 5571,
      "lines": [
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_FEE];",
        "            \u003d\u003d (nSexOffenderFee + aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID])}",
        "  bCheckDNADefault :\u003d {|| (nDNARegistryFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_FEE];",
        "            \u003d\u003d (nDNARegistryFee + aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID])}",
        "  bCheckSOVFDefault :\u003d {|| (nSexOffenseVictimFee \u003d\u003d 0 .AND. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID] \u003d\u003d 0);",
        "     .OR. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_FEE];",
        "                                    \u003d\u003d (nSexOffenseVictimFee + aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID])}",
        "  bCheckDefaultStateFees:\u003d;",
        "    {|| IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "          ( cNotDefaultTooltip :\u003d cNotDefaultMessage,;",
        "          IIF(aSFPPB_Booleans[lSFPPB_SFD],;",
        "            ( lUsingDefaultStateFees:\u003d.T.,;",
        "              IIF(EVAL(bCheckScoffDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Scoff: \";",
        "                    + IIF(aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM] \u003c\u003e \"A\",\"(\"+aSFD_SFDefaults[nSFD_SCOFF_CHG_NUM]+\") \",\"\");",
        "                    + Var2Char(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_FEE]))),;",
        "              IIF(EVAL(bCheckSOFDefault),NIL,;",
        "                ( lUsingDefaultStateFees:\u003d.F.,;",
        "                  cNotDefaultTooltip+\u003d\"; Default Sex Offender Fee: \"+Var2Char(aSFD_SFDefaults[nSFD_SOF]))),;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 185405",
    "offset": 185405,
    "line": 5600,
    "column": 5,
    "evidence": {
      "startLine": 5590,
      "endLine": 5610,
      "focusLine": 5600,
      "lines": [
        "          cNotDefaultTooltip :\u003d \"State Fee Defaults are turned off for this court.\"),;",
        "        DC_GetCargo(oSFNotDefault,cNotDefaultTooltip);",
        "    }  ",
        "",
        "  // Set SFs if SFs are indicated and there are defaults.",
        "  IF IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], lUsingDefaultStateFees)",
        "    IF !IsPartialWaived(aWaivedFFS[nWFS_SCOFF]);",
        "        .AND. aSFPPB_Booleans[lSFPPB_SCOFF] .OR. aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_PAID] \u003c\u003e 0",
        "      nScoffFee :\u003d IIF(ValType(aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE]) \u003d\u003d \"N\",;",
        "                     aFPD_SFFeesPaidsDues[nSFD_SCOFF_FEE][nSF_DUE],0)",
        "    ENDIF",
        "    IF aSFPPB_Booleans[lSFPPB_SOF] .OR. aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_PAID] \u003c\u003e 0",
        "      nSexOffenderFee :\u003d IIF(ValType(aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_DUE]) \u003d\u003d \"N\",;",
        "                           aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_DUE],0)",
        "    ENDIF",
        "    IF aSFPPB_Booleans[lSFPPB_DNA] .OR. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID] \u003c\u003e 0",
        "      nDNARegistryFee :\u003d IIF(ValType(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_DUE]) \u003d\u003d \"N\",;",
        "                           aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_DUE],0)",
        "    ENDIF",
        "    IF aSFPPB_Booleans[lSFPPB_SOVF] .OR. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID] \u003c\u003e 0",
        "      nSexOffenseVictimFee :\u003d IIF(ValType(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_DUE]) \u003d\u003d \"N\",;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 186186",
    "offset": 186186,
    "line": 5613,
    "column": 3,
    "evidence": {
      "startLine": 5603,
      "endLine": 5623,
      "focusLine": 5613,
      "lines": [
        "                           aFPD_SFFeesPaidsDues[nSFD_SOF][nSF_DUE],0)",
        "    ENDIF",
        "    IF aSFPPB_Booleans[lSFPPB_DNA] .OR. aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_PAID] \u003c\u003e 0",
        "      nDNARegistryFee :\u003d IIF(ValType(aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_DUE]) \u003d\u003d \"N\",;",
        "                           aFPD_SFFeesPaidsDues[nSFD_DNA][nSF_DUE],0)",
        "    ENDIF",
        "    IF aSFPPB_Booleans[lSFPPB_SOVF] .OR. aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_PAID] \u003c\u003e 0",
        "      nSexOffenseVictimFee :\u003d IIF(ValType(aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_DUE]) \u003d\u003d \"N\",;",
        "                                aFPD_SFFeesPaidsDues[nSFD_SOVF][nSF_DUE],0)",
        "    ENDIF",
        "  ENDIF",
        "  ",
        "  DC_GetValidBlock(.T.)",
        "  ",
        "  //Payment Plan Dialog",
        "  SEIStdDialog oPPDlg ; ",
        "          TITLE \"Payment Plan Setup\" ;",
        "          SIZE {720,440} ;",
        "          STOREGETLIST GetList ;",
        "          NOWINMENU  ;",
        "          MODAL"
      ]
    }
  },
  {
    "message": "Unexpected token GET at 186605",
    "offset": 186605,
    "line": 5629,
    "column": 36,
    "evidence": {
      "startLine": 5619,
      "endLine": 5639,
      "focusLine": 5629,
      "lines": [
        "          TITLE \"Payment Plan Setup\" ;",
        "          SIZE {720,440} ;",
        "          STOREGETLIST GetList ;",
        "          NOWINMENU  ;",
        "          MODAL",
        "          ",
        "  // Add the case and defendant name.",
        "  @  0, 4 DCSAY \"Case #: \" + Left(cINDNO, At(\u0027.\u0027,cINDNO)-1) + \" - \" + aName[cnFLName];  ",
        "            SAYSIZE 0",
        "",
        "  @  1, 4 DCSAY \"Total money due:\" GET nTotalDueWithStateFees ;",
        "            SAYSIZE 0 ;",
        "            SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT ;",
        "            GETCOLOR GRA_CLR_WHITE,GRA_CLR_BLACK ;",
        "            SAYFONT FONT_STYLE_BOLD NOTABSTOP;",
        "            GETPOS 1,22 PICT \"999999.99\" EDITPROTECT bEditProtect",
        "            ",
        "  @  1,34 DCSAY \"! !\" SAYCOLOR GRA_CLR_RED,XBPSYSCLR_TRANSPARENT ;",
        "            SAYTOOLTIP cPaymentsAlreadyMade SAYFONT FONT_STYLE_BOLD;",
        "            HIDE {|| nTotalAlreadyPaid \u003d\u003d 0}",
        "            "
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 195986",
    "offset": 195986,
    "line": 5815,
    "column": 5,
    "evidence": {
      "startLine": 5805,
      "endLine": 5825,
      "focusLine": 5815,
      "lines": [
        "      obj:insert(NIL,chr(13) + chr(10))",
        "    obj:insert(NIL,IIF(aSFPPB_Booleans[lSFPPB_PAYPLAN],\"Amended \",\"\") + \"Payment Plan:\")",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "    obj:insert(NIL,\"Total Due:              \" + CashTrim(nTotalDueWithStateFees, .T.))",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "    obj:insert(NIL,\"Due From Charges:       \" + CashTrim(nAmtDue, .T.))",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "    IF nScoffFee \u003e 0",
        "      obj:insert(NIL,\"Scoff Lift Fee:         \" + CashTrim(nScoffFee, .T.))",
        "        obj:insert(NIL,chr(13) + chr(10))",
        "    ENDIF",
        "    IF nSexOffenderFee \u003e 0",
        "      obj:insert(NIL,\"Sex Offender Fee:       \" + CashTrim(nSexOffenderFee, .T.))",
        "        obj:insert(NIL,chr(13) + chr(10))",
        "    ENDIF",
        "    IF nDNARegistryFee \u003e 0",
        "      obj:insert(NIL,\"DNA Fee:                \" + CashTrim(nDNARegistryFee, .T.))",
        "        obj:insert(NIL,chr(13) + chr(10))",
        "    ENDIF",
        "    IF nSexOffenseVictimFee \u003e 0",
        "      obj:insert(NIL,\"Sex Offense Victim Fee: \" + CashTrim(nSexOffenseVictimFee, .T.))"
      ]
    }
  },
  {
    "message": "Unexpected ELSEIF at 197933",
    "offset": 197933,
    "line": 5858,
    "column": 3,
    "evidence": {
      "startLine": 5848,
      "endLine": 5868,
      "focusLine": 5858,
      "lines": [
        "      // Array to pass to Payment Plan letter.",
        "      aPaymentPlanDialogValues :\u003d {dFirstPaymentDate,;",
        "                                   nInstallmentAmount,;",
        "                                   dFinalDate,;",
        "                                   nTotalDueWithStateFees}",
        "      WarnJudge(aChg[ccJudge])",
        "      oLetterThread:\u003dDataThread():new()",
        "      Sleep(5)",
        "      oLetterThread:start( \"Letters\",NIL,axLocals,,,aPaymentPlanDialogValues,,,\"HIDE\")",
        "    ENDIF",
        "  ELSEIF lRemove // Remove the payment plan and update the Notes to reflect that.",
        "    cSFAndPPIndicator :\u003d SetSFAndPPBits({;",
        "                      aSFPPB_Booleans[lSFPPB_SCOFF],;",
        "                      aSFPPB_Booleans[lSFPPB_SOF],;",
        "                      aSFPPB_Booleans[lSFPPB_DNA],;",
        "                      aSFPPB_Booleans[lSFPPB_SOVF],;",
        "                      IIF(Eval(bIsThereAtLeastOneSF),;",
        "                        aSFPPB_Booleans[lSFPPB_SFD],;",
        "                        .F.),;",
        "                      aSFPPB_Booleans[lSFPPB_WAIVED1],;",
        "                      aSFPPB_Booleans[lSFPPB_WAIVED2],;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 199147",
    "offset": 199147,
    "line": 5882,
    "column": 3,
    "evidence": {
      "startLine": 5872,
      "endLine": 5892,
      "focusLine": 5882,
      "lines": [
        "    obj:insert(NIL,\"------------------------------------------------------------------\")",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "    obj:insert(NIL,\"The existing Payment Plan was removed from the case.\")",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "    obj:insert(NIL,Dtoc(date()) + \" - \" + cuTypistCode)",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "    obj:insert(NIL,\"------------------------------------------------------------------\")",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "  ENDIF",
        "  ",
        "  IF lOK .OR. lRemove // Add the new information to the Notes and the PP information to Charges.",
        "    // Update the Notes DBF pointer to have the new text added to the object.",
        "    ccdNotes :\u003d obj:getData()",
        "    ",
        "    // Update all charges and current charge on the case with the Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags]:\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Only save case data if the calling screen is not going to do it itself, like _AdjDisp.",
        "    IF p_lPersistPP // Save data."
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 199486",
    "offset": 199486,
    "line": 5889,
    "column": 36,
    "evidence": {
      "startLine": 5879,
      "endLine": 5899,
      "focusLine": 5889,
      "lines": [
        "    obj:insert(NIL,\"------------------------------------------------------------------\")",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "  ENDIF",
        "  ",
        "  IF lOK .OR. lRemove // Add the new information to the Notes and the PP information to Charges.",
        "    // Update the Notes DBF pointer to have the new text added to the object.",
        "    ccdNotes :\u003d obj:getData()",
        "    ",
        "    // Update all charges and current charge on the case with the Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags]:\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Only save case data if the calling screen is not going to do it itself, like _AdjDisp.",
        "    IF p_lPersistPP // Save data.",
        "      PutNote(aCrtDay,aFilePos[3]) // Can persist the note now, but only because ccdNotes was updated.",
        "      PutCharge(@aCharge)",
        "    ELSE // Let the calling screen know changes need to be saved.",
        "      lRetPersisted :\u003d .F. // Let the calling screen know data needs saving.",
        "    ENDIF",
        "  ENDIF",
        ""
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 199486",
    "offset": 199486,
    "line": 5889,
    "column": 36,
    "evidence": {
      "startLine": 5879,
      "endLine": 5899,
      "focusLine": 5889,
      "lines": [
        "    obj:insert(NIL,\"------------------------------------------------------------------\")",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "  ENDIF",
        "  ",
        "  IF lOK .OR. lRemove // Add the new information to the Notes and the PP information to Charges.",
        "    // Update the Notes DBF pointer to have the new text added to the object.",
        "    ccdNotes :\u003d obj:getData()",
        "    ",
        "    // Update all charges and current charge on the case with the Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags]:\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Only save case data if the calling screen is not going to do it itself, like _AdjDisp.",
        "    IF p_lPersistPP // Save data.",
        "      PutNote(aCrtDay,aFilePos[3]) // Can persist the note now, but only because ccdNotes was updated.",
        "      PutCharge(@aCharge)",
        "    ELSE // Let the calling screen know changes need to be saved.",
        "      lRetPersisted :\u003d .F. // Let the calling screen know data needs saving.",
        "    ENDIF",
        "  ENDIF",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 199486",
    "offset": 199486,
    "line": 5889,
    "column": 36,
    "evidence": {
      "startLine": 5879,
      "endLine": 5899,
      "focusLine": 5889,
      "lines": [
        "    obj:insert(NIL,\"------------------------------------------------------------------\")",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "      obj:insert(NIL,chr(13) + chr(10))",
        "  ENDIF",
        "  ",
        "  IF lOK .OR. lRemove // Add the new information to the Notes and the PP information to Charges.",
        "    // Update the Notes DBF pointer to have the new text added to the object.",
        "    ccdNotes :\u003d obj:getData()",
        "    ",
        "    // Update all charges and current charge on the case with the Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags]:\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Only save case data if the calling screen is not going to do it itself, like _AdjDisp.",
        "    IF p_lPersistPP // Save data.",
        "      PutNote(aCrtDay,aFilePos[3]) // Can persist the note now, but only because ccdNotes was updated.",
        "      PutCharge(@aCharge)",
        "    ELSE // Let the calling screen know changes need to be saved.",
        "      lRetPersisted :\u003d .F. // Let the calling screen know data needs saving.",
        "    ENDIF",
        "  ENDIF",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 200032",
    "offset": 200032,
    "line": 5898,
    "column": 3,
    "evidence": {
      "startLine": 5888,
      "endLine": 5908,
      "focusLine": 5898,
      "lines": [
        "    // Update all charges and current charge on the case with the Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags]:\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Only save case data if the calling screen is not going to do it itself, like _AdjDisp.",
        "    IF p_lPersistPP // Save data.",
        "      PutNote(aCrtDay,aFilePos[3]) // Can persist the note now, but only because ccdNotes was updated.",
        "      PutCharge(@aCharge)",
        "    ELSE // Let the calling screen know changes need to be saved.",
        "      lRetPersisted :\u003d .F. // Let the calling screen know data needs saving.",
        "    ENDIF",
        "  ENDIF",
        "",
        "  GetList:\u003d{}",
        "  oPPDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oPPDlg )",
        "  oPPDlg :\u003d NIL",
        "",
        "RETURN lRetPersisted",
        "//EOF PaymentPlanNotes",
        "",
        "// The Dialog Handler for the Partial Payment dialog."
      ]
    }
  },
  {
    "message": "Expected identifier after LOCAL at 200294",
    "offset": 200294,
    "line": 5910,
    "column": 8,
    "evidence": {
      "startLine": 5900,
      "endLine": 5920,
      "focusLine": 5910,
      "lines": [
        "  GetList:\u003d{}",
        "  oPPDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oPPDlg )",
        "  oPPDlg :\u003d NIL",
        "",
        "RETURN lRetPersisted",
        "//EOF PaymentPlanNotes",
        "",
        "// The Dialog Handler for the Partial Payment dialog.",
        "//-----------------------------------------------",
        "STATIC FUNCTION PPDlgDlgHandler( nEvent, mp1, mp2, oXbp, oDlg, aGetList, aRef, lOk )",
        "LOCAL retVal:\u003dDCGUI_NONE",
        "  IF nEvent \u003d xbeP_Keyboard  // The date functions are fine, but UserClipBoard will break the CRP",
        "    IF mp1 \u003c\u003e xbeK_F8",
        "      DatePlusMinus(mp1, oXbp, aGetList)",
        "    ENDIF",
        "    ",
        "  ENDIF",
        "RETURN retVal",
        "// EOF PPDlgDlgHandler",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token LBRACKET at 207309",
    "offset": 207309,
    "line": 6081,
    "column": 23,
    "evidence": {
      "startLine": 6071,
      "endLine": 6091,
      "focusLine": 6081,
      "lines": [
        "    ENDIF",
        "  NEXT",
        "RETURN chr(nSFAndPPFlag)",
        "// EOF SetSFAndPPBits",
        "",
        "// Converts the State Fee and Payment Plan Indicator into an array of booleans.",
        "// p_cSFAndPPIndicator: The CHARGES-\u003eFLAGS[3] State Fee and Payment Plan Indicator",
        "// RETURNS an array[8] where each value is the bit value of p_cSFAndPPIndicator",
        "//  Array values match: SetSFAndPPBits()",
        "FUNCTION GetSFAndPPBits(p_cSFAndPPIndicator)",
        "LOCAL aSFAndPPBooleans[8], nSFAndPPIndicator",
        "  // For older data where FLAGS characters are initialized to chr(32) (space) and not chr(0).",
        "  IF ValType(p_cSFAndPPIndicator) \u003c\u003e \u0027C\u0027",
        "    p_cSFAndPPIndicator :\u003d chr(0)",
        "  ENDIF",
        "  nSFAndPPIndicator :\u003d asc(p_cSFAndPPIndicator)",
        "  FOR b2b:\u003d1 TO len(aSFAndPPBooleans)",
        "    aSFAndPPBooleans[b2b] :\u003d IsBit(nSFAndPPIndicator,b2b)",
        "  NEXT",
        "RETURN aSFAndPPBooleans",
        "// EOF GetSFAndPPBits"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 207503",
    "offset": 207503,
    "line": 6085,
    "column": 3,
    "evidence": {
      "startLine": 6075,
      "endLine": 6095,
      "focusLine": 6085,
      "lines": [
        "",
        "// Converts the State Fee and Payment Plan Indicator into an array of booleans.",
        "// p_cSFAndPPIndicator: The CHARGES-\u003eFLAGS[3] State Fee and Payment Plan Indicator",
        "// RETURNS an array[8] where each value is the bit value of p_cSFAndPPIndicator",
        "//  Array values match: SetSFAndPPBits()",
        "FUNCTION GetSFAndPPBits(p_cSFAndPPIndicator)",
        "LOCAL aSFAndPPBooleans[8], nSFAndPPIndicator",
        "  // For older data where FLAGS characters are initialized to chr(32) (space) and not chr(0).",
        "  IF ValType(p_cSFAndPPIndicator) \u003c\u003e \u0027C\u0027",
        "    p_cSFAndPPIndicator :\u003d chr(0)",
        "  ENDIF",
        "  nSFAndPPIndicator :\u003d asc(p_cSFAndPPIndicator)",
        "  FOR b2b:\u003d1 TO len(aSFAndPPBooleans)",
        "    aSFAndPPBooleans[b2b] :\u003d IsBit(nSFAndPPIndicator,b2b)",
        "  NEXT",
        "RETURN aSFAndPPBooleans",
        "// EOF GetSFAndPPBits",
        "",
        "//",
        "// Used to initialize the bDisplayPPCurrentStatusDlg code block.  ",
        "//  This code block is used to display the Payment Plan indicator screen."
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 208381",
    "offset": 208381,
    "line": 6105,
    "column": 70,
    "evidence": {
      "startLine": 6095,
      "endLine": 6115,
      "focusLine": 6105,
      "lines": [
        "//  This code block is used to display the Payment Plan indicator screen.",
        "// pr_bDisplayPPCurrentStatusDlg - The code block to initialize.",
        "PROCEDURE InitializePPIndicatorCodeBlocks(pr_bDisplayPPCurrentStatusDlg)",
        "LOCAL bDisplayPPCurrentStatus",
        "",
        "// bDisplayPPCurrentStatus is code block which creates the AlertBox to display",
        "//          the Payment Plan Status. ",
        "//          Displays text in cPPCurrentDisplayStatus which is populated in the",
        "//          pr_bDisplayPPCurrentStatusDlg code block.",
        "//     Code block returns 1\u003dOK or 2\u003dPRINT",
        "bDisplayPPCurrentStatus :\u003d {|axLocals, cPPCurrentDisplayStatus, x| x :\u003d Alert_Box(/*oOwner*/,;",
        "          cPPCurrentDisplayStatus,{\" OK \",\" PRINT \"},0,\"Payment Plan Information\",;",
        "          /*timeout*/,/*esc_default*/,/*aLOpt_array*/,/*lProgress*/,;",
        "          /*cPlayWave*/,/*lPacify*/,/*cFont*/,/*cButtonFont*/,.F.), x}",
        "",
        "// Set the code block passed in to do the following:",
        "//    Populate cPPCurrentDisplayStatus, execute the bDisplayPPCurrentStatus code block",
        "//    and either print or exit depending on the bDisplayPPCurrentStatus return value ",
        "pr_bDisplayPPCurrentStatusDlg :\u003d {|o| o:\u003dThread():new(), Sleep(5), o:Start({|axLocals| ;",
        "      cPPCurrentDisplayStatus :\u003d GetPPCurrentStatusDisplay(axLocals,.F.),;",
        "        IIF(Eval(bDisplayPPCurrentStatus, axLocals, cPPCurrentDisplayStatus) \u003d\u003d 2,;"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 208381",
    "offset": 208381,
    "line": 6105,
    "column": 70,
    "evidence": {
      "startLine": 6095,
      "endLine": 6115,
      "focusLine": 6105,
      "lines": [
        "//  This code block is used to display the Payment Plan indicator screen.",
        "// pr_bDisplayPPCurrentStatusDlg - The code block to initialize.",
        "PROCEDURE InitializePPIndicatorCodeBlocks(pr_bDisplayPPCurrentStatusDlg)",
        "LOCAL bDisplayPPCurrentStatus",
        "",
        "// bDisplayPPCurrentStatus is code block which creates the AlertBox to display",
        "//          the Payment Plan Status. ",
        "//          Displays text in cPPCurrentDisplayStatus which is populated in the",
        "//          pr_bDisplayPPCurrentStatusDlg code block.",
        "//     Code block returns 1\u003dOK or 2\u003dPRINT",
        "bDisplayPPCurrentStatus :\u003d {|axLocals, cPPCurrentDisplayStatus, x| x :\u003d Alert_Box(/*oOwner*/,;",
        "          cPPCurrentDisplayStatus,{\" OK \",\" PRINT \"},0,\"Payment Plan Information\",;",
        "          /*timeout*/,/*esc_default*/,/*aLOpt_array*/,/*lProgress*/,;",
        "          /*cPlayWave*/,/*lPacify*/,/*cFont*/,/*cButtonFont*/,.F.), x}",
        "",
        "// Set the code block passed in to do the following:",
        "//    Populate cPPCurrentDisplayStatus, execute the bDisplayPPCurrentStatus code block",
        "//    and either print or exit depending on the bDisplayPPCurrentStatus return value ",
        "pr_bDisplayPPCurrentStatusDlg :\u003d {|o| o:\u003dThread():new(), Sleep(5), o:Start({|axLocals| ;",
        "      cPPCurrentDisplayStatus :\u003d GetPPCurrentStatusDisplay(axLocals,.F.),;",
        "        IIF(Eval(bDisplayPPCurrentStatus, axLocals, cPPCurrentDisplayStatus) \u003d\u003d 2,;"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 211527",
    "offset": 211527,
    "line": 6159,
    "column": 7,
    "evidence": {
      "startLine": 6149,
      "endLine": 6169,
      "focusLine": 6159,
      "lines": [
        "        ",
        "    FOR h:\u003d1 TO Len(aSFDFields)",
        "      // Make an array with each element as a date/value pair.",
        "      cTempArray :\u003d String2Array(IniFile:ReadString(\"STATE_FEE_DEFAULTS\", aSFDFields[h][1],;",
        "                              aSFDFields[h][2]), \u0027|\u0027)",
        "      nTempArrayLen :\u003d Len(cTempArray)",
        "      // Go through each Date/Value pair, separate them, and cast the date string to a date.",
        "      FOR i:\u003d1 TO nTempArrayLen",
        "        cTempArray[i] :\u003d String2Array(cTempArray[i], \u0027~\u0027)",
        "        cTempArray[i][1] :\u003d StoD(cTempArray[i][1])",
        "      NEXT",
        "      // Add the date/value pairs as an element of the aSTATE_FEE_OPTIONS array.",
        "      aAdd(aSTATE_FEE_OPTIONS, aClone(cTempArray))",
        "    NEXT",
        "    ",
        "    // Then add the User Default setting.",
        "    aAdd(aSTATE_FEE_OPTIONS,;",
        "              IniFile:ReadBool(\"STATE_FEE_DEFAULTS\", \"User_Defaults\", lSFD_DEFAULTS_VALUE))",
        "              ",
        "    IniDone(@IniFile)",
        "  ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 211668",
    "offset": 211668,
    "line": 6162,
    "column": 5,
    "evidence": {
      "startLine": 6152,
      "endLine": 6172,
      "focusLine": 6162,
      "lines": [
        "      cTempArray :\u003d String2Array(IniFile:ReadString(\"STATE_FEE_DEFAULTS\", aSFDFields[h][1],;",
        "                              aSFDFields[h][2]), \u0027|\u0027)",
        "      nTempArrayLen :\u003d Len(cTempArray)",
        "      // Go through each Date/Value pair, separate them, and cast the date string to a date.",
        "      FOR i:\u003d1 TO nTempArrayLen",
        "        cTempArray[i] :\u003d String2Array(cTempArray[i], \u0027~\u0027)",
        "        cTempArray[i][1] :\u003d StoD(cTempArray[i][1])",
        "      NEXT",
        "      // Add the date/value pairs as an element of the aSTATE_FEE_OPTIONS array.",
        "      aAdd(aSTATE_FEE_OPTIONS, aClone(cTempArray))",
        "    NEXT",
        "    ",
        "    // Then add the User Default setting.",
        "    aAdd(aSTATE_FEE_OPTIONS,;",
        "              IniFile:ReadBool(\"STATE_FEE_DEFAULTS\", \"User_Defaults\", lSFD_DEFAULTS_VALUE))",
        "              ",
        "    IniDone(@IniFile)",
        "  ENDIF",
        "  aDup(aSTATE_FEE_OPTIONS, @aRet)",
        "RETURN aRet",
        "// EOF GetStateFeeDefaults"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 211881",
    "offset": 211881,
    "line": 6169,
    "column": 3,
    "evidence": {
      "startLine": 6159,
      "endLine": 6179,
      "focusLine": 6169,
      "lines": [
        "      NEXT",
        "      // Add the date/value pairs as an element of the aSTATE_FEE_OPTIONS array.",
        "      aAdd(aSTATE_FEE_OPTIONS, aClone(cTempArray))",
        "    NEXT",
        "    ",
        "    // Then add the User Default setting.",
        "    aAdd(aSTATE_FEE_OPTIONS,;",
        "              IniFile:ReadBool(\"STATE_FEE_DEFAULTS\", \"User_Defaults\", lSFD_DEFAULTS_VALUE))",
        "              ",
        "    IniDone(@IniFile)",
        "  ENDIF",
        "  aDup(aSTATE_FEE_OPTIONS, @aRet)",
        "RETURN aRet",
        "// EOF GetStateFeeDefaults",
        "",
        "// Gets the State Fee Defaults as they were on a specific date.",
        "// This function calls GetStateFeeDefaults() and returns on the values for a certain date.",
        "// If a date value is passed in, the the function will return the value of the State Fees",
        "// as they were on that date.  Otherwise the current value is returned.",
        "// PARAMETERS:",
        "//  p_lDate: The date to use to check the values of the State Fee Defaults for."
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 220118",
    "offset": 220118,
    "line": 6348,
    "column": 17,
    "evidence": {
      "startLine": 6338,
      "endLine": 6358,
      "focusLine": 6348,
      "lines": [
        "DEFAULT p_lIsToolTip TO .F.",
        "",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  GetStateFeesCaseData(axLocals,/*2*/,,,,,,,/*9*/, @aFPD_SFFeesPaidsDues)",
        "  aSFPPB_Booleans :\u003d GetSFAndPPBits(aChg[ccFlags,cCF_SF_PAYPLAN])",
        "  nPaidOnCharges :\u003d nTotFine + nTotFee + nTotCivFee",
        "  lUseDefault :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], aSFPPB_Booleans[lSFPPB_SFD])",
        "  lNoStateFees :\u003d !aSFPPB_Booleans[lSFPPB_SCOFF] .AND. !aSFPPB_Booleans[lSFPPB_SOF] .AND.;",
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 220120",
    "offset": 220120,
    "line": 6348,
    "column": 19,
    "evidence": {
      "startLine": 6338,
      "endLine": 6358,
      "focusLine": 6348,
      "lines": [
        "DEFAULT p_lIsToolTip TO .F.",
        "",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  GetStateFeesCaseData(axLocals,/*2*/,,,,,,,/*9*/, @aFPD_SFFeesPaidsDues)",
        "  aSFPPB_Booleans :\u003d GetSFAndPPBits(aChg[ccFlags,cCF_SF_PAYPLAN])",
        "  nPaidOnCharges :\u003d nTotFine + nTotFee + nTotCivFee",
        "  lUseDefault :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], aSFPPB_Booleans[lSFPPB_SFD])",
        "  lNoStateFees :\u003d !aSFPPB_Booleans[lSFPPB_SCOFF] .AND. !aSFPPB_Booleans[lSFPPB_SOF] .AND.;",
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges"
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 220534",
    "offset": 220534,
    "line": 6354,
    "column": 17,
    "evidence": {
      "startLine": 6344,
      "endLine": 6364,
      "focusLine": 6354,
      "lines": [
        "  lUseDefault :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], aSFPPB_Booleans[lSFPPB_SFD])",
        "  lNoStateFees :\u003d !aSFPPB_Booleans[lSFPPB_SCOFF] .AND. !aSFPPB_Booleans[lSFPPB_SOF] .AND.;",
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 220536",
    "offset": 220536,
    "line": 6354,
    "column": 19,
    "evidence": {
      "startLine": 6344,
      "endLine": 6364,
      "focusLine": 6354,
      "lines": [
        "  lUseDefault :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], aSFPPB_Booleans[lSFPPB_SFD])",
        "  lNoStateFees :\u003d !aSFPPB_Booleans[lSFPPB_SCOFF] .AND. !aSFPPB_Booleans[lSFPPB_SOF] .AND.;",
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])"
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 220613",
    "offset": 220613,
    "line": 6355,
    "column": 17,
    "evidence": {
      "startLine": 6345,
      "endLine": 6365,
      "focusLine": 6355,
      "lines": [
        "  lNoStateFees :\u003d !aSFPPB_Booleans[lSFPPB_SCOFF] .AND. !aSFPPB_Booleans[lSFPPB_SOF] .AND.;",
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 220615",
    "offset": 220615,
    "line": 6355,
    "column": 19,
    "evidence": {
      "startLine": 6345,
      "endLine": 6365,
      "focusLine": 6355,
      "lines": [
        "  lNoStateFees :\u003d !aSFPPB_Booleans[lSFPPB_SCOFF] .AND. !aSFPPB_Booleans[lSFPPB_SOF] .AND.;",
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]"
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 220690",
    "offset": 220690,
    "line": 6356,
    "column": 17,
    "evidence": {
      "startLine": 6346,
      "endLine": 6366,
      "focusLine": 6356,
      "lines": [
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 220692",
    "offset": 220692,
    "line": 6356,
    "column": 19,
    "evidence": {
      "startLine": 6346,
      "endLine": 6366,
      "focusLine": 6356,
      "lines": [
        "      !aSFPPB_Booleans[lSFPPB_DNA] .AND. !aSFPPB_Booleans[lSFPPB_SOVF]",
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]"
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 220798",
    "offset": 220798,
    "line": 6357,
    "column": 15,
    "evidence": {
      "startLine": 6347,
      "endLine": 6367,
      "focusLine": 6357,
      "lines": [
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]",
        "    cSFText :\u003d aSFIndexes[2]"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 220800",
    "offset": 220800,
    "line": 6357,
    "column": 17,
    "evidence": {
      "startLine": 6347,
      "endLine": 6367,
      "focusLine": 6357,
      "lines": [
        "",
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]",
        "    cSFText :\u003d aSFIndexes[2]"
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 220840",
    "offset": 220840,
    "line": 6358,
    "column": 14,
    "evidence": {
      "startLine": 6348,
      "endLine": 6368,
      "focusLine": 6358,
      "lines": [
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]",
        "    cSFText :\u003d aSFIndexes[2]",
        "    "
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 220842",
    "offset": 220842,
    "line": 6358,
    "column": 16,
    "evidence": {
      "startLine": 6348,
      "endLine": 6368,
      "focusLine": 6358,
      "lines": [
        "  cRetPPStatus +\u003d \"Charges Fines/Fees/Surcharges:\" + IIF(nAmtDue \u003d\u003d 0,;",
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]",
        "    cSFText :\u003d aSFIndexes[2]",
        "    "
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 220869",
    "offset": 220869,
    "line": 6359,
    "column": 13,
    "evidence": {
      "startLine": 6349,
      "endLine": 6369,
      "focusLine": 6359,
      "lines": [
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]",
        "    cSFText :\u003d aSFIndexes[2]",
        "    ",
        "    IF aSFPPB_Booleans[nSFBIndex]"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 220871",
    "offset": 220871,
    "line": 6359,
    "column": 15,
    "evidence": {
      "startLine": 6349,
      "endLine": 6369,
      "focusLine": 6359,
      "lines": [
        "                                                       \" PAID IN FULL\",;",
        "                                                       IIF(nAmtDue \u003c 0,;",
        "                                                         \" PAID IN FULL*\",;",
        "                                                         \"\"));",
        "                                                     + \";\"",
        "  cRetPPStatus +\u003d \"   * Fees: \" + CashTrim(nAmtDue + nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d \"   * Paid to Date: \" + CashTrim(nPaidOnCharges,.T.) + \";\"",
        "  cRetPPStatus +\u003d IIF(nAmtDue \u003c 0 .AND. !p_lIsToolTip,\"*R*\",\"\")+ \"   * Balance Due: \" + CashTrim(nAmtDue,.T.)",
        "  nCaseTotal +\u003d (nAmtDue + nPaidOnCharges)",
        "  nCasePaid +\u003d nPaidOnCharges",
        "  nCaseDue +\u003d nAmtDue",
        "  ",
        "  // State Fee Info",
        "  aSFToGet :\u003d {nSFD_SCOFF_FEE, nSFD_SOF, nSFD_DNA, nSFD_SOVF}",
        "  FOR i:\u003d1 TO Len(aSFToGet)",
        "    aSFIndexes :\u003d GetStateFeeIndexes(aSFToGet[i])",
        "    nSFIndex :\u003d aSFToGet[i]",
        "    nSFBIndex :\u003d aSFIndexes[1]",
        "    cSFText :\u003d aSFIndexes[2]",
        "    ",
        "    IF aSFPPB_Booleans[nSFBIndex]"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 228067",
    "offset": 228067,
    "line": 6515,
    "column": 38,
    "evidence": {
      "startLine": 6505,
      "endLine": 6525,
      "focusLine": 6515,
      "lines": [
        "      bSFInfoPixelHeightAndText, bAnyStateFeesOn, bCancelCode, bIsScreenValid,;",
        "      bUpdateScreen, nSFInfoHeightPixel, bUsingLine,;",
        "      lDefaultPermission:\u003d(GetLevel(84)\u003c\u003e\"D\" .OR. isSpecial()),;",
        "      nSayObjectMaxSize:\u003d20, aSayObjectList:\u003dArray(nSayObjectMaxSize), aCenterPosition,;",
        "      cPPMessage:\u003dArray(3), cPPMessage2, aCaseScoffalawedsDesc, cNoScofflawedMessage,;",
        "      cNoScoffsMessage, nNumScoffCharges:\u003d0, aFPD_SFFeesPaidsDues, DNA_Eligible:\u003dNIL",
        "PRIVATE lSLFCapExists:\u003d.F.",
        "",
        "  // Initialize checkbox values and record their original value.",
        "  aSFPPB_Booleans :\u003d GetSFAndPPBits(aChg[ccFlags,cCF_SF_PAYPLAN])",
        "  lScoff :\u003d aOldValues[lSFPPB_SCOFF] :\u003d aSFPPB_Booleans[lSFPPB_SCOFF]",
        "  lSOF :\u003d aOldValues[lSFPPB_SOF] :\u003d aSFPPB_Booleans[lSFPPB_SOF]",
        "  lDNA :\u003d aOldValues[lSFPPB_DNA] :\u003d aSFPPB_Booleans[lSFPPB_DNA]",
        "  lSOVF :\u003d aOldValues[lSFPPB_SOVF] :\u003d aSFPPB_Booleans[lSFPPB_SOVF]",
        "  aSFD_SFDefaults :\u003d GetStateFeeDefaultsForDate(aCharge[1][dcCrimeDate])",
        "  lSFDefaults :\u003d .F.",
        "  aOldValues[lSFPPB_SFD] :\u003d aSFD_SFDefaults[nSFD_INDICATOR]",
        "  cNoSFMessage :\u003d \"State Fees is set to \u0027Yes\u0027, but there are no State Fees selected.;;\";",
        "                    +\"Please select at least one of the State Fees or change State Fees to \u0027No\u0027.;\"",
        "  cNoScofflawedMessage :\u003d \"There are currently no SCOFFLAWEDs in the Case History.\";",
        "    + \";A Scoff Lift Fee cannot be added to the case unless there is at least one SCOFFLAWED\";"
      ]
    }
  },
  {
    "message": "Unexpected ELSEIF at 235737",
    "offset": 235737,
    "line": 6638,
    "column": 3,
    "evidence": {
      "startLine": 6628,
      "endLine": 6648,
      "focusLine": 6638,
      "lines": [
        "          oSFDlg:drawingArea:show();",
        "                     }",
        "  // Is the starting state Yes, No, or Maybe?",
        "  cCaseSF :\u003d aOldValues[nCASEINDEX] :\u003d StateFeeStatus(aSFPPB_Booleans)",
        "  // If the screen is starting on Yes, update the screen accordingly.",
        "  IF cCaseSF \u003d\u003d cSFS_YES",
        "    lSFDefaults :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], aSFPPB_Booleans[lSFPPB_SFD])",
        "    // If the screen is starting on Yes, then we need to record the original value of SFD.",
        "    aOldValues[lSFPPB_SFD] :\u003d aSFPPB_Booleans[lSFPPB_SFD]",
        "    lAllowSFCB :\u003d .T.",
        "  ELSEIF cCaseSF \u003d\u003d cSFS_MAYBE",
        "    lSFDefaults :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], .T.)",
        "  ENDIF",
        "  ",
        "  // Get the initial text to be displayed don the dialog, and calculate the initial size of the",
        "  //  dialog based on that text.",
        "  Eval(bSFInfoPixelHeightAndText)",
        "  ",
        "  // State Fees Dialog",
        "  SEIStdDialog oSFDlg ; ",
        "          TITLE \"State Fee Setup\";"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 235853",
    "offset": 235853,
    "line": 6640,
    "column": 3,
    "evidence": {
      "startLine": 6630,
      "endLine": 6650,
      "focusLine": 6640,
      "lines": [
        "  // Is the starting state Yes, No, or Maybe?",
        "  cCaseSF :\u003d aOldValues[nCASEINDEX] :\u003d StateFeeStatus(aSFPPB_Booleans)",
        "  // If the screen is starting on Yes, update the screen accordingly.",
        "  IF cCaseSF \u003d\u003d cSFS_YES",
        "    lSFDefaults :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], aSFPPB_Booleans[lSFPPB_SFD])",
        "    // If the screen is starting on Yes, then we need to record the original value of SFD.",
        "    aOldValues[lSFPPB_SFD] :\u003d aSFPPB_Booleans[lSFPPB_SFD]",
        "    lAllowSFCB :\u003d .T.",
        "  ELSEIF cCaseSF \u003d\u003d cSFS_MAYBE",
        "    lSFDefaults :\u003d IsCaseUsingDefaultStateFees(aSFD_SFDefaults[nSFD_INDICATOR], .T.)",
        "  ENDIF",
        "  ",
        "  // Get the initial text to be displayed don the dialog, and calculate the initial size of the",
        "  //  dialog based on that text.",
        "  Eval(bSFInfoPixelHeightAndText)",
        "  ",
        "  // State Fees Dialog",
        "  SEIStdDialog oSFDlg ; ",
        "          TITLE \"State Fee Setup\";",
        "          SIZE {330, nDlgBaseHeightPixel+nSFInfoHeightPixel} ;",
        "          STOREGETLIST GetList ;"
      ]
    }
  },
  {
    "message": "Unexpected token \u0027@\u0027 at 236249",
    "offset": 236249,
    "line": 6654,
    "column": 3,
    "evidence": {
      "startLine": 6644,
      "endLine": 6664,
      "focusLine": 6654,
      "lines": [
        "  Eval(bSFInfoPixelHeightAndText)",
        "  ",
        "  // State Fees Dialog",
        "  SEIStdDialog oSFDlg ; ",
        "          TITLE \"State Fee Setup\";",
        "          SIZE {330, nDlgBaseHeightPixel+nSFInfoHeightPixel} ;",
        "          STOREGETLIST GetList ;",
        "          NOWINMENU  ;",
        "          MODAL",
        "",
        "  @  .7, 3.5 DCSAY \"State Fees:\";",
        "          SAYRIGHT SAYSIZE 0",
        "  @  .5,12.5 DCCOMBOBOX cCaseSF LIST aSFCase SIZE 8,4 ; ",
        "              OBJECT oCaseSF ;",
        "              PRESENTATION GetCboPres()  ; ",
        "              TYPE XBPCOMBO_DROPDOWNLIST ;",
        "              ITEMSELECTED {|| Eval(bYesNoMaybeSelectLogic)} ;",
        "              TOOLTIP \"Are there State Fees on this case?\";",
        "              WHEN {|| !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "          ",
        "  @  1.5, 4 DCCHECKBOX lSFDefaults  SIZE 0 ;"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after expression at 237227",
    "offset": 237227,
    "line": 6672,
    "column": 40,
    "evidence": {
      "startLine": 6662,
      "endLine": 6682,
      "focusLine": 6672,
      "lines": [
        "              WHEN {|| !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "          ",
        "  @  1.5, 4 DCCHECKBOX lSFDefaults  SIZE 0 ;",
        "            PROMPT IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "                     \"Use State Fee Defaults\",;",
        "                     \"State Fee Defaults are turned off\");",
        "            TOOLTIP \"If this is checked, then the case will use the default State Fee values.\";",
        "            WHEN {|| lAllowSFCB .AND. aSFD_SFDefaults[nSFD_INDICATOR] .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| IIF(lDefaultPermission,;",
        "                         Eval(bUpdateScreen),;",
        "                         ( lSFDefaults :\u003d aOldValues[lSFPPB_SFD],;",
        "                           DC_GetRefresh(GetList),;",
        "                           InfoBox(\"You do not have permission to change State Fee Default settings.\",;",
        "                             \"PERMISSION LEVEL\")))} ",
        "  ",
        "  @  2.5, 4 DCCHECKBOX lScoff  SIZE 0 ; ",
        "            PROMPT \"Scoff Lift Fee\" ;",
        "            TOOLTIP \"Check this to indicate that the case has Scoff Lift Fees.\";",
        "            WHEN {|| lAllowSFCB .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| Eval(bUpdateScreen)}",
        "            "
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 237227",
    "offset": 237227,
    "line": 6672,
    "column": 40,
    "evidence": {
      "startLine": 6662,
      "endLine": 6682,
      "focusLine": 6672,
      "lines": [
        "              WHEN {|| !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "          ",
        "  @  1.5, 4 DCCHECKBOX lSFDefaults  SIZE 0 ;",
        "            PROMPT IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "                     \"Use State Fee Defaults\",;",
        "                     \"State Fee Defaults are turned off\");",
        "            TOOLTIP \"If this is checked, then the case will use the default State Fee values.\";",
        "            WHEN {|| lAllowSFCB .AND. aSFD_SFDefaults[nSFD_INDICATOR] .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| IIF(lDefaultPermission,;",
        "                         Eval(bUpdateScreen),;",
        "                         ( lSFDefaults :\u003d aOldValues[lSFPPB_SFD],;",
        "                           DC_GetRefresh(GetList),;",
        "                           InfoBox(\"You do not have permission to change State Fee Default settings.\",;",
        "                             \"PERMISSION LEVEL\")))} ",
        "  ",
        "  @  2.5, 4 DCCHECKBOX lScoff  SIZE 0 ; ",
        "            PROMPT \"Scoff Lift Fee\" ;",
        "            TOOLTIP \"Check this to indicate that the case has Scoff Lift Fees.\";",
        "            WHEN {|| lAllowSFCB .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| Eval(bUpdateScreen)}",
        "            "
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 237227",
    "offset": 237227,
    "line": 6672,
    "column": 40,
    "evidence": {
      "startLine": 6662,
      "endLine": 6682,
      "focusLine": 6672,
      "lines": [
        "              WHEN {|| !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "          ",
        "  @  1.5, 4 DCCHECKBOX lSFDefaults  SIZE 0 ;",
        "            PROMPT IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "                     \"Use State Fee Defaults\",;",
        "                     \"State Fee Defaults are turned off\");",
        "            TOOLTIP \"If this is checked, then the case will use the default State Fee values.\";",
        "            WHEN {|| lAllowSFCB .AND. aSFD_SFDefaults[nSFD_INDICATOR] .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| IIF(lDefaultPermission,;",
        "                         Eval(bUpdateScreen),;",
        "                         ( lSFDefaults :\u003d aOldValues[lSFPPB_SFD],;",
        "                           DC_GetRefresh(GetList),;",
        "                           InfoBox(\"You do not have permission to change State Fee Default settings.\",;",
        "                             \"PERMISSION LEVEL\")))} ",
        "  ",
        "  @  2.5, 4 DCCHECKBOX lScoff  SIZE 0 ; ",
        "            PROMPT \"Scoff Lift Fee\" ;",
        "            TOOLTIP \"Check this to indicate that the case has Scoff Lift Fees.\";",
        "            WHEN {|| lAllowSFCB .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| Eval(bUpdateScreen)}",
        "            "
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 237227",
    "offset": 237227,
    "line": 6672,
    "column": 40,
    "evidence": {
      "startLine": 6662,
      "endLine": 6682,
      "focusLine": 6672,
      "lines": [
        "              WHEN {|| !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "          ",
        "  @  1.5, 4 DCCHECKBOX lSFDefaults  SIZE 0 ;",
        "            PROMPT IIF(aSFD_SFDefaults[nSFD_INDICATOR],;",
        "                     \"Use State Fee Defaults\",;",
        "                     \"State Fee Defaults are turned off\");",
        "            TOOLTIP \"If this is checked, then the case will use the default State Fee values.\";",
        "            WHEN {|| lAllowSFCB .AND. aSFD_SFDefaults[nSFD_INDICATOR] .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| IIF(lDefaultPermission,;",
        "                         Eval(bUpdateScreen),;",
        "                         ( lSFDefaults :\u003d aOldValues[lSFPPB_SFD],;",
        "                           DC_GetRefresh(GetList),;",
        "                           InfoBox(\"You do not have permission to change State Fee Default settings.\",;",
        "                             \"PERMISSION LEVEL\")))} ",
        "  ",
        "  @  2.5, 4 DCCHECKBOX lScoff  SIZE 0 ; ",
        "            PROMPT \"Scoff Lift Fee\" ;",
        "            TOOLTIP \"Check this to indicate that the case has Scoff Lift Fees.\";",
        "            WHEN {|| lAllowSFCB .AND. !aSFPPB_Booleans[lSFPPB_PAYPLAN]};",
        "            ACTION {|| Eval(bUpdateScreen)}",
        "            "
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 239961",
    "offset": 239961,
    "line": 6721,
    "column": 3,
    "evidence": {
      "startLine": 6711,
      "endLine": 6731,
      "focusLine": 6721,
      "lines": [
        "                             \"~\",chr(247)),\"\u0026\",\"\u0026\u0026\"),;",
        "                           \"\")};",
        "                SAYCOLOR {|o| IIF(Eval(bUsingLine, o) .AND. aStateFeeInfo[dc_getcargo(o)][2]\u003d\u003d\"*R*\",;",
        "                                {GRA_CLR_DARKRED, XBPSYSCLR_TRANSPARENT},;",
        "                                {GRA_CLR_BLACK, XBPSYSCLR_TRANSPARENT})};",
        "                HIDE {|o| !Eval(bUsingLine, o)};",
        "                OBJECT aSayObjectList[i];",
        "                SAYSIZE 50, 1;",
        "                SAYLEFT;",
        "                CARGO i",
        "  NEXT",
        " ",
        "  // The OK and Cancel button have special RESIZE code that keeps their positions constant.",
        "  //  Since the screen is built from the bottom left corner (0,0) up, the buttons don\u0027t have to move",
        "  //  up or down when the screen changes size.  They just stay stationary relative to the bottom of ",
        "  //  the screen.",
        "  @  8+(nSFInfoHeight), 5 DCPUSHBUTTON CAPTION \"~OK\" SIZE 8,1.3 ;",
        "            ACCELKEY xbeK_CTRL_O FONT BTN_FONT_B ;",
        "            TOOLTIP \"Update case\u0027s State Fee settings.\" ;",
        "            OBJECT oSFOKButton;",
        "            ACTION {|| IIF(Eval(bIsScreenValid),DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList),NIL)};"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 240339",
    "offset": 240339,
    "line": 6727,
    "column": 60,
    "evidence": {
      "startLine": 6717,
      "endLine": 6737,
      "focusLine": 6727,
      "lines": [
        "                OBJECT aSayObjectList[i];",
        "                SAYSIZE 50, 1;",
        "                SAYLEFT;",
        "                CARGO i",
        "  NEXT",
        " ",
        "  // The OK and Cancel button have special RESIZE code that keeps their positions constant.",
        "  //  Since the screen is built from the bottom left corner (0,0) up, the buttons don\u0027t have to move",
        "  //  up or down when the screen changes size.  They just stay stationary relative to the bottom of ",
        "  //  the screen.",
        "  @  8+(nSFInfoHeight), 5 DCPUSHBUTTON CAPTION \"~OK\" SIZE 8,1.3 ;",
        "            ACCELKEY xbeK_CTRL_O FONT BTN_FONT_B ;",
        "            TOOLTIP \"Update case\u0027s State Fee settings.\" ;",
        "            OBJECT oSFOKButton;",
        "            ACTION {|| IIF(Eval(bIsScreenValid),DC_ReadGuiEvent(DCGUI_EXIT_OK, GetList),NIL)};",
        "            RESIZE {{|x,y,o| {o:currentPos()[1], o:currentPos()[2]}},}",
        "",
        "  @ 8+(nSFInfoHeight), 18.5 DCPUSHBUTTON CAPTION \"~Cancel\" SIZE 8,1.3 ;",
        "            ACCELKEY  xbeK_CTRL_C FONT BTN_FONT_B ;",
        "            TOOLTIP \"Cancel State Fee seetings.\" ;",
        "            ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_ABORT, GetList)};"
      ]
    }
  },
  {
    "message": "Unexpected ELSEIF at 243188",
    "offset": 243188,
    "line": 6776,
    "column": 5,
    "evidence": {
      "startLine": 6766,
      "endLine": 6786,
      "focusLine": 6776,
      "lines": [
        "              DC_GetRefresh(GetList)}",
        "",
        "  // If the screen exited with an \"OK\" code, and there were changes.",
        "  IF lOK .AND. Eval(bTestSFUpdated)",
        "    // Update the CHARGES-\u003eFLAGS character.",
        "    IF cCaseSF \u003d\u003d cSFS_NO",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .T.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1],;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSEIF cCaseSF \u003d\u003d cSFS_YES",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({lScoff, lSOF, lDNA, lSOVF, lSFDefaults,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSE",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .F.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ENDIF",
        "    // Update all charges and the current charge on the case with the State Fee and Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags] :\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 243452",
    "offset": 243452,
    "line": 6780,
    "column": 5,
    "evidence": {
      "startLine": 6770,
      "endLine": 6790,
      "focusLine": 6780,
      "lines": [
        "    // Update the CHARGES-\u003eFLAGS character.",
        "    IF cCaseSF \u003d\u003d cSFS_NO",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .T.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1],;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSEIF cCaseSF \u003d\u003d cSFS_YES",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({lScoff, lSOF, lDNA, lSOVF, lSFDefaults,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSE",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .F.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ENDIF",
        "    // Update all charges and the current charge on the case with the State Fee and Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags] :\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Persist the data.",
        "    PutCharge(@aCharge)",
        "  ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 243679",
    "offset": 243679,
    "line": 6784,
    "column": 5,
    "evidence": {
      "startLine": 6774,
      "endLine": 6794,
      "focusLine": 6784,
      "lines": [
        "                        aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSEIF cCaseSF \u003d\u003d cSFS_YES",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({lScoff, lSOF, lDNA, lSOVF, lSFDefaults,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSE",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .F.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ENDIF",
        "    // Update all charges and the current charge on the case with the State Fee and Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags] :\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Persist the data.",
        "    PutCharge(@aCharge)",
        "  ENDIF",
        "  ",
        "  GetList:\u003d{}",
        "  oSFDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oSFDlg )"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 243824",
    "offset": 243824,
    "line": 6786,
    "column": 37,
    "evidence": {
      "startLine": 6776,
      "endLine": 6796,
      "focusLine": 6786,
      "lines": [
        "    ELSEIF cCaseSF \u003d\u003d cSFS_YES",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({lScoff, lSOF, lDNA, lSOVF, lSFDefaults,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSE",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .F.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ENDIF",
        "    // Update all charges and the current charge on the case with the State Fee and Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags] :\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Persist the data.",
        "    PutCharge(@aCharge)",
        "  ENDIF",
        "  ",
        "  GetList:\u003d{}",
        "  oSFDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oSFDlg )",
        "  oSFDlg :\u003d NIL",
        "  "
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 243824",
    "offset": 243824,
    "line": 6786,
    "column": 37,
    "evidence": {
      "startLine": 6776,
      "endLine": 6796,
      "focusLine": 6786,
      "lines": [
        "    ELSEIF cCaseSF \u003d\u003d cSFS_YES",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({lScoff, lSOF, lDNA, lSOVF, lSFDefaults,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSE",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .F.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ENDIF",
        "    // Update all charges and the current charge on the case with the State Fee and Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags] :\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Persist the data.",
        "    PutCharge(@aCharge)",
        "  ENDIF",
        "  ",
        "  GetList:\u003d{}",
        "  oSFDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oSFDlg )",
        "  oSFDlg :\u003d NIL",
        "  "
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 243824",
    "offset": 243824,
    "line": 6786,
    "column": 37,
    "evidence": {
      "startLine": 6776,
      "endLine": 6796,
      "focusLine": 6786,
      "lines": [
        "    ELSEIF cCaseSF \u003d\u003d cSFS_YES",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({lScoff, lSOF, lDNA, lSOVF, lSFDefaults,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ELSE",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .F.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ENDIF",
        "    // Update all charges and the current charge on the case with the State Fee and Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags] :\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Persist the data.",
        "    PutCharge(@aCharge)",
        "  ENDIF",
        "  ",
        "  GetList:\u003d{}",
        "  oSFDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oSFDlg )",
        "  oSFDlg :\u003d NIL",
        "  "
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 244009",
    "offset": 244009,
    "line": 6790,
    "column": 3,
    "evidence": {
      "startLine": 6780,
      "endLine": 6800,
      "focusLine": 6790,
      "lines": [
        "    ELSE",
        "      cSFAndPPIndicator :\u003d SetSFAndPPBits({.F., .F., .F., .F., .F.,;",
        "                        aSFPPB_Booleans[lSFPPB_WAIVED1], aSFPPB_Booleans[lSFPPB_WAIVED2],;",
        "                        aSFPPB_Booleans[lSFPPB_PAYPLAN]})",
        "    ENDIF",
        "    // Update all charges and the current charge on the case with the State Fee and Payment Plan data.",
        "    AEval(aCharge,{|x,i| x[ccFlags] :\u003d Stuff(x[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)})",
        "    aChg[ccFlags]:\u003d Stuff(aChg[ccFlags],cCF_SF_PAYPLAN,1,cSFAndPPIndicator)",
        "    // Persist the data.",
        "    PutCharge(@aCharge)",
        "  ENDIF",
        "  ",
        "  GetList:\u003d{}",
        "  oSFDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oSFDlg )",
        "  oSFDlg :\u003d NIL",
        "  ",
        "RETURN lOK",
        "// EOF StateFeesDialog",
        "",
        "// Takes in the State Fee and Payment Plan bits for a case, and returns a string value indicating"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 252791",
    "offset": 252791,
    "line": 7004,
    "column": 38,
    "evidence": {
      "startLine": 6994,
      "endLine": 7014,
      "focusLine": 7004,
      "lines": [
        "  IF !Empty(p_cACFilter)",
        "    // Convert the filter to a single length array, if needed.",
        "    IF ValType(p_cACFilter) \u003c\u003e \"A\"",
        "      aACFilterArray :\u003d Array(1)",
        "      aACFilterArray[1] :\u003d p_cACFilter",
        "    ELSE",
        "      aACFilterArray :\u003d p_cACFilter",
        "    ENDIF",
        "    // Convert filter(s) to upper case if ignore p_lIgnoreCase is on.",
        "    IF p_lIgnoreCase",
        "      AEval(aACFilterArray, {|x,i| x :\u003d Upper(x)},,, .T.)",
        "    ENDIF",
        "    ",
        "    aFilteredDays :\u003d Array(0)",
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 252791",
    "offset": 252791,
    "line": 7004,
    "column": 38,
    "evidence": {
      "startLine": 6994,
      "endLine": 7014,
      "focusLine": 7004,
      "lines": [
        "  IF !Empty(p_cACFilter)",
        "    // Convert the filter to a single length array, if needed.",
        "    IF ValType(p_cACFilter) \u003c\u003e \"A\"",
        "      aACFilterArray :\u003d Array(1)",
        "      aACFilterArray[1] :\u003d p_cACFilter",
        "    ELSE",
        "      aACFilterArray :\u003d p_cACFilter",
        "    ENDIF",
        "    // Convert filter(s) to upper case if ignore p_lIgnoreCase is on.",
        "    IF p_lIgnoreCase",
        "      AEval(aACFilterArray, {|x,i| x :\u003d Upper(x)},,, .T.)",
        "    ENDIF",
        "    ",
        "    aFilteredDays :\u003d Array(0)",
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 252791",
    "offset": 252791,
    "line": 7004,
    "column": 38,
    "evidence": {
      "startLine": 6994,
      "endLine": 7014,
      "focusLine": 7004,
      "lines": [
        "  IF !Empty(p_cACFilter)",
        "    // Convert the filter to a single length array, if needed.",
        "    IF ValType(p_cACFilter) \u003c\u003e \"A\"",
        "      aACFilterArray :\u003d Array(1)",
        "      aACFilterArray[1] :\u003d p_cACFilter",
        "    ELSE",
        "      aACFilterArray :\u003d p_cACFilter",
        "    ENDIF",
        "    // Convert filter(s) to upper case if ignore p_lIgnoreCase is on.",
        "    IF p_lIgnoreCase",
        "      AEval(aACFilterArray, {|x,i| x :\u003d Upper(x)},,, .T.)",
        "    ENDIF",
        "    ",
        "    aFilteredDays :\u003d Array(0)",
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 253252",
    "offset": 253252,
    "line": 7014,
    "column": 53,
    "evidence": {
      "startLine": 7004,
      "endLine": 7024,
      "focusLine": 7014,
      "lines": [
        "      AEval(aACFilterArray, {|x,i| x :\u003d Upper(x)},,, .T.)",
        "    ENDIF",
        "    ",
        "    aFilteredDays :\u003d Array(0)",
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;",
        "                                        NIL)})",
        "      IF lMatchFound",
        "        AAdd(aFilteredDays, aAllCourtDays[j])",
        "      ENDIF",
        "    NEXT",
        "  aAllCourtDays :\u003d aFilteredDays",
        "  ENDIF",
        "  ",
        "  IF !Empty(p_cSort)",
        "    IF Upper(p_cSort) \u003d\u003d \"A\""
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 253252",
    "offset": 253252,
    "line": 7014,
    "column": 53,
    "evidence": {
      "startLine": 7004,
      "endLine": 7024,
      "focusLine": 7014,
      "lines": [
        "      AEval(aACFilterArray, {|x,i| x :\u003d Upper(x)},,, .T.)",
        "    ENDIF",
        "    ",
        "    aFilteredDays :\u003d Array(0)",
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;",
        "                                        NIL)})",
        "      IF lMatchFound",
        "        AAdd(aFilteredDays, aAllCourtDays[j])",
        "      ENDIF",
        "    NEXT",
        "  aAllCourtDays :\u003d aFilteredDays",
        "  ENDIF",
        "  ",
        "  IF !Empty(p_cSort)",
        "    IF Upper(p_cSort) \u003d\u003d \"A\""
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 253252",
    "offset": 253252,
    "line": 7014,
    "column": 53,
    "evidence": {
      "startLine": 7004,
      "endLine": 7024,
      "focusLine": 7014,
      "lines": [
        "      AEval(aACFilterArray, {|x,i| x :\u003d Upper(x)},,, .T.)",
        "    ENDIF",
        "    ",
        "    aFilteredDays :\u003d Array(0)",
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;",
        "                                        NIL)})",
        "      IF lMatchFound",
        "        AAdd(aFilteredDays, aAllCourtDays[j])",
        "      ENDIF",
        "    NEXT",
        "  aAllCourtDays :\u003d aFilteredDays",
        "  ENDIF",
        "  ",
        "  IF !Empty(p_cSort)",
        "    IF Upper(p_cSort) \u003d\u003d \"A\""
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 253252",
    "offset": 253252,
    "line": 7014,
    "column": 53,
    "evidence": {
      "startLine": 7004,
      "endLine": 7024,
      "focusLine": 7014,
      "lines": [
        "      AEval(aACFilterArray, {|x,i| x :\u003d Upper(x)},,, .T.)",
        "    ENDIF",
        "    ",
        "    aFilteredDays :\u003d Array(0)",
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;",
        "                                        NIL)})",
        "      IF lMatchFound",
        "        AAdd(aFilteredDays, aAllCourtDays[j])",
        "      ENDIF",
        "    NEXT",
        "  aAllCourtDays :\u003d aFilteredDays",
        "  ENDIF",
        "  ",
        "  IF !Empty(p_cSort)",
        "    IF Upper(p_cSort) \u003d\u003d \"A\""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 253381",
    "offset": 253381,
    "line": 7018,
    "column": 7,
    "evidence": {
      "startLine": 7008,
      "endLine": 7028,
      "focusLine": 7018,
      "lines": [
        "    FOR j :\u003d 1 TO Len(aAllCourtDays)",
        "      lMatchFound :\u003d .F.",
        "      // Check all filters against current Action Code.",
        "      AEval(aACFilterArray, {|x,i| IIF(x $ IIF(p_lIgnoreCase,;",
        "                                                Upper(aAllCourtDays[j][nDAYTEXT]),;",
        "                                                aAllCourtDays[j][nDAYTEXT]),;",
        "                                        lMatchFound :\u003d .T.,;",
        "                                        NIL)})",
        "      IF lMatchFound",
        "        AAdd(aFilteredDays, aAllCourtDays[j])",
        "      ENDIF",
        "    NEXT",
        "  aAllCourtDays :\u003d aFilteredDays",
        "  ENDIF",
        "  ",
        "  IF !Empty(p_cSort)",
        "    IF Upper(p_cSort) \u003d\u003d \"A\"",
        "      aAllCourtDays :\u003d aSort(aAllCourtDays,,,{|aX,aY| aX[nDAYDATE] \u003c aY[nDAYDATE]})",
        "    ELSEIF Upper(p_cSort) \u003d\u003d \"D\"",
        "      aAllCourtDays :\u003d aSort(aAllCourtDays,,,{|aX,aY| aX[nDAYDATE] \u003e aY[nDAYDATE]})",
        "    ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 268380",
    "offset": 268380,
    "line": 7503,
    "column": 24,
    "evidence": {
      "startLine": 7493,
      "endLine": 7513,
      "focusLine": 7503,
      "lines": [
        "tempOCATranPath :\u003d substr(cdxOCATranPath+space(50),1,50)",
        "",
        "lSaveSize  :\u003d Ok2SaveDlgSize()",
        "lSavePos   :\u003d Ok2SaveDlgPos()",
        "lScnReSize :\u003d Ok2Resize()",
        "lSatOK     :\u003d SaturdayOK()",
        "lChkHDay   :\u003d ChkHolidays()",
        "lHDNotify  :\u003d HolidayNotify()",
        "lMultiScn  :\u003d mlMultiScrn",
        "",
        "cJCFPath1 :\u003d cJCFPath2 :\u003d \"\"",
        "",
        "SEIStdDialog oDlg   ;",
        "             TITLE \"SET USER DEFAULTS\" ;",
        "             SIZE {500,400}  ;",
        "             SCREEN 326      ;",
        "             STOREGETLIST GetList ;",
        "             NOWINMENU       ;",
        "             HELPREF CRP_U_UD",
        "",
        "@  1, 2 DCSAY \"Default value for \u0027Cash\u0027:\" GET cdxCash  ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 269657",
    "offset": 269657,
    "line": 7539,
    "column": 1,
    "evidence": {
      "startLine": 7529,
      "endLine": 7549,
      "focusLine": 7539,
      "lines": [
        "",
        "IF GetLevel(1) \u003d \u0027P\u0027 .AND. .F.         // Block it for now, we never used this switch!",
        "  @ 1,28.5 DCSAY \"Allow OCA Data Transfer:\" GET ldxOCAxfer  ;",
        "         GROUP \"xCodes\"  ;",
        "         SAYSIZE 21  ;",
        "         PICTURE \u0027Y\u0027 ;",
        "         GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "         LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "         SAYRIGHTBOTTOM ;",
        "         GETTOOLTIP \"Allow automatic transfer of;case data to OCA\"",
        "ENDIF",
        "",
        "@ 2, 2 DCSAY \"Month for Audit Report:\" ;",
        "        SAYRIGHT SAYSIZE 20",
        "@ 2, 24 DCRADIO cdxRptMnth  ;",
        "  VALUE \u0027P\u0027                 ;",
        "  FONT cStdSayFont        ;",
        "  PROMPT \u0027Previous\u0027         ;",
        "  SIZE 12                   ;",
        "  ACTION {||DC_GetRefresh(GetList) }",
        "@ 2, 40 DCRADIO cdxRptMnth  ;"
      ]
    }
  },
  {
    "message": "Unexpected token GET at 270146",
    "offset": 270146,
    "line": 7556,
    "column": 43,
    "evidence": {
      "startLine": 7546,
      "endLine": 7566,
      "focusLine": 7556,
      "lines": [
        "  PROMPT \u0027Previous\u0027         ;",
        "  SIZE 12                   ;",
        "  ACTION {||DC_GetRefresh(GetList) }",
        "@ 2, 40 DCRADIO cdxRptMnth  ;",
        "  VALUE \u0027C\u0027                 ;",
        "  FONT cStdSayFont        ;",
        "  PROMPT \u0027Current\u0027          ;",
        "  SIZE 12                   ;",
        "  ACTION {||DC_GetRefresh(GetList) }",
        "",
        "@ 3, 2 DCSAY \"Location for Audit Report:\" GET tempACpath  ;",
        "        VALID {|o| FixJCFTran(@tempACpath,GetList), .T. } ;",
        "        SAYRIGHT     ;",
        "        SAYSIZE 20   ;",
        "        GETSIZE 30   ;",
        "        PICTURE \u0027@S25!\u0027 ;",
        "        GETTooltip \"Enter the drive and;path for your Audit Report\"",
        "",
        "@ 4,34.5 DCSAY \"Button Color:\" GET cdxBtnColor  ;",
        "        SAYRIGHT    ;",
        "        SAYSIZE 15  ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 275142",
    "offset": 275142,
    "line": 7676,
    "column": 1,
    "evidence": {
      "startLine": 7666,
      "endLine": 7686,
      "focusLine": 7676,
      "lines": [
        "             GETTOOLTIP \"Helps FTP get past some Firewalls\" ;",
        "             SAYSIZE 10",
        "  @ 10,39.5 DCSAY \"SOAP Setup:\" GET cdxSoapTransport  ;",
        "             PICTURE \u0027#\u0027 ;                                            // Used to set SOAP requests to use",
        "             GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;          //   preconfigured proxy server settings",
        "             LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;         //   or LowLevel Sockets",
        "             SAYRIGHTBOTTOM ;",
        "             VALID {|| cdxSoapTransport$\"012\" } ;",
        "             GETTOOLTIP \"SOAP Transport settings:;0 \u003d Sockets;1 \u003d WinInet;2 \u003d WinHTTP\" ;",
        "             SAYSIZE 10",
        "ENDIF",
        "",
        "@ 10, 2 DCSAY \"Autofill DMV on Dispos:\" GET ldxAutoDMV  ;",
        "            WHEN {||ldxeDispo} ;",
        "            PICTURE \u0027Y\u0027 ;",
        "            GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "            LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "            SAYRIGHTBOTTOM ;",
        "            GETTOOLTIP \"Autofill DMV info;on dispositions.\" ;",
        "            SAYSIZE 20",
        "            "
      ]
    }
  },
  {
    "message": "Unexpected token GET at 275189",
    "offset": 275189,
    "line": 7678,
    "column": 41,
    "evidence": {
      "startLine": 7668,
      "endLine": 7688,
      "focusLine": 7678,
      "lines": [
        "  @ 10,39.5 DCSAY \"SOAP Setup:\" GET cdxSoapTransport  ;",
        "             PICTURE \u0027#\u0027 ;                                            // Used to set SOAP requests to use",
        "             GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;          //   preconfigured proxy server settings",
        "             LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;         //   or LowLevel Sockets",
        "             SAYRIGHTBOTTOM ;",
        "             VALID {|| cdxSoapTransport$\"012\" } ;",
        "             GETTOOLTIP \"SOAP Transport settings:;0 \u003d Sockets;1 \u003d WinInet;2 \u003d WinHTTP\" ;",
        "             SAYSIZE 10",
        "ENDIF",
        "",
        "@ 10, 2 DCSAY \"Autofill DMV on Dispos:\" GET ldxAutoDMV  ;",
        "            WHEN {||ldxeDispo} ;",
        "            PICTURE \u0027Y\u0027 ;",
        "            GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "            LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "            SAYRIGHTBOTTOM ;",
        "            GETTOOLTIP \"Autofill DMV info;on dispositions.\" ;",
        "            SAYSIZE 20",
        "            ",
        "@ 10,27.6 DCSAY \"Preview:\" GET ldxPreview  ;",
        "           PICTURE \u0027Y\u0027 ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 277047",
    "offset": 277047,
    "line": 7720,
    "column": 1,
    "evidence": {
      "startLine": 7710,
      "endLine": 7730,
      "focusLine": 7720,
      "lines": [
        "             SAYSIZE 20",
        "",
        "  @ 12,37.5 DCSAY \"Archive Emails:\" GET cdxEmailIsPrint  ;",
        "             PICTURE \u0027#\u0027 ;",
        "             GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "             LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "             SAYRIGHTBOTTOM ;",
        "             VALID {|| cdxEmailIsPrint$\"012\" } ;",
        "             GETTOOLTIP \"0 \u003d Disable Email Archive;1 \u003d Enable Email Archive;2 \u003d Close Preview after Email\" ;",
        "             SAYSIZE 12",
        "ENDIF",
        "",
        "@ 12, 2 DCSAY \"Enable Screen Resize:\" GET lScnReSize  ;",
        "            PICTURE \u0027Y\u0027 ;",
        "            GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "            LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "            SAYRIGHTBOTTOM ;",
        "            GETTOOLTIP \"Check to enable resizing screens.\" ;",
        "            SAYSIZE 20",
        "",
        "@ 12, 26 DCSAY \"Save Size:\" GET lSaveSize  ;"
      ]
    }
  },
  {
    "message": "Unexpected token GET at 277092",
    "offset": 277092,
    "line": 7722,
    "column": 39,
    "evidence": {
      "startLine": 7712,
      "endLine": 7732,
      "focusLine": 7722,
      "lines": [
        "  @ 12,37.5 DCSAY \"Archive Emails:\" GET cdxEmailIsPrint  ;",
        "             PICTURE \u0027#\u0027 ;",
        "             GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "             LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "             SAYRIGHTBOTTOM ;",
        "             VALID {|| cdxEmailIsPrint$\"012\" } ;",
        "             GETTOOLTIP \"0 \u003d Disable Email Archive;1 \u003d Enable Email Archive;2 \u003d Close Preview after Email\" ;",
        "             SAYSIZE 12",
        "ENDIF",
        "",
        "@ 12, 2 DCSAY \"Enable Screen Resize:\" GET lScnReSize  ;",
        "            PICTURE \u0027Y\u0027 ;",
        "            GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "            LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "            SAYRIGHTBOTTOM ;",
        "            GETTOOLTIP \"Check to enable resizing screens.\" ;",
        "            SAYSIZE 20",
        "",
        "@ 12, 26 DCSAY \"Save Size:\" GET lSaveSize  ;",
        "            PICTURE \u0027Y\u0027 ;",
        "            GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 280744",
    "offset": 280744,
    "line": 7810,
    "column": 1,
    "evidence": {
      "startLine": 7800,
      "endLine": 7820,
      "focusLine": 7810,
      "lines": [
        "            ",
        "@ 18,2 DCSAY \"CRP Launches Outlook:\" GET ldxUseOutlookForVPEEmail  ;",
        "           PICTURE \u0027Y\u0027 ;",
        "           GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "           LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "           SAYRIGHTBOTTOM ;",
        "           GETTOOLTIP \"Checked indicates CRP will launch Outlook to email letters.  Unchecked, the CourtRoom Program will rely on VPE to launch an email client.\" ;",
        "           SAYSIZE 20",
        "",
        "  nLine :\u003d 19.5",
        "ENDIF",
        "",
        "@ nLine,5 DCPUSHBUTTON CAPTION \" ~Ok \"  SIZE 17,1.5 ;",
        "           ACCELKEY xbeK_CTRL_O ;",
        "           TOOLTIP \"Set the new defaults\" ;",
        "           ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_OK,GetList) }  ;",
        "           FONT BTN_FONT_B",
        "",
        "@ nLine,25 DCPUSHBUTTON CAPTION \"~Quit\"   SIZE 17,1.5 ;",
        "           ACCELKEY xbeK_CTRL_Q  ;",
        "           TOOLTIP \"Exit without saving the new defaults\" ;"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 280798",
    "offset": 280798,
    "line": 7812,
    "column": 48,
    "evidence": {
      "startLine": 7802,
      "endLine": 7822,
      "focusLine": 7812,
      "lines": [
        "           PICTURE \u0027Y\u0027 ;",
        "           GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "           LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "           SAYRIGHTBOTTOM ;",
        "           GETTOOLTIP \"Checked indicates CRP will launch Outlook to email letters.  Unchecked, the CourtRoom Program will rely on VPE to launch an email client.\" ;",
        "           SAYSIZE 20",
        "",
        "  nLine :\u003d 19.5",
        "ENDIF",
        "",
        "@ nLine,5 DCPUSHBUTTON CAPTION \" ~Ok \"  SIZE 17,1.5 ;",
        "           ACCELKEY xbeK_CTRL_O ;",
        "           TOOLTIP \"Set the new defaults\" ;",
        "           ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_OK,GetList) }  ;",
        "           FONT BTN_FONT_B",
        "",
        "@ nLine,25 DCPUSHBUTTON CAPTION \"~Quit\"   SIZE 17,1.5 ;",
        "           ACCELKEY xbeK_CTRL_Q  ;",
        "           TOOLTIP \"Exit without saving the new defaults\" ;",
        "           ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_ABORT, GetList) } ;",
        "           FONT BTN_FONT_B"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 281482",
    "offset": 281482,
    "line": 7829,
    "column": 1,
    "evidence": {
      "startLine": 7819,
      "endLine": 7839,
      "focusLine": 7829,
      "lines": [
        "           ACCELKEY xbeK_CTRL_Q  ;",
        "           TOOLTIP \"Exit without saving the new defaults\" ;",
        "           ACTION {|| DC_ReadGuiEvent(DCGUI_EXIT_ABORT, GetList) } ;",
        "           FONT BTN_FONT_B",
        "",
        "IF GetLevel(1) \u003d \u0027P\u0027",
        "  @ nLine+1.5,5 DCCHECKBOX lSaveToAll  SIZE 0 ;",
        "                  HIDE {|| .F. }   ; //  FONT cStdGetFont  ;",
        "                  PROMPT \"Save to ALL users\"   ;",
        "                  TOOLTIP \"Check to save these values;to ALL user\u0027s defaults\"",
        "ENDIF",
        "",
        "DCHOTKEY xbeK_F1 WHEN {||oDlg:getFrameState()\u003c\u003eXBPDLG_FRAMESTAT_MINIMIZED} ;",
        "               ACTION {||HelpObject():showhelp(CRP_U_UD) }",
        "",
        "DCREAD GUI TO lOK            ;",
        "          PARENT @oDlg       ;",
        "          EVAL {|oDlg|IIF(!Ok2Resize(),LockSize(oDlg),NIL)} ;",
        "          OPTIONS GetOptions ;",
        "          FIT",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token TO at 281637",
    "offset": 281637,
    "line": 7834,
    "column": 12,
    "evidence": {
      "startLine": 7824,
      "endLine": 7844,
      "focusLine": 7834,
      "lines": [
        "IF GetLevel(1) \u003d \u0027P\u0027",
        "  @ nLine+1.5,5 DCCHECKBOX lSaveToAll  SIZE 0 ;",
        "                  HIDE {|| .F. }   ; //  FONT cStdGetFont  ;",
        "                  PROMPT \"Save to ALL users\"   ;",
        "                  TOOLTIP \"Check to save these values;to ALL user\u0027s defaults\"",
        "ENDIF",
        "",
        "DCHOTKEY xbeK_F1 WHEN {||oDlg:getFrameState()\u003c\u003eXBPDLG_FRAMESTAT_MINIMIZED} ;",
        "               ACTION {||HelpObject():showhelp(CRP_U_UD) }",
        "",
        "DCREAD GUI TO lOK            ;",
        "          PARENT @oDlg       ;",
        "          EVAL {|oDlg|IIF(!Ok2Resize(),LockSize(oDlg),NIL)} ;",
        "          OPTIONS GetOptions ;",
        "          FIT",
        "",
        "GetList:\u003d{}",
        "DestroyAll( @oDlg )",
        "oDlg :\u003d NIL",
        "",
        "IF lOK           // Save the new values"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 282084",
    "offset": 282084,
    "line": 7854,
    "column": 3,
    "evidence": {
      "startLine": 7844,
      "endLine": 7864,
      "focusLine": 7854,
      "lines": [
        "IF lOK           // Save the new values",
        "  Ok2SaveDlgSize( lSaveSize )",
        "  Ok2SaveDlgPos( lSavePos )",
        "  Ok2Resize( lScnReSize )",
        "  SaturdayOK(lSatOK)",
        "  ChkHolidays( lChkHDay )",
        "  HolidayNotify(lHDNotify)",
        "",
        "  IF mParkMove \u003d \"M\"",
        "    GetOptionSetup()",
        "  ENDIF",
        "  cdxRptPath :\u003d alltrim(tempACpath)",
        "  FixJCFTran(@cdxRptPath)            // \u003c-- fix trailing \u0027\\\u0027 and/or \u0027:\u0027",
        "",
        "  cdxMCImportPath :\u003d alltrim(tempMCIpath)",
        "  IF right(cdxMCImportPath,1)\u003c\u003e\u0027\\\u0027",
        "    cdxMCImportPath +\u003d \u0027\\\u0027",
        "  ENDIF",
        "",
        "  cdxDMVImportPath :\u003d alltrim(tempETicPath)",
        "  IF right(cdxDMVImportPath,1)\u003c\u003e\u0027\\\u0027"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 285327",
    "offset": 285327,
    "line": 7958,
    "column": 3,
    "evidence": {
      "startLine": 7948,
      "endLine": 7968,
      "focusLine": 7958,
      "lines": [
        "      FOR x:\u003d 1 TO reccount()",
        "        WriteUserDefaults(IniFile,password-\u003eTYPISTCODE)",
        "        dbSkip()",
        "        oAlertBox[3]:increment()",
        "      NEXT",
        "//      WriteUserDefaults(IniFile,\"sEi\")",
        "//      WriteUserDefaults(IniFile,\"xYz\")",
        "    ENDIF",
        "    USE",
        "    SELE(oldArea)",
        "  ENDIF",
        "  IniDone(@IniFile)     // No more ini file stuff after this!",
        "  KillAlert(@oAlertBox)",
        "  Proper(ldxProper)",
        "  SetPrintScreen()",
        "  ",
        "  InfoBox(\"You have updated the user defaults.  Please restart CourtRoom Program before continuing.\",\"User Defaults Updated\")",
        "ELSE             // Reread old values",
        "  LoadUserDefaults()",
        "ENDIF",
        "SetSEIstdBtn()"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 285587",
    "offset": 285587,
    "line": 7965,
    "column": 1,
    "evidence": {
      "startLine": 7955,
      "endLine": 7975,
      "focusLine": 7965,
      "lines": [
        "    ENDIF",
        "    USE",
        "    SELE(oldArea)",
        "  ENDIF",
        "  IniDone(@IniFile)     // No more ini file stuff after this!",
        "  KillAlert(@oAlertBox)",
        "  Proper(ldxProper)",
        "  SetPrintScreen()",
        "  ",
        "  InfoBox(\"You have updated the user defaults.  Please restart CourtRoom Program before continuing.\",\"User Defaults Updated\")",
        "ELSE             // Reread old values",
        "  LoadUserDefaults()",
        "ENDIF",
        "SetSEIstdBtn()",
        "RETURN",
        "// EOP EditUserDefaults",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE LoadUserDefaults()     // aUDefaults is a public var",
        "LOCAL iniFile"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 285646",
    "offset": 285646,
    "line": 7967,
    "column": 1,
    "evidence": {
      "startLine": 7957,
      "endLine": 7977,
      "focusLine": 7967,
      "lines": [
        "    SELE(oldArea)",
        "  ENDIF",
        "  IniDone(@IniFile)     // No more ini file stuff after this!",
        "  KillAlert(@oAlertBox)",
        "  Proper(ldxProper)",
        "  SetPrintScreen()",
        "  ",
        "  InfoBox(\"You have updated the user defaults.  Please restart CourtRoom Program before continuing.\",\"User Defaults Updated\")",
        "ELSE             // Reread old values",
        "  LoadUserDefaults()",
        "ENDIF",
        "SetSEIstdBtn()",
        "RETURN",
        "// EOP EditUserDefaults",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE LoadUserDefaults()     // aUDefaults is a public var",
        "LOCAL iniFile",
        "",
        "  IniFile    :\u003d TIniFile():New(DataPath()+\"users.ini\")   // Open or create USERS.INI"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 296697",
    "offset": 296697,
    "line": 8137,
    "column": 66,
    "evidence": {
      "startLine": 8127,
      "endLine": 8147,
      "focusLine": 8137,
      "lines": [
        "  ENDIF",
        "RETURN",
        "// EOP WriteUserDefaults",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE CustomBtnClrSetup()",
        "LOCAL oAlertBox, GetList:\u003d{}, GetOptions, lOK, oBG, oMO, oMC, ;",
        "      oDlg1, IniFile",
        "",
        "  @ 1, 5   DCPUSHBUTTON CAPTION \"  Set Background Color\"  SIZE 25,1.3 ;",
        "              STATIC OBJECT oBG ;        //                  ALIGNCAPTION BS_CENTER ;",
        "              ACCELKEY xbeK_CTRL_B ;",
        "              EVAL {|o| o:setColorBG(ndxCustBtnBGClr)} ;",
        "              TOOLTIP \"Set a custom button;background color\" ;",
        "              FONT BTN_FONT_B      ;",
        "              ACTION  {|x| x:\u003dV_GetColor(GraGetRGBIntensity(ndxCustBtnBGClr),,1,3), ;",
        "                               ndxCustBtnBGClr:\u003dx, oBG:setColorBG(ndxCustBtnBGClr) }",
        "",
        "  @ 2.5, 5 DCPUSHBUTTON CAPTION \"  Set MouseOver Color\"  SIZE 25,1.3 ;",
        "              STATIC OBJECT oMO ;           //               ALIGNCAPTION BS_CENTER ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 299474",
    "offset": 299474,
    "line": 8196,
    "column": 1,
    "evidence": {
      "startLine": 8186,
      "endLine": 8206,
      "focusLine": 8196,
      "lines": [
        "",
        "  GetList:\u003d{}",
        "  Scn_No(0)",
        "",
        "IF lOK    // did we exit without ESC or quit?",
        "  IniFile :\u003d TIniFile():New(DataPath()+\"users.ini\")",
        "  IniFile:WriteString(cuTypistCode+\"-UserDefaults\",\"CustomBtnBGColor\",nTrim(ndxCustBtnBGClr))",
        "  IniFile:WriteString(cuTypistCode+\"-UserDefaults\",\"CustomBtnMouseColor\",nTrim(ndxCustBtnMouseClr))",
        "  IniFile:WriteString(cuTypistCode+\"-UserDefaults\",\"CustomBtnClickColor\",nTrim(ndxCustBtnClickClr))",
        "  IniDone(@IniFile)     // No more ini file stuff after this!",
        "ENDIF",
        "",
        "RETURN",
        "// EOP CustomBtnClrSetup",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE CleanUserIni(lQuiet)",
        "LOCAL cValidUsers, aDeleteUsers, x, xTest, xIniText, oldArea:\u003dSELE(), ;",
        "      lNeedPack:\u003d.F., IniFile",
        "PRIVATE  aProgress"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 304001",
    "offset": 304001,
    "line": 8339,
    "column": 3,
    "evidence": {
      "startLine": 8329,
      "endLine": 8349,
      "focusLine": 8339,
      "lines": [
        "ENDIF",
        "",
        "  AlertBox TO lOk TEXT \"Are you sure you want to \"+cText   ;",
        "         BUTTONS {\" OK \",\" CANCEL \"} ;",
        "         FONT FONT_TIMES_MEDIUM ;",
        "         SYSICON \"?\"            ;",
        "         TITLE \"CONFIRM LOCAL FEE OPTIONS\"",
        "  IF lOk \u003c\u003e 1",
        "    infobox(\"Local Fee Setup was Canceled\",,4)",
        "    RETURN",
        "  ENDIF",
        "",
        "",
        "IF lOk \u003d 1",
        "  ndxLocalFeeAmt   :\u003d nqLocalFeeAmt    // Local Charge CivilFee amount",
        "  cdxLocalFeeRule  :\u003d cqLocalFeeRule   // applyRule -- \u0027O\u0027\u003dOne Charge per case, \u0027A\u0027\u003dAll Charges, \u0027C\u0027\u003dCustom",
        "  cdxLocalFeeTxt   :\u003d cqLocalFeeTxt    // Text for Fee (ie. \u0027Driver Responsibility Fee\u0027)",
        "  cdxLocalFeeLaw   :\u003d cqLocalFeeLaw    // Local Law Section (ie. \u00272016-21\u0027)",
        "  ddxLocalFeeDate  :\u003d dqLocalFeeDate   // Date Local Law Fee Effective",
        "",
        "  IniFile :\u003d TIniFile():New(DataPath()+\"USERS.INI\")        // Open USERS.INI"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 307847",
    "offset": 307847,
    "line": 8447,
    "column": 34,
    "evidence": {
      "startLine": 8437,
      "endLine": 8457,
      "focusLine": 8447,
      "lines": [
        "              STOREGETLIST GetList   ;",
        "              WINMENU                ;",
        "              WINMENUTITLE \"Edit Notes\"",
        "",
        "//  oDlg1:setInputFocus :\u003d {|| GetNote(aCrtDay,aFilePos[3]),xxNote:\u003d ccdNotes,;",
        "//                             dc_getrefresh(@GetList),SetAppFocus(oNote) }",
        "//  oDlg1:KillDisplayFocus :\u003d {||IIF(!(oNote:getdata()\u003d\u003dccdNotes),;",
        "//              IIF(RFAModAlert()\u003d1,(ccdNotes:\u003dxxNote,PutNote(aCrtDay,aFilePos[3])),NIL),NIL) }",
        "",
        "  DC_GetPopupCaption( {\"\",BITMAP_MENU} )",
        "@ 1,1 DCGROUP oNoteGroup  SIZE 87,16 ;          // Box around notes",
        "                NOTABSTOP",
        "@ 0.7,0.95 DCKLMLE xxNote            ;",
        "            GOTFOCUS {|u1,u2,o|oldHelp:\u003dHelpSet(CRP_NS_NS),ReHiLite(o,1,GRA_CLR_RED)} ;",
        "            LOSTFOCUS {|u1,u2,o|HelpSet(oldHelp),ReHiLite(o,2,GRA_CLR_RED)};",
        "            PARENT oNoteGroup        ;",
        "            SIZE 85,15               ;",
        "            NOHORIZSCROLL            ;   // required to force word wrap",
        "            FONT cStdGetFont       ;",
        "            GROUP \"NoteField\"        ;",
        "            SUGGESTFONT BTN_FONT_B   ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 309852",
    "offset": 309852,
    "line": 8498,
    "column": 5,
    "evidence": {
      "startLine": 8488,
      "endLine": 8508,
      "focusLine": 8498,
      "lines": [
        "          EVAL {|oDlg1| Scn_No(049),;",
        "                        IIF(!Ok2Resize(),LockSize(oDlg1),NIL),;",
        "                        oDlg1:show(),;",
        "                        SetAppFocus(oDlg1),;",
        "                        SetAppFocus(oNote)}",
        "",
        "  IF nExit \u003c\u003e 5 .AND. !(xxNote \u003d\u003d ccdNotes)",
        "    nExit2 :\u003d RFAModAlert()",
        "    IF nExit2 \u003d 1",
        "      nExit :\u003d 5",
        "    ENDIF",
        "  ENDIF",
        "  IF nExit \u003d 5    // Need to save",
        "    ccdNotes :\u003d xxNote",
        "    PutNote(aCrtDay,aFilePos[3]) // put xxNote into aCrtDay and save if changed!",
        "  ENDIF",
        "  GetList:\u003d{}",
        "  DestroyAll( @oDlg1 )",
        "  oDlg1   :\u003d NIL",
        "",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 309860",
    "offset": 309860,
    "line": 8499,
    "column": 3,
    "evidence": {
      "startLine": 8489,
      "endLine": 8509,
      "focusLine": 8499,
      "lines": [
        "                        IIF(!Ok2Resize(),LockSize(oDlg1),NIL),;",
        "                        oDlg1:show(),;",
        "                        SetAppFocus(oDlg1),;",
        "                        SetAppFocus(oNote)}",
        "",
        "  IF nExit \u003c\u003e 5 .AND. !(xxNote \u003d\u003d ccdNotes)",
        "    nExit2 :\u003d RFAModAlert()",
        "    IF nExit2 \u003d 1",
        "      nExit :\u003d 5",
        "    ENDIF",
        "  ENDIF",
        "  IF nExit \u003d 5    // Need to save",
        "    ccdNotes :\u003d xxNote",
        "    PutNote(aCrtDay,aFilePos[3]) // put xxNote into aCrtDay and save if changed!",
        "  ENDIF",
        "  GetList:\u003d{}",
        "  DestroyAll( @oDlg1 )",
        "  oDlg1   :\u003d NIL",
        "",
        "",
        "  Scn_No(0)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 310667",
    "offset": 310667,
    "line": 8537,
    "column": 3,
    "evidence": {
      "startLine": 8527,
      "endLine": 8547,
      "focusLine": 8537,
      "lines": [
        "LOCAL nReturn",
        "ALERTBOX TEXT \u0027Data has been modified.;Save Changes?\u0027;",
        "          TO nReturn ;",
        "          BUTTONS {\u0027YES\u0027,\u0027NO\u0027} ;",
        "          SYSICON \"?\" ;    //",
        "          FONT FONT_TIMES_MEDIUM ;",
        "          TITLE \u0027Caution\u0027 ;",
        "          DEFAULTBUTTON 1",
        "  IF nReturn\u003d1",
        "    CurReadLev(1)",
        "  ENDIF",
        "RETURN nReturn",
        "// EOF RFAModAlert",
        "",
        "// MarijuanaSeal",
        "//-----------------------------------------------",
        "PROCEDURE MarijuanaSeal(aCaseList, p_cTypist)  // aCaseList \u003d {indexno,indexno,...}",
        "  CustomSeal(aCaseList, \u00270\u0027, p_cTypist)",
        "RETURN",
        "// EOP MarijuanaSeal",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 311719",
    "offset": 311719,
    "line": 8580,
    "column": 37,
    "evidence": {
      "startLine": 8570,
      "endLine": 8590,
      "focusLine": 8580,
      "lines": [
        "  ",
        "  dbSelectArea(\"CHARGES\")",
        "  oldOrder :\u003d OrdNumber()",
        "  oldRec:\u003drecno()",
        "    ",
        "  FOR x:\u003d1 TO len(p_aCaseList)",
        "    OrderSet(\"B1\")",
        "    seek p_aCaseList[x]",
        "    IF found()",
        "      rec_lock(0)",
        "      REPLACE seal_type WITH p_cSeal,;",
        "              changed   WITH date(),;",
        "              typist    WITH p_cTypist     // Automatic Seal",
        "      y++",
        "      DBCommit()",
        "      unlock all",
        "      OrderSet(\"C1\")",
        "      seek SubStr(p_aCaseList[x], 1, 9)",
        "      IF found()",
        "        rec_lock(0)",
        "        REPLACE COURTDAY-\u003eNOTES WITH dtoc(date()) + \": Charge \" + GetChargeNumber(p_aCaseList[x]);"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 312355",
    "offset": 312355,
    "line": 8597,
    "column": 5,
    "evidence": {
      "startLine": 8587,
      "endLine": 8607,
      "focusLine": 8597,
      "lines": [
        "      seek SubStr(p_aCaseList[x], 1, 9)",
        "      IF found()",
        "        rec_lock(0)",
        "        REPLACE COURTDAY-\u003eNOTES WITH dtoc(date()) + \": Charge \" + GetChargeNumber(p_aCaseList[x]);",
        "                                      + \" Sealed \" + FormatSealCode(p_cSeal) + \" by Form (\" + p_cTypist + \"). - \";",
        "                                      + cuTypistCode + CRLF + CRLF + COURTDAY-\u003eNOTES",
        "                                      ",
        "        DBCommit()",
        "        unlock all",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(OldRec)",
        "  SELE(oldArea)",
        "  IF y\u003e0",
        "    Infobox(nTrim(y)+\u0027 record\u0027+IIF(y\u003d1,\u0027 was\u0027,\u0027s were\u0027)+\u0027 sealed \u0027 + p_cSeal)",
        "  ELSE",
        "    Infobox(\u0027No records were sealed!.\u0027)",
        "  ENDIF",
        "RETURN"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 313546",
    "offset": 313546,
    "line": 8651,
    "column": 1,
    "evidence": {
      "startLine": 8641,
      "endLine": 8661,
      "focusLine": 8651,
      "lines": [
        "      RETURN",
        "    ENDIF",
        "    IF nOK \u003d 2",
        "      mnAllowFrmUp :\u003d 2",
        "      RETURN",
        "    ENDIF",
        "    IF nOK \u003d 4",
        "      mnAllowFrmUp :\u003d 1",
        "    ENDIF",
        "  ENDIF",
        "ENDIF",
        "",
        "IF empty(cFrmFileName)",
        "  IF nFormNo\u003e97",
        "    cFrmFileName :\u003d str(nFormNo,3)           // default forms",
        "  ELSE",
        "    cFrmFileName :\u003d \"LH_\"+strzero(nFormNo,3)  // default letterheads",
        "  ENDIF",
        "ENDIF",
        "nArea :\u003d select(\"cForms\")",
        "IF nArea \u003d\u003d 0"
      ]
    }
  },
  {
    "message": "Expected TO in FOR statement at 314111",
    "offset": 314111,
    "line": 8675,
    "column": 1,
    "evidence": {
      "startLine": 8665,
      "endLine": 8685,
      "focusLine": 8675,
      "lines": [
        "               \"CFORMS.DBF PROBLEM\")",
        "    USE",
        "    SELE(oldArea)",
        "    lOK2 :\u003d .F.",
        "    RETURN",
        "  ENDIF",
        "ELSE",
        "  dbSelectArea(\"cForms\")",
        "ENDIF",
        "Locate FOR Form_No \u003d nFormNo",
        "IF !found() .AND. lMake",
        "  Append Blank",
        "  lNew:\u003d.T.",
        "ENDIF",
        "oldRec :\u003d RecNo()",
        "",
        " DO WHILE (found().OR.lNew) .AND. lOK2",
        "  IF UpdateBlocked(cforms-\u003eText)\u003e0   // we found it, is update blocked?",
        "    InfoBox(alltrim(cforms-\u003eName)+\" form was not updated.;\"+;",
        "          +\"Update is blocked by the \u0027..NOUPDATE\u0027 directive!\",;",
        "             \"FORM UPDATE BLOCKED\",5)"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 314111",
    "offset": 314111,
    "line": 8675,
    "column": 1,
    "evidence": {
      "startLine": 8665,
      "endLine": 8685,
      "focusLine": 8675,
      "lines": [
        "               \"CFORMS.DBF PROBLEM\")",
        "    USE",
        "    SELE(oldArea)",
        "    lOK2 :\u003d .F.",
        "    RETURN",
        "  ENDIF",
        "ELSE",
        "  dbSelectArea(\"cForms\")",
        "ENDIF",
        "Locate FOR Form_No \u003d nFormNo",
        "IF !found() .AND. lMake",
        "  Append Blank",
        "  lNew:\u003d.T.",
        "ENDIF",
        "oldRec :\u003d RecNo()",
        "",
        " DO WHILE (found().OR.lNew) .AND. lOK2",
        "  IF UpdateBlocked(cforms-\u003eText)\u003e0   // we found it, is update blocked?",
        "    InfoBox(alltrim(cforms-\u003eName)+\" form was not updated.;\"+;",
        "          +\"Update is blocked by the \u0027..NOUPDATE\u0027 directive!\",;",
        "             \"FORM UPDATE BLOCKED\",5)"
      ]
    }
  },
  {
    "message": "Expected end expression after TO at 314114",
    "offset": 314114,
    "line": 8675,
    "column": 4,
    "evidence": {
      "startLine": 8665,
      "endLine": 8685,
      "focusLine": 8675,
      "lines": [
        "               \"CFORMS.DBF PROBLEM\")",
        "    USE",
        "    SELE(oldArea)",
        "    lOK2 :\u003d .F.",
        "    RETURN",
        "  ENDIF",
        "ELSE",
        "  dbSelectArea(\"cForms\")",
        "ENDIF",
        "Locate FOR Form_No \u003d nFormNo",
        "IF !found() .AND. lMake",
        "  Append Blank",
        "  lNew:\u003d.T.",
        "ENDIF",
        "oldRec :\u003d RecNo()",
        "",
        " DO WHILE (found().OR.lNew) .AND. lOK2",
        "  IF UpdateBlocked(cforms-\u003eText)\u003e0   // we found it, is update blocked?",
        "    InfoBox(alltrim(cforms-\u003eName)+\" form was not updated.;\"+;",
        "          +\"Update is blocked by the \u0027..NOUPDATE\u0027 directive!\",;",
        "             \"FORM UPDATE BLOCKED\",5)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 314162",
    "offset": 314162,
    "line": 8678,
    "column": 1,
    "evidence": {
      "startLine": 8668,
      "endLine": 8688,
      "focusLine": 8678,
      "lines": [
        "    lOK2 :\u003d .F.",
        "    RETURN",
        "  ENDIF",
        "ELSE",
        "  dbSelectArea(\"cForms\")",
        "ENDIF",
        "Locate FOR Form_No \u003d nFormNo",
        "IF !found() .AND. lMake",
        "  Append Blank",
        "  lNew:\u003d.T.",
        "ENDIF",
        "oldRec :\u003d RecNo()",
        "",
        " DO WHILE (found().OR.lNew) .AND. lOK2",
        "  IF UpdateBlocked(cforms-\u003eText)\u003e0   // we found it, is update blocked?",
        "    InfoBox(alltrim(cforms-\u003eName)+\" form was not updated.;\"+;",
        "          +\"Update is blocked by the \u0027..NOUPDATE\u0027 directive!\",;",
        "             \"FORM UPDATE BLOCKED\",5)",
        "    DbContinue()         // Maybe other Judges have same form!",
        "    loop",
        "  ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected token ARROW at 316043",
    "offset": 316043,
    "line": 8721,
    "column": 13,
    "evidence": {
      "startLine": 8711,
      "endLine": 8731,
      "focusLine": 8721,
      "lines": [
        "      REPLACE cforms-\u003eGraph_Bot   WITH val(substr(txt_in,80,5))",
        "      REPLACE cforms-\u003eNum_Copies  WITH substr(txt_in,85,2)",
        "      REPLACE cforms-\u003eText        WITH substr(txt_in,87)",
        "      IF substr(cforms-\u003eText,1,2) \u003d\u003d chr(13)+chr(10)",
        "        REPLACE cforms-\u003eText WITH substr(cforms-\u003eText,3)",
        "      ENDIF",
        "      REPLACE cforms-\u003eRev_Lv      WITH IncRevLev(cforms-\u003eRev_Lv)",
        "      REPLACE cforms-\u003eTypist      WITH \"T05\"       // Tag-05",
        "      REPLACE cforms-\u003eChanged     WITH date()",
        "      REPLACE cforms-\u003eLocked      WITH \u0027 \u0027",
        "      cforms-\u003e(dbCommit())",
        "      unlock all",
        "    ENDIF",
        "  ENDIF",
        "  IF lNew",
        "    EXIT",
        "  ENDIF",
        "  IF !empty(aOldVars)",
        "    ResetVars(aOldVars)",
        "  ENDIF",
        "  DbContinue()"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 318162",
    "offset": 318162,
    "line": 8813,
    "column": 7,
    "evidence": {
      "startLine": 8803,
      "endLine": 8823,
      "focusLine": 8813,
      "lines": [
        "  IF valtype(lSetOK)\u003d\u003d\"L\"",
        "    IF lSetOK .AND. snTries \u003c 3.5",
        "      IF Prompt4Access(.T.,0)     // old style number of the day -- date offset is 0",
        "        snBypass :\u003d seconds()",
        "        sdDate :\u003d date()",
        "        snTries :\u003d 0",
        "      ELSE      // Must have been bad password, shut down access",
        "        snBypass :\u003d -1000",
        "        sdDate :\u003d date()-5        // just not equal to today!",
        "        snTries++",
        "      ENDIF",
        "    ELSE        // Must have been .F., shut down access",
        "      snBypass :\u003d -1000",
        "      sdDate :\u003d date()-5          // just not equal to today!",
        "    ENDIF",
        "  ENDIF",
        "",
        "  IF snBypass \u003e seconds()-180 .AND. sdDate\u003d\u003ddate()           // 3 Minutes of unrestricted access!",
        "    lOK :\u003d .T.",
        "  ENDIF",
        "ENDIF"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 318172",
    "offset": 318172,
    "line": 8814,
    "column": 5,
    "evidence": {
      "startLine": 8804,
      "endLine": 8824,
      "focusLine": 8814,
      "lines": [
        "    IF lSetOK .AND. snTries \u003c 3.5",
        "      IF Prompt4Access(.T.,0)     // old style number of the day -- date offset is 0",
        "        snBypass :\u003d seconds()",
        "        sdDate :\u003d date()",
        "        snTries :\u003d 0",
        "      ELSE      // Must have been bad password, shut down access",
        "        snBypass :\u003d -1000",
        "        sdDate :\u003d date()-5        // just not equal to today!",
        "        snTries++",
        "      ENDIF",
        "    ELSE        // Must have been .F., shut down access",
        "      snBypass :\u003d -1000",
        "      sdDate :\u003d date()-5          // just not equal to today!",
        "    ENDIF",
        "  ENDIF",
        "",
        "  IF snBypass \u003e seconds()-180 .AND. sdDate\u003d\u003ddate()           // 3 Minutes of unrestricted access!",
        "    lOK :\u003d .T.",
        "  ENDIF",
        "ENDIF",
        "IF !SecureOK()"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 318172",
    "offset": 318172,
    "line": 8814,
    "column": 5,
    "evidence": {
      "startLine": 8804,
      "endLine": 8824,
      "focusLine": 8814,
      "lines": [
        "    IF lSetOK .AND. snTries \u003c 3.5",
        "      IF Prompt4Access(.T.,0)     // old style number of the day -- date offset is 0",
        "        snBypass :\u003d seconds()",
        "        sdDate :\u003d date()",
        "        snTries :\u003d 0",
        "      ELSE      // Must have been bad password, shut down access",
        "        snBypass :\u003d -1000",
        "        sdDate :\u003d date()-5        // just not equal to today!",
        "        snTries++",
        "      ENDIF",
        "    ELSE        // Must have been .F., shut down access",
        "      snBypass :\u003d -1000",
        "      sdDate :\u003d date()-5          // just not equal to today!",
        "    ENDIF",
        "  ENDIF",
        "",
        "  IF snBypass \u003e seconds()-180 .AND. sdDate\u003d\u003ddate()           // 3 Minutes of unrestricted access!",
        "    lOK :\u003d .T.",
        "  ENDIF",
        "ENDIF",
        "IF !SecureOK()"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 319036",
    "offset": 319036,
    "line": 8842,
    "column": 32,
    "evidence": {
      "startLine": 8832,
      "endLine": 8852,
      "focusLine": 8842,
      "lines": [
        "FUNCTION Prompt4Access(lSecure,nDateOffset)",
        "  LOCAL nEvent, mp1, mp2, lExit, cPassWord, oPW, drawingArea, ;",
        "        oOK, aPos, aSize, oXbp, lOK:\u003d.F.",
        "",
        "  v_Valtype(@lSecure,.T.,@nDateOffset,0)",
        "",
        "  aSize            :\u003d {350,80}",
        "  aPos             :\u003d CenterPos(aSize,RootWindow():currentSize())",
        "  oDlg             :\u003d XbpDialog():new( AppDesktop(), SetAppWindow(), aPos, aSize, , .F.)",
        "  oDlg:Title       :\u003d \"ACCESS PASSWORD REQUIRED\"",
        "  oDlg:close       :\u003d {|| lExit:\u003d.T. }",
        "  oDlg:border      :\u003d XBPDLG_DLGBORDER",
        "  oDlg:taskList    :\u003d .T.",
        "  oDlg:MinButton   :\u003d .F.",
        "  oDlg:MaxButton   :\u003d .F.",
        "  oDlg:alwaysOnTop :\u003d .T.",
        "  oDlg:icon        :\u003d ICON_GAVEL",
        "  oDlg:drawingArea:bitmap :\u003d BITMAP_BRICKS",
        "  oDlg:setDisplayFocus :\u003d {||setAppFocus( oPW )}",
        "  oDlg:create()",
        "  oDlg:drawingArea:SetColorBG( XBPSYSCLR_TRANSPARENT )"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 319036",
    "offset": 319036,
    "line": 8842,
    "column": 32,
    "evidence": {
      "startLine": 8832,
      "endLine": 8852,
      "focusLine": 8842,
      "lines": [
        "FUNCTION Prompt4Access(lSecure,nDateOffset)",
        "  LOCAL nEvent, mp1, mp2, lExit, cPassWord, oPW, drawingArea, ;",
        "        oOK, aPos, aSize, oXbp, lOK:\u003d.F.",
        "",
        "  v_Valtype(@lSecure,.T.,@nDateOffset,0)",
        "",
        "  aSize            :\u003d {350,80}",
        "  aPos             :\u003d CenterPos(aSize,RootWindow():currentSize())",
        "  oDlg             :\u003d XbpDialog():new( AppDesktop(), SetAppWindow(), aPos, aSize, , .F.)",
        "  oDlg:Title       :\u003d \"ACCESS PASSWORD REQUIRED\"",
        "  oDlg:close       :\u003d {|| lExit:\u003d.T. }",
        "  oDlg:border      :\u003d XBPDLG_DLGBORDER",
        "  oDlg:taskList    :\u003d .T.",
        "  oDlg:MinButton   :\u003d .F.",
        "  oDlg:MaxButton   :\u003d .F.",
        "  oDlg:alwaysOnTop :\u003d .T.",
        "  oDlg:icon        :\u003d ICON_GAVEL",
        "  oDlg:drawingArea:bitmap :\u003d BITMAP_BRICKS",
        "  oDlg:setDisplayFocus :\u003d {||setAppFocus( oPW )}",
        "  oDlg:create()",
        "  oDlg:drawingArea:SetColorBG( XBPSYSCLR_TRANSPARENT )"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 320646",
    "offset": 320646,
    "line": 8889,
    "column": 5,
    "evidence": {
      "startLine": 8879,
      "endLine": 8899,
      "focusLine": 8889,
      "lines": [
        "  Dlg2Front(oDlg)",
        "  SetAppFocus( oPW )",
        "",
        "  lExit :\u003d .F.",
        "  oPW:clear()",
        "  SetAppFocus( oPW )",
        "  DO WHILE !lExit",
        "    nEvent :\u003d AppEvent( @mp1, @mp2, @oXbp, 1 )",
        "    IF nEvent\u003c\u003exbe_None .AND. IsObject(oXbp)",
        "      oXbp:handleEvent( nEvent, mp1, mp2 )",
        "    ENDIF",
        "    IF nEvent \u003d\u003d xbeP_Keyboard .AND. (mp1 \u003d\u003d xbeK_ESC .OR. mp1 \u003d\u003d xbeK_END)",
        "      lExit :\u003d .T.",
        "    ENDIF",
        "  ENDDO",
        "  cPassWord :\u003d alltrim(oPW:getData())",
        "  oDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oDlg )",
        "  oDlg :\u003d NIL",
        "  IF lSecure",
        "    IF RDtC(cPassword)"
      ]
    }
  },
  {
    "message": "Unexpected ENDDO at 320759",
    "offset": 320759,
    "line": 8893,
    "column": 3,
    "evidence": {
      "startLine": 8883,
      "endLine": 8903,
      "focusLine": 8893,
      "lines": [
        "  oPW:clear()",
        "  SetAppFocus( oPW )",
        "  DO WHILE !lExit",
        "    nEvent :\u003d AppEvent( @mp1, @mp2, @oXbp, 1 )",
        "    IF nEvent\u003c\u003exbe_None .AND. IsObject(oXbp)",
        "      oXbp:handleEvent( nEvent, mp1, mp2 )",
        "    ENDIF",
        "    IF nEvent \u003d\u003d xbeP_Keyboard .AND. (mp1 \u003d\u003d xbeK_ESC .OR. mp1 \u003d\u003d xbeK_END)",
        "      lExit :\u003d .T.",
        "    ENDIF",
        "  ENDDO",
        "  cPassWord :\u003d alltrim(oPW:getData())",
        "  oDlg:setModalState( XBP_DISP_MODELESS )",
        "  DestroyAll( @oDlg )",
        "  oDlg :\u003d NIL",
        "  IF lSecure",
        "    IF RDtC(cPassword)",
        "      lOK :\u003d .T.",
        "    ENDIF",
        "  ELSE",
        "    IF cPassWord \u003d\u003d TMDC(date()+nDateOffset)"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 323519",
    "offset": 323519,
    "line": 8995,
    "column": 21,
    "evidence": {
      "startLine": 8985,
      "endLine": 9005,
      "focusLine": 8995,
      "lines": [
        "oldFocus :\u003d SetAppFocus()",
        "",
        "SEIStdDialog oDlg   ;",
        "              TITLE \u0027Enter Data\u0027   ;",
        "              SIZE {100,100}       ;",
        "              MODAL                ;",
        "              STOREGETLIST GetList ;",
        "              NOWINMENU",
        "",
        "@ 1, 3 DCSAY cTitle  ;",
        "          SAYSIZE 40,1.2 ;",
        "          SAYCOLOR GRA_CLR_DARKBLUE,XBPSYSCLR_TRANSPARENT  ;",
        "          SAYFONT cStdLargeSay",
        "",
        "@ 3, 3 DCKLMLE cReason  SIZE 40,4  ;",
        "          NOHORIZSCROLL  ;",
        "          GOTFOCUS {|u1,u2,o|ReHiLite(o,1,GRA_CLR_RED)} ;",
        "          LOSTFOCUS {|u1,u2,o|ReHiLite(o,2,GRA_CLR_RED)} ;",
        "          SUGGESTFONT BTN_FONT_B       ;",
        "          SHORTSPELL xbeK_CTRL_K       ;",
        "          MAINDICT \"Court.Dic\"         ;"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 325390",
    "offset": 325390,
    "line": 9045,
    "column": 1,
    "evidence": {
      "startLine": 9035,
      "endLine": 9055,
      "focusLine": 9045,
      "lines": [
        "       PARENT @oDlg  ;         //        HANDLER DlgHandler ;",
        "       EVAL {|oDlg| IIF(!Ok2Resize(),LockSize(oDlg),NIL),;",
        "                    oDlg:SetPos(CenterScnPos(oDlg:currentSize(),RootWindow())), ;",
        "                    SetAppWindow(oDlg),;",
        "                    SetAppFocus(oDlg),;",
        "                    SetAppFocus(oReason) }",
        "",
        "IF lOK",
        "  cReason :\u003d alltrim(cReason)",
        "  cReason :\u003d strtran(cReason,chr(13)+chr(10),\u0027 \u0027)",
        "ELSE",
        "  cReason :\u003d \"\"",
        "ENDIF",
        "oDlg:setModalState( XBP_DISP_MODELESS )",
        "IF IsObject(oldFocus)",
        "  SetAppFocus(oldFocus)",
        "ENDIF",
        "GetList:\u003d{}",
        "DestroyAll( @oDlg )",
        "oDlg    :\u003d NIL",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 325411",
    "offset": 325411,
    "line": 9047,
    "column": 1,
    "evidence": {
      "startLine": 9037,
      "endLine": 9057,
      "focusLine": 9047,
      "lines": [
        "                    oDlg:SetPos(CenterScnPos(oDlg:currentSize(),RootWindow())), ;",
        "                    SetAppWindow(oDlg),;",
        "                    SetAppFocus(oDlg),;",
        "                    SetAppFocus(oReason) }",
        "",
        "IF lOK",
        "  cReason :\u003d alltrim(cReason)",
        "  cReason :\u003d strtran(cReason,chr(13)+chr(10),\u0027 \u0027)",
        "ELSE",
        "  cReason :\u003d \"\"",
        "ENDIF",
        "oDlg:setModalState( XBP_DISP_MODELESS )",
        "IF IsObject(oldFocus)",
        "  SetAppFocus(oldFocus)",
        "ENDIF",
        "GetList:\u003d{}",
        "DestroyAll( @oDlg )",
        "oDlg    :\u003d NIL",
        "",
        "RETURN cReason",
        "// EOF Prompt4Reason"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 330451",
    "offset": 330451,
    "line": 9211,
    "column": 1,
    "evidence": {
      "startLine": 9201,
      "endLine": 9221,
      "focusLine": 9211,
      "lines": [
        "  RETURN",
        "ENDIF",
        "",
        "IF mParkMove\u003d\u003d\"P\"      // Parking timeout not done yet!",
        "  RETURN",
        "ENDIF",
        "IF IsSpecial()",
        "  RETURN",
        "ENDIF",
        "nCount--",
        "IF nCount \u003c 0 .AND. rootWindow():hasDisplayFocus",
        "  lRequireLogin :\u003d .F.",
        "  nCount :\u003d 3",
        "  WriteUserOptions()",
        "  oThread :\u003d Thread():new()",
        "  Sleep(5)",
        "  oThread:start(\"Login\")",
        "  oThread:Synchronize(0)",
        "ENDIF",
        "",
        "IF nCount \u003c -4320         // Gone for over 12 hours ??"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027-\u0027 at 330454",
    "offset": 330454,
    "line": 9211,
    "column": 4,
    "evidence": {
      "startLine": 9201,
      "endLine": 9221,
      "focusLine": 9211,
      "lines": [
        "  RETURN",
        "ENDIF",
        "",
        "IF mParkMove\u003d\u003d\"P\"      // Parking timeout not done yet!",
        "  RETURN",
        "ENDIF",
        "IF IsSpecial()",
        "  RETURN",
        "ENDIF",
        "nCount--",
        "IF nCount \u003c 0 .AND. rootWindow():hasDisplayFocus",
        "  lRequireLogin :\u003d .F.",
        "  nCount :\u003d 3",
        "  WriteUserOptions()",
        "  oThread :\u003d Thread():new()",
        "  Sleep(5)",
        "  oThread:start(\"Login\")",
        "  oThread:Synchronize(0)",
        "ENDIF",
        "",
        "IF nCount \u003c -4320         // Gone for over 12 hours ??"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 330647",
    "offset": 330647,
    "line": 9219,
    "column": 1,
    "evidence": {
      "startLine": 9209,
      "endLine": 9229,
      "focusLine": 9219,
      "lines": [
        "ENDIF",
        "nCount--",
        "IF nCount \u003c 0 .AND. rootWindow():hasDisplayFocus",
        "  lRequireLogin :\u003d .F.",
        "  nCount :\u003d 3",
        "  WriteUserOptions()",
        "  oThread :\u003d Thread():new()",
        "  Sleep(5)",
        "  oThread:start(\"Login\")",
        "  oThread:Synchronize(0)",
        "ENDIF",
        "",
        "IF nCount \u003c -4320         // Gone for over 12 hours ??",
        "  AppQuit(.T.)",
        "ENDIF",
        "",
        "RETURN",
        "// EOP LogOutCheck",
        "",
        "//",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 331165",
    "offset": 331165,
    "line": 9246,
    "column": 1,
    "evidence": {
      "startLine": 9236,
      "endLine": 9256,
      "focusLine": 9246,
      "lines": [
        "ENDIF",
        "IF valtype(xCount)\u003d\"N\"        // A way to reset (or speed-up) the timer",
        "  nCount :\u003d xCount",
        "  RETURN",
        "ENDIF",
        "IF valType(nCount)\u003c\u003e\"N\"",
        "  nCount :\u003d 3          // 30 \u003d about 5 minutes for first news read!",
        "  RETURN",
        "ENDIF",
        "nCount--",
        "IF nCount \u003c 0",
        "//   WriteUserOptions()                Maybe we should save user options every 10 minutes ??",
        "  IF !mlInMessage",
        "    oThread :\u003d Thread():new()",
        "    Sleep(5)",
        "    oThread:start(\"ReadSEINews\")",
        "    nCount :\u003d 360    // then check about every hour!",
        "  ENDIF",
        "ENDIF",
        "",
        "RETURN"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027-\u0027 at 331168",
    "offset": 331168,
    "line": 9246,
    "column": 4,
    "evidence": {
      "startLine": 9236,
      "endLine": 9256,
      "focusLine": 9246,
      "lines": [
        "ENDIF",
        "IF valtype(xCount)\u003d\"N\"        // A way to reset (or speed-up) the timer",
        "  nCount :\u003d xCount",
        "  RETURN",
        "ENDIF",
        "IF valType(nCount)\u003c\u003e\"N\"",
        "  nCount :\u003d 3          // 30 \u003d about 5 minutes for first news read!",
        "  RETURN",
        "ENDIF",
        "nCount--",
        "IF nCount \u003c 0",
        "//   WriteUserOptions()                Maybe we should save user options every 10 minutes ??",
        "  IF !mlInMessage",
        "    oThread :\u003d Thread():new()",
        "    Sleep(5)",
        "    oThread:start(\"ReadSEINews\")",
        "    nCount :\u003d 360    // then check about every hour!",
        "  ENDIF",
        "ENDIF",
        "",
        "RETURN"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 331427",
    "offset": 331427,
    "line": 9254,
    "column": 1,
    "evidence": {
      "startLine": 9244,
      "endLine": 9264,
      "focusLine": 9254,
      "lines": [
        "ENDIF",
        "nCount--",
        "IF nCount \u003c 0",
        "//   WriteUserOptions()                Maybe we should save user options every 10 minutes ??",
        "  IF !mlInMessage",
        "    oThread :\u003d Thread():new()",
        "    Sleep(5)",
        "    oThread:start(\"ReadSEINews\")",
        "    nCount :\u003d 360    // then check about every hour!",
        "  ENDIF",
        "ENDIF",
        "",
        "RETURN",
        "// EOP NewsCheck",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE ListOut(aOList,cPre)",
        "LOCAL oThread",
        "  oThread :\u003d Thread():new()                         // Send an array to UCS as a flat file in a background thread",
        "  sleep(5)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 334929",
    "offset": 334929,
    "line": 9362,
    "column": 3,
    "evidence": {
      "startLine": 9352,
      "endLine": 9372,
      "focusLine": 9362,
      "lines": [
        "  AlertBox TEXT \"Set-Up custom printer codes?\" ;",
        "                 TO nReturn ;",
        "                 BUTTONS {\u0027NO\u0027,\u0027 YES \u0027};",
        "                 FONT FONT_TIMES_MEDIUM ;",
        "                 TIMEOUT 10             ;",
        "                 DEFAULTBUTTON 1        ;",
        "                 SYSICON \"?\"            ;",
        "                 TITLE \"PRINT SET-UP\"",
        "  IF nReturn \u003d\u003d 2",
        "    SetCustomPrintCodes()",
        "  ENDIF",
        "RETURN",
        "// EOP SetRawPrint",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE SetCustomPrintCodes()",
        "LOCAL oDlg, oDraw:\u003d{}, GetOptions, GetList:\u003d{}, IniFile, lineNo:\u003d1.5, oBoldOn, ;",
        "      aPrnCustomCodes[iniRawPC_len]",
        "",
        "PRIVATE bPutArray :\u003d {||PutCustomCodes( IniFile, aPrnCustomCodes )}, bUpDateTest"
      ]
    }
  },
  {
    "message": "Unexpected token LBRACKET at 335149",
    "offset": 335149,
    "line": 9370,
    "column": 22,
    "evidence": {
      "startLine": 9360,
      "endLine": 9380,
      "focusLine": 9370,
      "lines": [
        "  IF nReturn \u003d\u003d 2",
        "    SetCustomPrintCodes()",
        "  ENDIF",
        "RETURN",
        "// EOP SetRawPrint",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE SetCustomPrintCodes()",
        "LOCAL oDlg, oDraw:\u003d{}, GetOptions, GetList:\u003d{}, IniFile, lineNo:\u003d1.5, oBoldOn, ;",
        "      aPrnCustomCodes[iniRawPC_len]",
        "",
        "PRIVATE bPutArray :\u003d {||PutCustomCodes( IniFile, aPrnCustomCodes )}, bUpDateTest",
        "",
        "IniFile :\u003d TIniFile():New(RootPath()+\"court.ini\")   // Open or create COURT.INI",
        "cpcBoldOn      :\u003d IniFile:ReadString(\"CustomRawPrintCodes\",\"BoldOn\",\"\")",
        "cpcBoldOff     :\u003d IniFile:ReadString(\"CustomRawPrintCodes\",\"BoldOff\",\"\")",
        "cpcUnderOn     :\u003d IniFile:ReadString(\"CustomRawPrintCodes\",\"UnderOn\",\"\")",
        "cpcUnderOff    :\u003d IniFile:ReadString(\"CustomRawPrintCodes\",\"UnderOff\",\"\")",
        "cpcWideOn      :\u003d IniFile:ReadString(\"CustomRawPrintCodes\",\"WideOn\",\"\")",
        "cpcWideOff     :\u003d IniFile:ReadString(\"CustomRawPrintCodes\",\"WideOff\",\"\")"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 341232",
    "offset": 341232,
    "line": 9522,
    "column": 3,
    "evidence": {
      "startLine": 9512,
      "endLine": 9532,
      "focusLine": 9522,
      "lines": [
        "",
        "  GetList:\u003d{}",
        "  DestroyAll( @oDlg )",
        "  oDlg    :\u003d NIL",
        "",
        "",
        "  Scn_No(0)",
        "",
        "  IF lOK",
        "    PutCustomCodes( IniFile, aPrnCustomCodes )",
        "  ENDIF",
        "  IniDone(@IniFile)     // No more ini file stuff after this!",
        "",
        "RETURN",
        "// EOP SetCustomPrintCodes",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE CreateRegType(cNewPath,cNewName)",
        "v_Valtype(@cNewName,\"Reg_Type\")",
        "IF fExists(cNewPath+cNewName+\".DBF\")"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 345402",
    "offset": 345402,
    "line": 9679,
    "column": 11,
    "evidence": {
      "startLine": 9669,
      "endLine": 9689,
      "focusLine": 9679,
      "lines": [
        "OrderSet(\"C1\")",
        "IF !empty(xIndexNo)",
        "  seek substr(xIndexNo,1,9)",
        "  IF found() .AND. xCode$datecode .AND. IIF(empty(xjudge),.T.,xjudge\u003d\u003dcourtday-\u003ejudge)",
        "    FOR xx :\u003d 1 TO len(trim(datecode)) step 6",
        "      IF substr(datecode,xx,3)\u003d\u003dxCode",
        "        IF datepack(substr(datecode,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "             datepack(substr(datecode,xx+3,3))\u003c\u003dendDate",
        "          lOK:\u003d.T.",
        "          nCount++",
        "          IF valtype(aList)\u003d\u003d\"A\"",
        "            aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(datecode,xx+3,3))})",
        "          ENDIF",
        "          IF lOneTime",
        "            EXIT",
        "          ENDIF",
        "        ENDIF",
        "      ENDIF",
        "    NEXT",
        "  ENDIF",
        "ELSE"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 345405",
    "offset": 345405,
    "line": 9679,
    "column": 14,
    "evidence": {
      "startLine": 9669,
      "endLine": 9689,
      "focusLine": 9679,
      "lines": [
        "OrderSet(\"C1\")",
        "IF !empty(xIndexNo)",
        "  seek substr(xIndexNo,1,9)",
        "  IF found() .AND. xCode$datecode .AND. IIF(empty(xjudge),.T.,xjudge\u003d\u003dcourtday-\u003ejudge)",
        "    FOR xx :\u003d 1 TO len(trim(datecode)) step 6",
        "      IF substr(datecode,xx,3)\u003d\u003dxCode",
        "        IF datepack(substr(datecode,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "             datepack(substr(datecode,xx+3,3))\u003c\u003dendDate",
        "          lOK:\u003d.T.",
        "          nCount++",
        "          IF valtype(aList)\u003d\u003d\"A\"",
        "            aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(datecode,xx+3,3))})",
        "          ENDIF",
        "          IF lOneTime",
        "            EXIT",
        "          ENDIF",
        "        ENDIF",
        "      ENDIF",
        "    NEXT",
        "  ENDIF",
        "ELSE"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 345601",
    "offset": 345601,
    "line": 9686,
    "column": 7,
    "evidence": {
      "startLine": 9676,
      "endLine": 9696,
      "focusLine": 9686,
      "lines": [
        "             datepack(substr(datecode,xx+3,3))\u003c\u003dendDate",
        "          lOK:\u003d.T.",
        "          nCount++",
        "          IF valtype(aList)\u003d\u003d\"A\"",
        "            aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(datecode,xx+3,3))})",
        "          ENDIF",
        "          IF lOneTime",
        "            EXIT",
        "          ENDIF",
        "        ENDIF",
        "      ENDIF",
        "    NEXT",
        "  ENDIF",
        "ELSE",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF empty(xjudge) .OR. xjudge\u003d\u003dcourtday-\u003ejudge",
        "      FOR xx :\u003d 1 TO len(trim(datecode)) step 6",
        "        IF substr(datecode,xx,3)\u003d\u003dxCode",
        "          IF datepack(substr(datecode,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "               datepack(substr(datecode,xx+3,3))\u003c\u003dendDate"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 345975",
    "offset": 345975,
    "line": 9699,
    "column": 13,
    "evidence": {
      "startLine": 9689,
      "endLine": 9709,
      "focusLine": 9699,
      "lines": [
        "ELSE",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF empty(xjudge) .OR. xjudge\u003d\u003dcourtday-\u003ejudge",
        "      FOR xx :\u003d 1 TO len(trim(datecode)) step 6",
        "        IF substr(datecode,xx,3)\u003d\u003dxCode",
        "          IF datepack(substr(datecode,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "               datepack(substr(datecode,xx+3,3))\u003c\u003dendDate",
        "            lOK:\u003d.T.",
        "            nCount++",
        "            IF valtype(aList)\u003d\u003d\"A\"",
        "              aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(datecode,xx+3,3))})",
        "            ENDIF",
        "            IF lOneTime",
        "              EXIT",
        "            ENDIF",
        "          ENDIF",
        "        ENDIF",
        "      NEXT",
        "    ENDIF",
        "    skip"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 345978",
    "offset": 345978,
    "line": 9699,
    "column": 16,
    "evidence": {
      "startLine": 9689,
      "endLine": 9709,
      "focusLine": 9699,
      "lines": [
        "ELSE",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF empty(xjudge) .OR. xjudge\u003d\u003dcourtday-\u003ejudge",
        "      FOR xx :\u003d 1 TO len(trim(datecode)) step 6",
        "        IF substr(datecode,xx,3)\u003d\u003dxCode",
        "          IF datepack(substr(datecode,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "               datepack(substr(datecode,xx+3,3))\u003c\u003dendDate",
        "            lOK:\u003d.T.",
        "            nCount++",
        "            IF valtype(aList)\u003d\u003d\"A\"",
        "              aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(datecode,xx+3,3))})",
        "            ENDIF",
        "            IF lOneTime",
        "              EXIT",
        "            ENDIF",
        "          ENDIF",
        "        ENDIF",
        "      NEXT",
        "    ENDIF",
        "    skip"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 346188",
    "offset": 346188,
    "line": 9706,
    "column": 9,
    "evidence": {
      "startLine": 9696,
      "endLine": 9716,
      "focusLine": 9706,
      "lines": [
        "               datepack(substr(datecode,xx+3,3))\u003c\u003dendDate",
        "            lOK:\u003d.T.",
        "            nCount++",
        "            IF valtype(aList)\u003d\u003d\"A\"",
        "              aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(datecode,xx+3,3))})",
        "            ENDIF",
        "            IF lOneTime",
        "              EXIT",
        "            ENDIF",
        "          ENDIF",
        "        ENDIF",
        "      NEXT",
        "    ENDIF",
        "    skip",
        "  ENDDO",
        "ENDIF",
        "OrdSetfocus(oldOrder)  // Put things back the way they were",
        "dbGoTo(OldRec)",
        "SELE(oldArea)",
        "RETURN lOK",
        "// EOF GetHistoryCode"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 347278",
    "offset": 347278,
    "line": 9746,
    "column": 11,
    "evidence": {
      "startLine": 9736,
      "endLine": 9756,
      "focusLine": 9746,
      "lines": [
        "OrderSet(\"C1\")",
        "IF !empty(xIndexNo)",
        "  seek substr(xIndexNo,1,9)",
        "  IF found() .AND. xCode$LTRCODE .AND. IIF(empty(xjudge),.T.,xjudge\u003d\u003dcourtday-\u003ejudge)",
        "    FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "      IF substr(LTRCODE,xx,3)\u003d\u003dxCode",
        "        IF datepack(substr(LTRCODE,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "             datepack(substr(LTRCODE,xx+3,3))\u003c\u003dendDate",
        "          lOK:\u003d.T.",
        "          nCount++",
        "          IF valtype(aList)\u003d\u003d\"A\"",
        "            aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(LTRCODE,xx+3,3))})",
        "          ENDIF",
        "          IF lOneTime",
        "            EXIT",
        "          ENDIF",
        "        ENDIF",
        "      ENDIF",
        "    NEXT",
        "  ENDIF",
        "ELSE"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 347281",
    "offset": 347281,
    "line": 9746,
    "column": 14,
    "evidence": {
      "startLine": 9736,
      "endLine": 9756,
      "focusLine": 9746,
      "lines": [
        "OrderSet(\"C1\")",
        "IF !empty(xIndexNo)",
        "  seek substr(xIndexNo,1,9)",
        "  IF found() .AND. xCode$LTRCODE .AND. IIF(empty(xjudge),.T.,xjudge\u003d\u003dcourtday-\u003ejudge)",
        "    FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "      IF substr(LTRCODE,xx,3)\u003d\u003dxCode",
        "        IF datepack(substr(LTRCODE,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "             datepack(substr(LTRCODE,xx+3,3))\u003c\u003dendDate",
        "          lOK:\u003d.T.",
        "          nCount++",
        "          IF valtype(aList)\u003d\u003d\"A\"",
        "            aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(LTRCODE,xx+3,3))})",
        "          ENDIF",
        "          IF lOneTime",
        "            EXIT",
        "          ENDIF",
        "        ENDIF",
        "      ENDIF",
        "    NEXT",
        "  ENDIF",
        "ELSE"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 347476",
    "offset": 347476,
    "line": 9753,
    "column": 7,
    "evidence": {
      "startLine": 9743,
      "endLine": 9763,
      "focusLine": 9753,
      "lines": [
        "             datepack(substr(LTRCODE,xx+3,3))\u003c\u003dendDate",
        "          lOK:\u003d.T.",
        "          nCount++",
        "          IF valtype(aList)\u003d\u003d\"A\"",
        "            aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(LTRCODE,xx+3,3))})",
        "          ENDIF",
        "          IF lOneTime",
        "            EXIT",
        "          ENDIF",
        "        ENDIF",
        "      ENDIF",
        "    NEXT",
        "  ENDIF",
        "ELSE",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF empty(xjudge) .OR. xjudge\u003d\u003dcourtday-\u003ejudge",
        "      FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "        IF substr(LTRCODE,xx,3)\u003d\u003dxCode",
        "          IF datepack(substr(LTRCODE,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "               datepack(substr(LTRCODE,xx+3,3))\u003c\u003dendDate"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 347846",
    "offset": 347846,
    "line": 9766,
    "column": 13,
    "evidence": {
      "startLine": 9756,
      "endLine": 9776,
      "focusLine": 9766,
      "lines": [
        "ELSE",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF empty(xjudge) .OR. xjudge\u003d\u003dcourtday-\u003ejudge",
        "      FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "        IF substr(LTRCODE,xx,3)\u003d\u003dxCode",
        "          IF datepack(substr(LTRCODE,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "               datepack(substr(LTRCODE,xx+3,3))\u003c\u003dendDate",
        "            lOK:\u003d.T.",
        "            nCount++",
        "            IF valtype(aList)\u003d\u003d\"A\"",
        "              aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(LTRCODE,xx+3,3))})",
        "            ENDIF",
        "            IF lOneTime",
        "              EXIT",
        "            ENDIF",
        "          ENDIF",
        "        ENDIF",
        "      NEXT",
        "    ENDIF",
        "    skip"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 347849",
    "offset": 347849,
    "line": 9766,
    "column": 16,
    "evidence": {
      "startLine": 9756,
      "endLine": 9776,
      "focusLine": 9766,
      "lines": [
        "ELSE",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF empty(xjudge) .OR. xjudge\u003d\u003dcourtday-\u003ejudge",
        "      FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "        IF substr(LTRCODE,xx,3)\u003d\u003dxCode",
        "          IF datepack(substr(LTRCODE,xx+3,3))\u003e\u003dstartDate .AND. ;",
        "               datepack(substr(LTRCODE,xx+3,3))\u003c\u003dendDate",
        "            lOK:\u003d.T.",
        "            nCount++",
        "            IF valtype(aList)\u003d\u003d\"A\"",
        "              aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(LTRCODE,xx+3,3))})",
        "            ENDIF",
        "            IF lOneTime",
        "              EXIT",
        "            ENDIF",
        "          ENDIF",
        "        ENDIF",
        "      NEXT",
        "    ENDIF",
        "    skip"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 348058",
    "offset": 348058,
    "line": 9773,
    "column": 9,
    "evidence": {
      "startLine": 9763,
      "endLine": 9783,
      "focusLine": 9773,
      "lines": [
        "               datepack(substr(LTRCODE,xx+3,3))\u003c\u003dendDate",
        "            lOK:\u003d.T.",
        "            nCount++",
        "            IF valtype(aList)\u003d\u003d\"A\"",
        "              aAdd(aList,{courtday-\u003eindex_no,xCode,datepack(substr(LTRCODE,xx+3,3))})",
        "            ENDIF",
        "            IF lOneTime",
        "              EXIT",
        "            ENDIF",
        "          ENDIF",
        "        ENDIF",
        "      NEXT",
        "    ENDIF",
        "    skip",
        "  ENDDO",
        "ENDIF",
        "OrdSetfocus(oldOrder)  // Put things back the way they were",
        "dbGoTo(OldRec)",
        "SELE(oldArea)",
        "RETURN lOK",
        "// EOF GetLetterCode"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 348730",
    "offset": 348730,
    "line": 9801,
    "column": 7,
    "evidence": {
      "startLine": 9791,
      "endLine": 9811,
      "focusLine": 9801,
      "lines": [
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of letters used.;Please wait...;\u0027,reccount(),1,\"LETTER HISTORY\")",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "    cCode :\u003d substr(LTRCODE,xx,3)",
        "    dUsed :\u003d datepack(substr(LTRCODE,xx+3,3))",
        "    yy :\u003d aScan(aLtrs,{|x| x[1]\u003d\u003dcCode})",
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "      aLtrs[yy,5]++",
        "      IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aLtrs[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aLtrs[yy,4]",
        "        aLtrs[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 348733",
    "offset": 348733,
    "line": 9801,
    "column": 10,
    "evidence": {
      "startLine": 9791,
      "endLine": 9811,
      "focusLine": 9801,
      "lines": [
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of letters used.;Please wait...;\u0027,reccount(),1,\"LETTER HISTORY\")",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "    cCode :\u003d substr(LTRCODE,xx,3)",
        "    dUsed :\u003d datepack(substr(LTRCODE,xx+3,3))",
        "    yy :\u003d aScan(aLtrs,{|x| x[1]\u003d\u003dcCode})",
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "      aLtrs[yy,5]++",
        "      IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aLtrs[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aLtrs[yy,4]",
        "        aLtrs[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 348893",
    "offset": 348893,
    "line": 9807,
    "column": 5,
    "evidence": {
      "startLine": 9797,
      "endLine": 9817,
      "focusLine": 9807,
      "lines": [
        "    dUsed :\u003d datepack(substr(LTRCODE,xx+3,3))",
        "    yy :\u003d aScan(aLtrs,{|x| x[1]\u003d\u003dcCode})",
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "      aLtrs[yy,5]++",
        "      IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aLtrs[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aLtrs[yy,4]",
        "        aLtrs[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()",
        "  skip",
        "ENDDO",
        "ReptProgress(\"KILL\")",
        "",
        "select(0)",
        "IF fExists(datapath()+\"PARKDAY.DBF\") .AND. net_use(\u0027PARKDAY\u0027,.F.,5,\"pday\")"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 348953",
    "offset": 348953,
    "line": 9809,
    "column": 5,
    "evidence": {
      "startLine": 9799,
      "endLine": 9819,
      "focusLine": 9809,
      "lines": [
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "      aLtrs[yy,5]++",
        "      IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aLtrs[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aLtrs[yy,4]",
        "        aLtrs[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()",
        "  skip",
        "ENDDO",
        "ReptProgress(\"KILL\")",
        "",
        "select(0)",
        "IF fExists(datapath()+\"PARKDAY.DBF\") .AND. net_use(\u0027PARKDAY\u0027,.F.,5,\"pday\")",
        "  ReptProgress(\u0027;Gathering history of parking letters used.;Please wait...;\u0027,reccount(),1,\"PARKING LETTER HISTORY\")",
        "  dbGoTop()"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 349489",
    "offset": 349489,
    "line": 9827,
    "column": 9,
    "evidence": {
      "startLine": 9817,
      "endLine": 9837,
      "focusLine": 9827,
      "lines": [
        "IF fExists(datapath()+\"PARKDAY.DBF\") .AND. net_use(\u0027PARKDAY\u0027,.F.,5,\"pday\")",
        "  ReptProgress(\u0027;Gathering history of parking letters used.;Please wait...;\u0027,reccount(),1,\"PARKING LETTER HISTORY\")",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "      cCode :\u003d substr(LTRCODE,xx,3)",
        "      dUsed :\u003d datepack(substr(LTRCODE,xx+3,3))",
        "      yy :\u003d aScan(aLtrs,{|x| x[1]\u003d\u003dcCode})",
        "      IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "        aLtrs[yy,5]++",
        "        IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "          aLtrs[yy,3] :\u003d dUsed",
        "        ENDIF",
        "        IF dUsed \u003e aLtrs[yy,4]",
        "          aLtrs[yy,4] :\u003d dUsed",
        "        ENDIF",
        "      ELSE",
        "        aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "      ENDIF",
        "    NEXT",
        "    ReptProgress()"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 349492",
    "offset": 349492,
    "line": 9827,
    "column": 12,
    "evidence": {
      "startLine": 9817,
      "endLine": 9837,
      "focusLine": 9827,
      "lines": [
        "IF fExists(datapath()+\"PARKDAY.DBF\") .AND. net_use(\u0027PARKDAY\u0027,.F.,5,\"pday\")",
        "  ReptProgress(\u0027;Gathering history of parking letters used.;Please wait...;\u0027,reccount(),1,\"PARKING LETTER HISTORY\")",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "      cCode :\u003d substr(LTRCODE,xx,3)",
        "      dUsed :\u003d datepack(substr(LTRCODE,xx+3,3))",
        "      yy :\u003d aScan(aLtrs,{|x| x[1]\u003d\u003dcCode})",
        "      IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "        aLtrs[yy,5]++",
        "        IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "          aLtrs[yy,3] :\u003d dUsed",
        "        ENDIF",
        "        IF dUsed \u003e aLtrs[yy,4]",
        "          aLtrs[yy,4] :\u003d dUsed",
        "        ENDIF",
        "      ELSE",
        "        aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "      ENDIF",
        "    NEXT",
        "    ReptProgress()"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 349664",
    "offset": 349664,
    "line": 9833,
    "column": 7,
    "evidence": {
      "startLine": 9823,
      "endLine": 9843,
      "focusLine": 9833,
      "lines": [
        "      dUsed :\u003d datepack(substr(LTRCODE,xx+3,3))",
        "      yy :\u003d aScan(aLtrs,{|x| x[1]\u003d\u003dcCode})",
        "      IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "        aLtrs[yy,5]++",
        "        IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "          aLtrs[yy,3] :\u003d dUsed",
        "        ENDIF",
        "        IF dUsed \u003e aLtrs[yy,4]",
        "          aLtrs[yy,4] :\u003d dUsed",
        "        ENDIF",
        "      ELSE",
        "        aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "      ENDIF",
        "    NEXT",
        "    ReptProgress()",
        "    skip",
        "  ENDDO",
        "  ReptProgress(\"KILL\")",
        "  USE",
        "ENDIF",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 349728",
    "offset": 349728,
    "line": 9835,
    "column": 7,
    "evidence": {
      "startLine": 9825,
      "endLine": 9845,
      "focusLine": 9835,
      "lines": [
        "      IF yy \u003e 0 .AND. yy\u003c\u003d len(aLtrs)",
        "        aLtrs[yy,5]++",
        "        IF dUsed \u003c aLtrs[yy,3] .AND. year(dUsed) \u003e 1950",
        "          aLtrs[yy,3] :\u003d dUsed",
        "        ENDIF",
        "        IF dUsed \u003e aLtrs[yy,4]",
        "          aLtrs[yy,4] :\u003d dUsed",
        "        ENDIF",
        "      ELSE",
        "        aAdd(aLtrs,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "      ENDIF",
        "    NEXT",
        "    ReptProgress()",
        "    skip",
        "  ENDDO",
        "  ReptProgress(\"KILL\")",
        "  USE",
        "ENDIF",
        "",
        "select(0)",
        "IF !fExists(datapath()+\"CLETTERS.DBF\") .OR. !net_use(\u0027CLETTERS\u0027,.F.,5,\"Ltr\")"
      ]
    }
  },
  {
    "message": "Unexpected token IF at 351086",
    "offset": 351086,
    "line": 9885,
    "column": 7,
    "evidence": {
      "startLine": 9875,
      "endLine": 9895,
      "focusLine": 9885,
      "lines": [
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of action codes used.;Please wait...;\u0027,reccount(),1,\"CODE HISTORY\")",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(DATECODE)) step 6",
        "    cCode :\u003d substr(DATECODE,xx,3)",
        "    dUsed :\u003d datepack(substr(DATECODE,xx+3,3))",
        "    yy :\u003d aScan(aCodes,{|x| x[1]\u003d\u003dcCode})",
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aCodes)",
        "      aCodes[yy,5]++",
        "      IF dUsed \u003c aCodes[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aCodes[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aCodes[yy,4]",
        "        aCodes[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aCodes,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 351089",
    "offset": 351089,
    "line": 9885,
    "column": 10,
    "evidence": {
      "startLine": 9875,
      "endLine": 9895,
      "focusLine": 9885,
      "lines": [
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of action codes used.;Please wait...;\u0027,reccount(),1,\"CODE HISTORY\")",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(DATECODE)) step 6",
        "    cCode :\u003d substr(DATECODE,xx,3)",
        "    dUsed :\u003d datepack(substr(DATECODE,xx+3,3))",
        "    yy :\u003d aScan(aCodes,{|x| x[1]\u003d\u003dcCode})",
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aCodes)",
        "      aCodes[yy,5]++",
        "      IF dUsed \u003c aCodes[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aCodes[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aCodes[yy,4]",
        "        aCodes[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aCodes,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 351253",
    "offset": 351253,
    "line": 9891,
    "column": 5,
    "evidence": {
      "startLine": 9881,
      "endLine": 9901,
      "focusLine": 9891,
      "lines": [
        "    dUsed :\u003d datepack(substr(DATECODE,xx+3,3))",
        "    yy :\u003d aScan(aCodes,{|x| x[1]\u003d\u003dcCode})",
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aCodes)",
        "      aCodes[yy,5]++",
        "      IF dUsed \u003c aCodes[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aCodes[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aCodes[yy,4]",
        "        aCodes[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aCodes,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()",
        "  skip",
        "ENDDO",
        "ReptProgress(\"KILL\")",
        "select(0)",
        "IF !fExists(datapath()+\"STATCODE.DBF\") .OR. !net_use(\u0027STATCODE\u0027,.F.,5,\"scd\")",
        "  InfoBox(\"StatCode Database not available, try again later!...\",;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 351314",
    "offset": 351314,
    "line": 9893,
    "column": 5,
    "evidence": {
      "startLine": 9883,
      "endLine": 9903,
      "focusLine": 9893,
      "lines": [
        "    IF yy \u003e 0 .AND. yy\u003c\u003d len(aCodes)",
        "      aCodes[yy,5]++",
        "      IF dUsed \u003c aCodes[yy,3] .AND. year(dUsed) \u003e 1950",
        "        aCodes[yy,3] :\u003d dUsed",
        "      ENDIF",
        "      IF dUsed \u003e aCodes[yy,4]",
        "        aCodes[yy,4] :\u003d dUsed",
        "      ENDIF",
        "    ELSE",
        "      aAdd(aCodes,{cCode,\" - n/a -\",dUsed,dUsed,1})",
        "    ENDIF",
        "  NEXT",
        "  ReptProgress()",
        "  skip",
        "ENDDO",
        "ReptProgress(\"KILL\")",
        "select(0)",
        "IF !fExists(datapath()+\"STATCODE.DBF\") .OR. !net_use(\u0027STATCODE\u0027,.F.,5,\"scd\")",
        "  InfoBox(\"StatCode Database not available, try again later!...\",;",
        "               \"STATCODE.DBF PROBLEM\")",
        "ELSE"
      ]
    }
  },
  {
    "message": "Expected \u0027:\u003d\u0027 after FOR iterator at 352615",
    "offset": 352615,
    "line": 9939,
    "column": 17,
    "evidence": {
      "startLine": 9929,
      "endLine": 9949,
      "focusLine": 9939,
      "lines": [
        "PRIVATE aProgress",
        "",
        "v_Valtype(@lSort,.F.)",
        "IF Valtype(czCode)\u003c\u003e\"C\" .OR. val(czCode)\u003c1",
        "  RETURN aCodes",
        "ENDIF",
        "czCode :\u003d right(\"000\"+alltrim(czCode),3)",
        "CodeTxt :\u003d \u0027Unknown\u0027",
        "select(0)",
        "IF fExists(datapath()+\"STATCODE.DBF\") .AND. net_use(\u0027STATCODE\u0027,.F.,5,\"scd\")",
        "  LOCATE FOR scd-\u003eCODE \u003d\u003d czCode",
        "  IF FOUND()",
        "    CodeTxt :\u003d alltrim(scd-\u003eCODE_TXT)",
        "  ENDIF",
        "  USE",
        "ENDIF",
        "",
        "aCodes :\u003d {czCode,CodeTxt,{}}",
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of action code - \u0027+czCode+\u0027.;Please wait...;\u0027,;"
      ]
    }
  },
  {
    "message": "Unexpected token ARROW at 352615",
    "offset": 352615,
    "line": 9939,
    "column": 17,
    "evidence": {
      "startLine": 9929,
      "endLine": 9949,
      "focusLine": 9939,
      "lines": [
        "PRIVATE aProgress",
        "",
        "v_Valtype(@lSort,.F.)",
        "IF Valtype(czCode)\u003c\u003e\"C\" .OR. val(czCode)\u003c1",
        "  RETURN aCodes",
        "ENDIF",
        "czCode :\u003d right(\"000\"+alltrim(czCode),3)",
        "CodeTxt :\u003d \u0027Unknown\u0027",
        "select(0)",
        "IF fExists(datapath()+\"STATCODE.DBF\") .AND. net_use(\u0027STATCODE\u0027,.F.,5,\"scd\")",
        "  LOCATE FOR scd-\u003eCODE \u003d\u003d czCode",
        "  IF FOUND()",
        "    CodeTxt :\u003d alltrim(scd-\u003eCODE_TXT)",
        "  ENDIF",
        "  USE",
        "ENDIF",
        "",
        "aCodes :\u003d {czCode,CodeTxt,{}}",
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of action code - \u0027+czCode+\u0027.;Please wait...;\u0027,;"
      ]
    }
  },
  {
    "message": "Expected start expression after \u0027:\u003d\u0027 at 352617",
    "offset": 352617,
    "line": 9939,
    "column": 19,
    "evidence": {
      "startLine": 9929,
      "endLine": 9949,
      "focusLine": 9939,
      "lines": [
        "PRIVATE aProgress",
        "",
        "v_Valtype(@lSort,.F.)",
        "IF Valtype(czCode)\u003c\u003e\"C\" .OR. val(czCode)\u003c1",
        "  RETURN aCodes",
        "ENDIF",
        "czCode :\u003d right(\"000\"+alltrim(czCode),3)",
        "CodeTxt :\u003d \u0027Unknown\u0027",
        "select(0)",
        "IF fExists(datapath()+\"STATCODE.DBF\") .AND. net_use(\u0027STATCODE\u0027,.F.,5,\"scd\")",
        "  LOCATE FOR scd-\u003eCODE \u003d\u003d czCode",
        "  IF FOUND()",
        "    CodeTxt :\u003d alltrim(scd-\u003eCODE_TXT)",
        "  ENDIF",
        "  USE",
        "ENDIF",
        "",
        "aCodes :\u003d {czCode,CodeTxt,{}}",
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of action code - \u0027+czCode+\u0027.;Please wait...;\u0027,;"
      ]
    }
  },
  {
    "message": "Expected TO in FOR statement at 352617",
    "offset": 352617,
    "line": 9939,
    "column": 19,
    "evidence": {
      "startLine": 9929,
      "endLine": 9949,
      "focusLine": 9939,
      "lines": [
        "PRIVATE aProgress",
        "",
        "v_Valtype(@lSort,.F.)",
        "IF Valtype(czCode)\u003c\u003e\"C\" .OR. val(czCode)\u003c1",
        "  RETURN aCodes",
        "ENDIF",
        "czCode :\u003d right(\"000\"+alltrim(czCode),3)",
        "CodeTxt :\u003d \u0027Unknown\u0027",
        "select(0)",
        "IF fExists(datapath()+\"STATCODE.DBF\") .AND. net_use(\u0027STATCODE\u0027,.F.,5,\"scd\")",
        "  LOCATE FOR scd-\u003eCODE \u003d\u003d czCode",
        "  IF FOUND()",
        "    CodeTxt :\u003d alltrim(scd-\u003eCODE_TXT)",
        "  ENDIF",
        "  USE",
        "ENDIF",
        "",
        "aCodes :\u003d {czCode,CodeTxt,{}}",
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of action code - \u0027+czCode+\u0027.;Please wait...;\u0027,;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 352697",
    "offset": 352697,
    "line": 9944,
    "column": 1,
    "evidence": {
      "startLine": 9934,
      "endLine": 9954,
      "focusLine": 9944,
      "lines": [
        "ENDIF",
        "czCode :\u003d right(\"000\"+alltrim(czCode),3)",
        "CodeTxt :\u003d \u0027Unknown\u0027",
        "select(0)",
        "IF fExists(datapath()+\"STATCODE.DBF\") .AND. net_use(\u0027STATCODE\u0027,.F.,5,\"scd\")",
        "  LOCATE FOR scd-\u003eCODE \u003d\u003d czCode",
        "  IF FOUND()",
        "    CodeTxt :\u003d alltrim(scd-\u003eCODE_TXT)",
        "  ENDIF",
        "  USE",
        "ENDIF",
        "",
        "aCodes :\u003d {czCode,CodeTxt,{}}",
        "OrderSet(\"C1\")",
        "dbGoTop()",
        "ReptProgress(\u0027;Gathering history of action code - \u0027+czCode+\u0027.;Please wait...;\u0027,;",
        "                    reccount(),1,\"CODE USAGE HISTORY\")",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(DATECODE)) step 6",
        "    IF czCode\u003d\u003dsubstr(DATECODE,xx,3) .AND. (empty(aCodes[3]) .OR. ;",
        "               aScan(aCodes[3],{|x| x[1]\u003d\u003dcourtday-\u003eINDEX_NO .AND. x[2]\u003d\u003ddatepack(substr(courtday-\u003eDATECODE,xx+3,3))})\u003d0)"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 353723",
    "offset": 353723,
    "line": 9981,
    "column": 5,
    "evidence": {
      "startLine": 9971,
      "endLine": 9991,
      "focusLine": 9981,
      "lines": [
        "FUNCTION CountLettersSent(xyr)",
        "LOCAL xx, nCount:\u003d0",
        "",
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "    IF year(datepack(substr(LTRCODE,xx+3,3))) \u003d xyr",
        "      nCount++",
        "    ENDIF",
        "  NEXT",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "// Enter with PARKING open",
        "FUNCTION CountParkLettersSent(xyr)"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 353731",
    "offset": 353731,
    "line": 9982,
    "column": 3,
    "evidence": {
      "startLine": 9972,
      "endLine": 9992,
      "focusLine": 9982,
      "lines": [
        "LOCAL xx, nCount:\u003d0",
        "",
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "    IF year(datepack(substr(LTRCODE,xx+3,3))) \u003d xyr",
        "      nCount++",
        "    ENDIF",
        "  NEXT",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "// Enter with PARKING open",
        "FUNCTION CountParkLettersSent(xyr)",
        "LOCAL xx, nCount:\u003d0"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 353731",
    "offset": 353731,
    "line": 9982,
    "column": 3,
    "evidence": {
      "startLine": 9972,
      "endLine": 9992,
      "focusLine": 9982,
      "lines": [
        "LOCAL xx, nCount:\u003d0",
        "",
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "    IF year(datepack(substr(LTRCODE,xx+3,3))) \u003d xyr",
        "      nCount++",
        "    ENDIF",
        "  NEXT",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "// Enter with PARKING open",
        "FUNCTION CountParkLettersSent(xyr)",
        "LOCAL xx, nCount:\u003d0"
      ]
    }
  },
  {
    "message": "Unexpected ENDDO at 353743",
    "offset": 353743,
    "line": 9984,
    "column": 1,
    "evidence": {
      "startLine": 9974,
      "endLine": 9994,
      "focusLine": 9984,
      "lines": [
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  FOR xx :\u003d 1 TO len(trim(LTRCODE)) step 6",
        "    IF year(datepack(substr(LTRCODE,xx+3,3))) \u003d xyr",
        "      nCount++",
        "    ENDIF",
        "  NEXT",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "// Enter with PARKING open",
        "FUNCTION CountParkLettersSent(xyr)",
        "LOCAL xx, nCount:\u003d0",
        "",
        "v_Valtype(@xyr,year(date()))"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 354026",
    "offset": 354026,
    "line": 10000,
    "column": 3,
    "evidence": {
      "startLine": 9990,
      "endLine": 10010,
      "focusLine": 10000,
      "lines": [
        "// Enter with PARKING open",
        "FUNCTION CountParkLettersSent(xyr)",
        "LOCAL xx, nCount:\u003d0",
        "",
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  IF year(parking-\u003eLTR1) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 354034",
    "offset": 354034,
    "line": 10001,
    "column": 3,
    "evidence": {
      "startLine": 9991,
      "endLine": 10011,
      "focusLine": 10001,
      "lines": [
        "FUNCTION CountParkLettersSent(xyr)",
        "LOCAL xx, nCount:\u003d0",
        "",
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  IF year(parking-\u003eLTR1) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 354078",
    "offset": 354078,
    "line": 10003,
    "column": 3,
    "evidence": {
      "startLine": 9993,
      "endLine": 10013,
      "focusLine": 10003,
      "lines": [
        "",
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  IF year(parking-\u003eLTR1) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountParkLettersSent"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 354086",
    "offset": 354086,
    "line": 10004,
    "column": 3,
    "evidence": {
      "startLine": 9994,
      "endLine": 10014,
      "focusLine": 10004,
      "lines": [
        "v_Valtype(@xyr,year(date()))",
        "",
        "dbGoTop()",
        "DO WHILE !eof()",
        "  IF year(parking-\u003eLTR1) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountParkLettersSent",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 354130",
    "offset": 354130,
    "line": 10006,
    "column": 3,
    "evidence": {
      "startLine": 9996,
      "endLine": 10016,
      "focusLine": 10006,
      "lines": [
        "dbGoTop()",
        "DO WHILE !eof()",
        "  IF year(parking-\u003eLTR1) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountParkLettersSent",
        "",
        "//",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 354138",
    "offset": 354138,
    "line": 10007,
    "column": 3,
    "evidence": {
      "startLine": 9997,
      "endLine": 10017,
      "focusLine": 10007,
      "lines": [
        "DO WHILE !eof()",
        "  IF year(parking-\u003eLTR1) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountParkLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION NextDToC(InDate,outLen)"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 354183",
    "offset": 354183,
    "line": 10009,
    "column": 3,
    "evidence": {
      "startLine": 9999,
      "endLine": 10019,
      "focusLine": 10009,
      "lines": [
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountParkLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION NextDToC(InDate,outLen)",
        "LOCAL cOut",
        "v_valtype(@outLen,10,@InDate,\"\")"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 354191",
    "offset": 354191,
    "line": 10010,
    "column": 3,
    "evidence": {
      "startLine": 10000,
      "endLine": 10020,
      "focusLine": 10010,
      "lines": [
        "  ENDIF",
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountParkLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION NextDToC(InDate,outLen)",
        "LOCAL cOut",
        "v_valtype(@outLen,10,@InDate,\"\")",
        "IF InDate \u003d \"\u003c\" .AND. substr(InDate,2,2)\u003c\u003e\u0027  \u0027"
      ]
    }
  },
  {
    "message": "Unexpected ENDDO at 354196",
    "offset": 354196,
    "line": 10011,
    "column": 1,
    "evidence": {
      "startLine": 10001,
      "endLine": 10021,
      "focusLine": 10011,
      "lines": [
        "  IF year(parking-\u003eLTR2) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eLTR3) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  IF year(parking-\u003eC_LTR) \u003d xyr",
        "    nCount++",
        "  ENDIF",
        "  skip",
        "ENDDO",
        "RETURN nCount",
        "// EOF CountParkLettersSent",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION NextDToC(InDate,outLen)",
        "LOCAL cOut",
        "v_valtype(@outLen,10,@InDate,\"\")",
        "IF InDate \u003d \"\u003c\" .AND. substr(InDate,2,2)\u003c\u003e\u0027  \u0027",
        "  cOut :\u003d stod(IIF(val(substr(InDate,2,2))\u003e50,\u002719\u0027,\u002720\u0027)+substr(InDate,2,6))"
      ]
    }
  },
  {
    "message": "Unexpected token BREAK at 355769",
    "offset": 355769,
    "line": 10070,
    "column": 28,
    "evidence": {
      "startLine": 10060,
      "endLine": 10080,
      "focusLine": 10070,
      "lines": [
        "RETURN",
        "// EOP ColonFixer",
        "",
        "//        New way traps individual errors",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseAll(lFirstTry)",
        "LOCAL bError, aWS, i, cErrDBF:\u003d\"\"",
        "",
        "v_ValType(@lFirstTry,.T.)",
        "Sleep(4)",
        "bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "aWS :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]"
      ]
    }
  },
  {
    "message": "Expected expression in block literal at 355774",
    "offset": 355774,
    "line": 10070,
    "column": 33,
    "evidence": {
      "startLine": 10060,
      "endLine": 10080,
      "focusLine": 10070,
      "lines": [
        "RETURN",
        "// EOP ColonFixer",
        "",
        "//        New way traps individual errors",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseAll(lFirstTry)",
        "LOCAL bError, aWS, i, cErrDBF:\u003d\"\"",
        "",
        "v_ValType(@lFirstTry,.T.)",
        "Sleep(4)",
        "bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "aWS :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 355774",
    "offset": 355774,
    "line": 10070,
    "column": 33,
    "evidence": {
      "startLine": 10060,
      "endLine": 10080,
      "focusLine": 10070,
      "lines": [
        "RETURN",
        "// EOP ColonFixer",
        "",
        "//        New way traps individual errors",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseAll(lFirstTry)",
        "LOCAL bError, aWS, i, cErrDBF:\u003d\"\"",
        "",
        "v_ValType(@lFirstTry,.T.)",
        "Sleep(4)",
        "bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "aWS :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 355777",
    "offset": 355777,
    "line": 10070,
    "column": 36,
    "evidence": {
      "startLine": 10060,
      "endLine": 10080,
      "focusLine": 10070,
      "lines": [
        "RETURN",
        "// EOP ColonFixer",
        "",
        "//        New way traps individual errors",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseAll(lFirstTry)",
        "LOCAL bError, aWS, i, cErrDBF:\u003d\"\"",
        "",
        "v_ValType(@lFirstTry,.T.)",
        "Sleep(4)",
        "bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "aWS :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]"
      ]
    }
  },
  {
    "message": "Unexpected token RBRACE at 355777",
    "offset": 355777,
    "line": 10070,
    "column": 36,
    "evidence": {
      "startLine": 10060,
      "endLine": 10080,
      "focusLine": 10070,
      "lines": [
        "RETURN",
        "// EOP ColonFixer",
        "",
        "//        New way traps individual errors",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseAll(lFirstTry)",
        "LOCAL bError, aWS, i, cErrDBF:\u003d\"\"",
        "",
        "v_ValType(@lFirstTry,.T.)",
        "Sleep(4)",
        "bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "aWS :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]"
      ]
    }
  },
  {
    "message": "Unexpected RECOVER at 356011",
    "offset": 356011,
    "line": 10077,
    "column": 3,
    "evidence": {
      "startLine": 10067,
      "endLine": 10087,
      "focusLine": 10077,
      "lines": [
        "",
        "v_ValType(@lFirstTry,.T.)",
        "Sleep(4)",
        "bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "aWS :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]",
        "  ENDSEQUENCE",
        "NEXT",
        "ErrorBlock( bError )",
        "",
        "IF !empty(cErrDBF)",
        "  InfoBox(\"There appears to have been a problem;while closing the data files!;\"+;",
        "                 cErrDBF+\";;Please check the work you just finished.\")"
      ]
    }
  },
  {
    "message": "Unexpected token ARROW at 356031",
    "offset": 356031,
    "line": 10078,
    "column": 13,
    "evidence": {
      "startLine": 10068,
      "endLine": 10088,
      "focusLine": 10078,
      "lines": [
        "v_ValType(@lFirstTry,.T.)",
        "Sleep(4)",
        "bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "aWS :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]",
        "  ENDSEQUENCE",
        "NEXT",
        "ErrorBlock( bError )",
        "",
        "IF !empty(cErrDBF)",
        "  InfoBox(\"There appears to have been a problem;while closing the data files!;\"+;",
        "                 cErrDBF+\";;Please check the work you just finished.\")",
        "ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 356121",
    "offset": 356121,
    "line": 10082,
    "column": 1,
    "evidence": {
      "startLine": 10072,
      "endLine": 10092,
      "focusLine": 10082,
      "lines": [
        "FOR i:\u003d 1 TO len(aWS)",
        "  BEGIN SEQUENCE      // Force all pending record updates to be committed in the current workspace",
        "    (aWS[i])-\u003e(DbCommit())",
        "    (aWS[i])-\u003e(DbUnlock())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "  RECOVER",
        "    (aWS[i])-\u003e(DbRRollback())",
        "    (aWS[i])-\u003e(DbCloseArea())",
        "    cErrDBF +\u003d \";  \"+aWS[i]",
        "  ENDSEQUENCE",
        "NEXT",
        "ErrorBlock( bError )",
        "",
        "IF !empty(cErrDBF)",
        "  InfoBox(\"There appears to have been a problem;while closing the data files!;\"+;",
        "                 cErrDBF+\";;Please check the work you just finished.\")",
        "ENDIF",
        "",
        "IF !empty(WorkSpaceList())",
        "  IF lFirstTry        // Give it one more try",
        "    TW_CloseAll(.F.)"
      ]
    }
  },
  {
    "message": "Unexpected token BREAK at 356660",
    "offset": 356660,
    "line": 10104,
    "column": 34,
    "evidence": {
      "startLine": 10094,
      "endLine": 10114,
      "focusLine": 10104,
      "lines": [
        "    InfoBox(\"Data files did not close after two attempts\")",
        "  ENDIF",
        "ENDIF",
        "dbSelectArea(1)",
        "RETURN",
        "// EOF TW_CloseAll",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseOne(lQuiet)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "v_valtype(@lQuiet,.F.)",
        "Sleep(5)",
        "BEGIN SEQUENCE",
        "  USE",
        "RECOVER",
        "  IF !lQuiet",
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)"
      ]
    }
  },
  {
    "message": "Expected expression in block literal at 356665",
    "offset": 356665,
    "line": 10104,
    "column": 39,
    "evidence": {
      "startLine": 10094,
      "endLine": 10114,
      "focusLine": 10104,
      "lines": [
        "    InfoBox(\"Data files did not close after two attempts\")",
        "  ENDIF",
        "ENDIF",
        "dbSelectArea(1)",
        "RETURN",
        "// EOF TW_CloseAll",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseOne(lQuiet)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "v_valtype(@lQuiet,.F.)",
        "Sleep(5)",
        "BEGIN SEQUENCE",
        "  USE",
        "RECOVER",
        "  IF !lQuiet",
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 356665",
    "offset": 356665,
    "line": 10104,
    "column": 39,
    "evidence": {
      "startLine": 10094,
      "endLine": 10114,
      "focusLine": 10104,
      "lines": [
        "    InfoBox(\"Data files did not close after two attempts\")",
        "  ENDIF",
        "ENDIF",
        "dbSelectArea(1)",
        "RETURN",
        "// EOF TW_CloseAll",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseOne(lQuiet)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "v_valtype(@lQuiet,.F.)",
        "Sleep(5)",
        "BEGIN SEQUENCE",
        "  USE",
        "RECOVER",
        "  IF !lQuiet",
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 356668",
    "offset": 356668,
    "line": 10104,
    "column": 42,
    "evidence": {
      "startLine": 10094,
      "endLine": 10114,
      "focusLine": 10104,
      "lines": [
        "    InfoBox(\"Data files did not close after two attempts\")",
        "  ENDIF",
        "ENDIF",
        "dbSelectArea(1)",
        "RETURN",
        "// EOF TW_CloseAll",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseOne(lQuiet)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "v_valtype(@lQuiet,.F.)",
        "Sleep(5)",
        "BEGIN SEQUENCE",
        "  USE",
        "RECOVER",
        "  IF !lQuiet",
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)"
      ]
    }
  },
  {
    "message": "Unexpected token RBRACE at 356668",
    "offset": 356668,
    "line": 10104,
    "column": 42,
    "evidence": {
      "startLine": 10094,
      "endLine": 10114,
      "focusLine": 10104,
      "lines": [
        "    InfoBox(\"Data files did not close after two attempts\")",
        "  ENDIF",
        "ENDIF",
        "dbSelectArea(1)",
        "RETURN",
        "// EOF TW_CloseAll",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseOne(lQuiet)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "v_valtype(@lQuiet,.F.)",
        "Sleep(5)",
        "BEGIN SEQUENCE",
        "  USE",
        "RECOVER",
        "  IF !lQuiet",
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)"
      ]
    }
  },
  {
    "message": "Unexpected RECOVER at 356725",
    "offset": 356725,
    "line": 10109,
    "column": 1,
    "evidence": {
      "startLine": 10099,
      "endLine": 10119,
      "focusLine": 10109,
      "lines": [
        "// EOF TW_CloseAll",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE TW_CloseOne(lQuiet)",
        "LOCAL bError :\u003d ErrorBlock( {|e| Break(e)} )",
        "v_valtype(@lQuiet,.F.)",
        "Sleep(5)",
        "BEGIN SEQUENCE",
        "  USE",
        "RECOVER",
        "  IF !lQuiet",
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)",
        "RETURN",
        "// EOF TW_CloseOne",
        "",
        "//",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Unexpected token BREAK at 357033",
    "offset": 357033,
    "line": 10121,
    "column": 33,
    "evidence": {
      "startLine": 10111,
      "endLine": 10131,
      "focusLine": 10121,
      "lines": [
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)",
        "RETURN",
        "// EOF TW_CloseOne",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE xxClose()",
        "LOCAL bError :\u003dErrorBlock( {|e| Break(e)} )",
        "LOCAL aList, i",
        "aList :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())"
      ]
    }
  },
  {
    "message": "Expected expression in block literal at 357038",
    "offset": 357038,
    "line": 10121,
    "column": 38,
    "evidence": {
      "startLine": 10111,
      "endLine": 10131,
      "focusLine": 10121,
      "lines": [
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)",
        "RETURN",
        "// EOF TW_CloseOne",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE xxClose()",
        "LOCAL bError :\u003dErrorBlock( {|e| Break(e)} )",
        "LOCAL aList, i",
        "aList :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 357038",
    "offset": 357038,
    "line": 10121,
    "column": 38,
    "evidence": {
      "startLine": 10111,
      "endLine": 10131,
      "focusLine": 10121,
      "lines": [
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)",
        "RETURN",
        "// EOF TW_CloseOne",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE xxClose()",
        "LOCAL bError :\u003dErrorBlock( {|e| Break(e)} )",
        "LOCAL aList, i",
        "aList :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 357041",
    "offset": 357041,
    "line": 10121,
    "column": 41,
    "evidence": {
      "startLine": 10111,
      "endLine": 10131,
      "focusLine": 10121,
      "lines": [
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)",
        "RETURN",
        "// EOF TW_CloseOne",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE xxClose()",
        "LOCAL bError :\u003dErrorBlock( {|e| Break(e)} )",
        "LOCAL aList, i",
        "aList :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())"
      ]
    }
  },
  {
    "message": "Unexpected token RBRACE at 357041",
    "offset": 357041,
    "line": 10121,
    "column": 41,
    "evidence": {
      "startLine": 10111,
      "endLine": 10131,
      "focusLine": 10121,
      "lines": [
        "    InfoBox(\"There appears to have been a problem;while closing a file!;;Please check the work you just finished.\")",
        "  ENDIF",
        "ENDSEQUENCE",
        "ErrorBlock(bError)",
        "RETURN",
        "// EOF TW_CloseOne",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE xxClose()",
        "LOCAL bError :\u003dErrorBlock( {|e| Break(e)} )",
        "LOCAL aList, i",
        "aList :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())"
      ]
    }
  },
  {
    "message": "Unexpected RECOVER at 357218",
    "offset": 357218,
    "line": 10129,
    "column": 3,
    "evidence": {
      "startLine": 10119,
      "endLine": 10139,
      "focusLine": 10129,
      "lines": [
        "//-----------------------------------------------",
        "PROCEDURE xxClose()",
        "LOCAL bError :\u003dErrorBlock( {|e| Break(e)} )",
        "LOCAL aList, i",
        "aList :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "  ENDSEQUENCE",
        "NEXT",
        "RETURN",
        "// EOP xxClose",
        "",
        "//",
        "//-----------------------------------------------"
      ]
    }
  },
  {
    "message": "Unexpected token ARROW at 357265",
    "offset": 357265,
    "line": 10131,
    "column": 15,
    "evidence": {
      "startLine": 10121,
      "endLine": 10141,
      "focusLine": 10131,
      "lines": [
        "LOCAL bError :\u003dErrorBlock( {|e| Break(e)} )",
        "LOCAL aList, i",
        "aList :\u003d WorkSpaceList()",
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "  ENDSEQUENCE",
        "NEXT",
        "RETURN",
        "// EOP xxClose",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE ZapIndexFiles()",
        "LOCAL aDirectory :\u003d Directory(datapath()+\"*.CDX\")"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 357329",
    "offset": 357329,
    "line": 10134,
    "column": 1,
    "evidence": {
      "startLine": 10124,
      "endLine": 10144,
      "focusLine": 10134,
      "lines": [
        "FOR i:\u003d 1 TO len(aFileList)",
        "  BEGIN SEQUENCE",
        "    (aList[i])-\u003e(DbCommit())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "    ErrorBlock( bError )",
        "  RECOVER",
        "    ErrorBlock( bError )",
        "    (aList[i])-\u003e(DbRRollback())",
        "    (aList[i])-\u003e(DbCloseArea())",
        "  ENDSEQUENCE",
        "NEXT",
        "RETURN",
        "// EOP xxClose",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE ZapIndexFiles()",
        "LOCAL aDirectory :\u003d Directory(datapath()+\"*.CDX\")",
        "",
        "AEval( aDirectory, { |a| FErase( datapath()+a[ F_NAME ] ) } )",
        ""
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after expression at 358804",
    "offset": 358804,
    "line": 10203,
    "column": 23,
    "evidence": {
      "startLine": 10193,
      "endLine": 10213,
      "focusLine": 10203,
      "lines": [
        "IF empty(cFile) .OR. valtype(cFile)\u003c\u003e\"C\"",
        "  IF lAppend",
        "    cFile :\u003d RootPath()+\"PrgError.LOG\"",
        "  ELSE",
        "    cFile :\u003d RootPath()+\"PrgError.TXT\"",
        "  ENDIF",
        "ENDIF",
        "BEGIN SEQUENCE",
        "",
        "  IF lAppend .AND. FExists( cFile, \"-D-S+H\" )",
        "    DO WHILE (nHandle :\u003d FOpen(cFile, FO_READWRITE)) \u003c 0",
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "    FSeek(nHandle, 0, FS_END)  // position to end of file",
        "  ELSE",
        "    IF ! lAppend",
        "       FErase(cFile)  // if the file is hidden we get an error for FCreate()",
        "    ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 358804",
    "offset": 358804,
    "line": 10203,
    "column": 23,
    "evidence": {
      "startLine": 10193,
      "endLine": 10213,
      "focusLine": 10203,
      "lines": [
        "IF empty(cFile) .OR. valtype(cFile)\u003c\u003e\"C\"",
        "  IF lAppend",
        "    cFile :\u003d RootPath()+\"PrgError.LOG\"",
        "  ELSE",
        "    cFile :\u003d RootPath()+\"PrgError.TXT\"",
        "  ENDIF",
        "ENDIF",
        "BEGIN SEQUENCE",
        "",
        "  IF lAppend .AND. FExists( cFile, \"-D-S+H\" )",
        "    DO WHILE (nHandle :\u003d FOpen(cFile, FO_READWRITE)) \u003c 0",
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "    FSeek(nHandle, 0, FS_END)  // position to end of file",
        "  ELSE",
        "    IF ! lAppend",
        "       FErase(cFile)  // if the file is hidden we get an error for FCreate()",
        "    ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 358881",
    "offset": 358881,
    "line": 10206,
    "column": 7,
    "evidence": {
      "startLine": 10196,
      "endLine": 10216,
      "focusLine": 10206,
      "lines": [
        "  ELSE",
        "    cFile :\u003d RootPath()+\"PrgError.TXT\"",
        "  ENDIF",
        "ENDIF",
        "BEGIN SEQUENCE",
        "",
        "  IF lAppend .AND. FExists( cFile, \"-D-S+H\" )",
        "    DO WHILE (nHandle :\u003d FOpen(cFile, FO_READWRITE)) \u003c 0",
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "    FSeek(nHandle, 0, FS_END)  // position to end of file",
        "  ELSE",
        "    IF ! lAppend",
        "       FErase(cFile)  // if the file is hidden we get an error for FCreate()",
        "    ENDIF",
        "    DO WHILE (nHandle :\u003d FCreate(cFile)) \u003c 0",
        "      IF ++i \u003e 9",
        "        RETURN .F."
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after expression at 359104",
    "offset": 359104,
    "line": 10214,
    "column": 23,
    "evidence": {
      "startLine": 10204,
      "endLine": 10224,
      "focusLine": 10214,
      "lines": [
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "    FSeek(nHandle, 0, FS_END)  // position to end of file",
        "  ELSE",
        "    IF ! lAppend",
        "       FErase(cFile)  // if the file is hidden we get an error for FCreate()",
        "    ENDIF",
        "    DO WHILE (nHandle :\u003d FCreate(cFile)) \u003c 0",
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "  ENDIF",
        "  IF nHandle \u003e 1",
        "    FWrite(nHandle, cText)",
        "    IF lAppend",
        "      FWrite(nHandle, chr(13)+chr(10) )"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 359104",
    "offset": 359104,
    "line": 10214,
    "column": 23,
    "evidence": {
      "startLine": 10204,
      "endLine": 10224,
      "focusLine": 10214,
      "lines": [
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "    FSeek(nHandle, 0, FS_END)  // position to end of file",
        "  ELSE",
        "    IF ! lAppend",
        "       FErase(cFile)  // if the file is hidden we get an error for FCreate()",
        "    ENDIF",
        "    DO WHILE (nHandle :\u003d FCreate(cFile)) \u003c 0",
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "  ENDIF",
        "  IF nHandle \u003e 1",
        "    FWrite(nHandle, cText)",
        "    IF lAppend",
        "      FWrite(nHandle, chr(13)+chr(10) )"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 359169",
    "offset": 359169,
    "line": 10217,
    "column": 7,
    "evidence": {
      "startLine": 10207,
      "endLine": 10227,
      "focusLine": 10217,
      "lines": [
        "      Sleep(20)",
        "    ENDDO",
        "    FSeek(nHandle, 0, FS_END)  // position to end of file",
        "  ELSE",
        "    IF ! lAppend",
        "       FErase(cFile)  // if the file is hidden we get an error for FCreate()",
        "    ENDIF",
        "    DO WHILE (nHandle :\u003d FCreate(cFile)) \u003c 0",
        "      IF ++i \u003e 9",
        "        RETURN .F.",
        "      ENDIF",
        "      Sleep(20)",
        "    ENDDO",
        "  ENDIF",
        "  IF nHandle \u003e 1",
        "    FWrite(nHandle, cText)",
        "    IF lAppend",
        "      FWrite(nHandle, chr(13)+chr(10) )",
        "    ENDIF",
        "    FClose(nHandle)",
        "    nHandle :\u003d 0"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after expression at 374175",
    "offset": 374175,
    "line": 10740,
    "column": 17,
    "evidence": {
      "startLine": 10730,
      "endLine": 10750,
      "focusLine": 10740,
      "lines": [
        "   LOCAL h, i, x, n, z, nRet",
        "",
        "  h :\u003d \u00270123456789ABCDEF\u0027",
        "  z :\u003d 0",
        "  c :\u003d upper(alltrim(c))",
        "  nRet :\u003d 0",
        "  FOR i :\u003d len(c) to 1 step -1",
        "    x :\u003d substr( c, i, 1 )",
        "    n :\u003d at( x, h ) - 1",
        "    IF z \u003e 0 .AND. n \u003e 0",
        "      n :\u003d n*(16^z)",
        "    ENDIF",
        "    nRet +\u003d n",
        "    z++",
        "  NEXT",
        "RETURN (nRet)",
        "// EOF h2dec",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE MakeClerksRaw()"
      ]
    }
  },
  {
    "message": "Unexpected token \u0027^\u0027 at 374175",
    "offset": 374175,
    "line": 10740,
    "column": 17,
    "evidence": {
      "startLine": 10730,
      "endLine": 10750,
      "focusLine": 10740,
      "lines": [
        "   LOCAL h, i, x, n, z, nRet",
        "",
        "  h :\u003d \u00270123456789ABCDEF\u0027",
        "  z :\u003d 0",
        "  c :\u003d upper(alltrim(c))",
        "  nRet :\u003d 0",
        "  FOR i :\u003d len(c) to 1 step -1",
        "    x :\u003d substr( c, i, 1 )",
        "    n :\u003d at( x, h ) - 1",
        "    IF z \u003e 0 .AND. n \u003e 0",
        "      n :\u003d n*(16^z)",
        "    ENDIF",
        "    nRet +\u003d n",
        "    z++",
        "  NEXT",
        "RETURN (nRet)",
        "// EOF h2dec",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE MakeClerksRaw()"
      ]
    }
  },
  {
    "message": "Unexpected token NEXT at 374213",
    "offset": 374213,
    "line": 10744,
    "column": 3,
    "evidence": {
      "startLine": 10734,
      "endLine": 10754,
      "focusLine": 10744,
      "lines": [
        "  c :\u003d upper(alltrim(c))",
        "  nRet :\u003d 0",
        "  FOR i :\u003d len(c) to 1 step -1",
        "    x :\u003d substr( c, i, 1 )",
        "    n :\u003d at( x, h ) - 1",
        "    IF z \u003e 0 .AND. n \u003e 0",
        "      n :\u003d n*(16^z)",
        "    ENDIF",
        "    nRet +\u003d n",
        "    z++",
        "  NEXT",
        "RETURN (nRet)",
        "// EOF h2dec",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE MakeClerksRaw()",
        "",
        "CREATE temp",
        "add_field(\u0027NAME_F\u0027,\u0027C\u0027,30)",
        "add_field(\u0027NAME_L\u0027,\u0027C\u0027,30)"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 374218",
    "offset": 374218,
    "line": 10745,
    "column": 1,
    "evidence": {
      "startLine": 10735,
      "endLine": 10755,
      "focusLine": 10745,
      "lines": [
        "  nRet :\u003d 0",
        "  FOR i :\u003d len(c) to 1 step -1",
        "    x :\u003d substr( c, i, 1 )",
        "    n :\u003d at( x, h ) - 1",
        "    IF z \u003e 0 .AND. n \u003e 0",
        "      n :\u003d n*(16^z)",
        "    ENDIF",
        "    nRet +\u003d n",
        "    z++",
        "  NEXT",
        "RETURN (nRet)",
        "// EOF h2dec",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE MakeClerksRaw()",
        "",
        "CREATE temp",
        "add_field(\u0027NAME_F\u0027,\u0027C\u0027,30)",
        "add_field(\u0027NAME_L\u0027,\u0027C\u0027,30)",
        "add_field(\u0027TORV\u0027,\u0027C\u0027,35)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 376405",
    "offset": 376405,
    "line": 10832,
    "column": 1,
    "evidence": {
      "startLine": 10822,
      "endLine": 10842,
      "focusLine": 10832,
      "lines": [
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION isCAP_County(lForceChk)",
        "STATIC slCap",
        "",
        "v_ValType(@lForceChk,.F.)",
        "",
        "IF valtype(slCAP) # \"L\" .OR. lForceChk",
        "  slCAP :\u003d fExists(DataPath()+\"CAP_County.SET\")",
        "ENDIF",
        "RETURN slCAP",
        "// EOF isCAP_County",
        "",
        "// All CAP dockets should have a 9 in the 5th spot of the docket number.",
        "//-----------------------------------------------",
        "FUNCTION isCAPDocket(docketNumber)",
        "  RETURN getDocketFifthNumber(docketNumber) \u003d \"9\"",
        "// EOF isCAPDocket",
        "",
        "// All dockets that were merged in from another court should have a 5 in the 5th spot of the docket number."
      ]
    }
  },
  {
    "message": "Unexpected token \u0027.dbf\nIF !fExists(DataPath()+\"Notes2.\u0027 at 377226",
    "offset": 377226,
    "line": 10859,
    "column": 11,
    "evidence": {
      "startLine": 10849,
      "endLine": 10869,
      "focusLine": 10859,
      "lines": [
        "//-----------------------------------------------",
        "FUNCTION getDocketFifthNumber(docketNumber)",
        "  RETURN substr(docketNumber,6,1)",
        "// EOF getDocketFifthNumber",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE MakeNotes2()",
        "LOCAL oAlertBox, oldArea:\u003dSELE()",
        "",
        "erase temp.dbf",
        "IF !fExists(DataPath()+\"Notes2.dbf\")",
        "  oAlertBox :\u003d JustInfo(\u0027;Creating new NOTES2.DBF;\u0027)",
        "  dbSelectArea(0)",
        "  CREATE temp",
        "  add_field(\u0027N_INDEX_NO\u0027,\u0027C\u0027, 9)            //",
        "  add_field(\u0027N_TYPE\u0027,    \u0027C\u0027, 2)            //  \u0027OL\u0027 Old Letter, \u0027OA\u0027 Old Action, ... ?",
        "  add_field(\u0027N_POSITION\u0027,\u0027N\u0027, 3, 0)         //   Secuence number",
        "  add_field(\u0027N_CODE\u0027,    \u0027C\u0027, 3)            //",
        "  add_field(\u0027N_TEXT\u0027,    \u0027C\u0027,50)            //",
        "  add_field(\u0027N_DATE\u0027,    \u0027D\u0027, 8)            //"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 378026",
    "offset": 378026,
    "line": 10880,
    "column": 1,
    "evidence": {
      "startLine": 10870,
      "endLine": 10890,
      "focusLine": 10880,
      "lines": [
        "  CLOSE",
        "  CREATE(dataPath()+\"NOTES2\") FROM temp",
        "  erase temp.dbf",
        "  USE",
        "  net_use(DataPath()+\u0027Notes2\u0027,.T.,2)",
        "  OrdCreate(\"NOTES2\", \"Index_No\", \"n_index_no+n_type+str(n_position,3)\",;         // SEE INDEX.PRG ALSO",
        "                               {||n_index_no+n_type+str(n_position,3) } )",
        "  USE",
        "  KillAlert(@oAlertBox)",
        "  SELE(oldArea)",
        "ENDIF",
        "",
        "RETURN",
        "// EOP MakeNotes2",
        "",
        "//",
        "//-----------------------------------------------",
        "PROCEDURE TestLineReader(cFileName)",
        "LOCAL nn, xx, oRead, cTxt",
        "PRIVATE aProgress",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 378767",
    "offset": 378767,
    "line": 10912,
    "column": 16,
    "evidence": {
      "startLine": 10902,
      "endLine": 10922,
      "focusLine": 10912,
      "lines": [
        "oRead :\u003d NIL",
        "InfoBox(nTrim(nn)+\" Lines were read from ;\"+cFileName+\".;;Last Line:;\"+cTxt, \"TEST\", 8)",
        "RETURN",
        "// EOP TestLineReader",
        "",
        "//",
        "//-----------------------------------------------",
        "// Class for reading .CSV or .TXT files, _much_ faster than MEMOLINE!",
        "CLASS LineReader",
        "   PROTECTED:",
        "   VAR    cText, cLine, n1, n2, nMaxPos",
        "",
        "   EXPORTED:",
        "   VAR    nMaxLn READONLY",
        "   VAR    nCurLn READONLY",
        "   METHOD      create, getLine, destroy",
        "",
        "ENDCLASS",
        "",
        "// Read in and tokenize the lines",
        "METHOD LineReader:create( cFile )"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 379512",
    "offset": 379512,
    "line": 10942,
    "column": 3,
    "evidence": {
      "startLine": 10932,
      "endLine": 10952,
      "focusLine": 10942,
      "lines": [
        "",
        "// Sequential line reader",
        "METHOD LineReader:getLine()",
        "LOCAL n2",
        "  IF valtype(::n1)\u003d\"N\" .AND. ;",
        "         valtype(::nMaxPos)\u003d\"N\" .AND. ::n1 \u003c ::nMaxPos",
        "    n2 :\u003d at( chr(131), ::cText, ::n1 )",
        "    ::cLine :\u003d SubStr(::cText,::n1,n2-::n1)",
        "    ::n1 :\u003d n2+1",
        "    ::nCurLn++",
        "  ELSE",
        "    ::cLine :\u003d \"\"",
        "  ENDIF",
        "RETURN ::cLine",
        "// EOM LineReader:getLine",
        "",
        "// Release resources",
        "METHOD LineReader:destroy()",
        "   ::cText :\u003d ::cLine :\u003d ::nMaxPos :\u003d ::nMaxLn :\u003d ::n1 :\u003d ::nCurLn :\u003d NIL",
        "RETURN self",
        "// EOM LineReader:destroy"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 379537",
    "offset": 379537,
    "line": 10944,
    "column": 3,
    "evidence": {
      "startLine": 10934,
      "endLine": 10954,
      "focusLine": 10944,
      "lines": [
        "METHOD LineReader:getLine()",
        "LOCAL n2",
        "  IF valtype(::n1)\u003d\"N\" .AND. ;",
        "         valtype(::nMaxPos)\u003d\"N\" .AND. ::n1 \u003c ::nMaxPos",
        "    n2 :\u003d at( chr(131), ::cText, ::n1 )",
        "    ::cLine :\u003d SubStr(::cText,::n1,n2-::n1)",
        "    ::n1 :\u003d n2+1",
        "    ::nCurLn++",
        "  ELSE",
        "    ::cLine :\u003d \"\"",
        "  ENDIF",
        "RETURN ::cLine",
        "// EOM LineReader:getLine",
        "",
        "// Release resources",
        "METHOD LineReader:destroy()",
        "   ::cText :\u003d ::cLine :\u003d ::nMaxPos :\u003d ::nMaxLn :\u003d ::n1 :\u003d ::nCurLn :\u003d NIL",
        "RETURN self",
        "// EOM LineReader:destroy",
        "// EOC LineReader",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 379656",
    "offset": 379656,
    "line": 10950,
    "column": 23,
    "evidence": {
      "startLine": 10940,
      "endLine": 10960,
      "focusLine": 10950,
      "lines": [
        "    ::n1 :\u003d n2+1",
        "    ::nCurLn++",
        "  ELSE",
        "    ::cLine :\u003d \"\"",
        "  ENDIF",
        "RETURN ::cLine",
        "// EOM LineReader:getLine",
        "",
        "// Release resources",
        "METHOD LineReader:destroy()",
        "   ::cText :\u003d ::cLine :\u003d ::nMaxPos :\u003d ::nMaxLn :\u003d ::n1 :\u003d ::nCurLn :\u003d NIL",
        "RETURN self",
        "// EOM LineReader:destroy",
        "// EOC LineReader",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION SettleCodeTxt(xxCode, xxCodeTxt, GetList)",
        "LOCAL n",
        "  n:\u003daScan(aStatCode,{|x| x[cscCode]\u003d\u003dxxCode })",
        "  IF n\u003e0                               // Was code found?"
      ]
    }
  },
  {
    "message": "Unexpected ELSEIF at 380034",
    "offset": 380034,
    "line": 10962,
    "column": 3,
    "evidence": {
      "startLine": 10952,
      "endLine": 10972,
      "focusLine": 10962,
      "lines": [
        "// EOM LineReader:destroy",
        "// EOC LineReader",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION SettleCodeTxt(xxCode, xxCodeTxt, GetList)",
        "LOCAL n",
        "  n:\u003daScan(aStatCode,{|x| x[cscCode]\u003d\u003dxxCode })",
        "  IF n\u003e0                               // Was code found?",
        "    xxCodeTxt :\u003d trim(aStatCode[ n,cscCodeTxt ])",
        "  ELSEIF xxCode \u003d\u003d \u0027   \u0027               // or, was it a blank code?",
        "    xxCodeTxt :\u003d Space(20)",
        "  ELSE                                 // else report code as unknown!",
        "    xxCodeTxt :\u003d \"Unknown Code - \"+xxCode",
        "  ENDIF",
        "  IF \"\u0026\"$xxCodeTxt",
        "    xxCodeTxt :\u003d strtran(xxCodeTxt,\"\u0026\",\"\u0026\u0026\")",
        "  ENDIF",
        "  IF valtype(GetList)\u003d\"A\"",
        "    dc_getrefresh(GetList)",
        "  ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 380128",
    "offset": 380128,
    "line": 10964,
    "column": 3,
    "evidence": {
      "startLine": 10954,
      "endLine": 10974,
      "focusLine": 10964,
      "lines": [
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION SettleCodeTxt(xxCode, xxCodeTxt, GetList)",
        "LOCAL n",
        "  n:\u003daScan(aStatCode,{|x| x[cscCode]\u003d\u003dxxCode })",
        "  IF n\u003e0                               // Was code found?",
        "    xxCodeTxt :\u003d trim(aStatCode[ n,cscCodeTxt ])",
        "  ELSEIF xxCode \u003d\u003d \u0027   \u0027               // or, was it a blank code?",
        "    xxCodeTxt :\u003d Space(20)",
        "  ELSE                                 // else report code as unknown!",
        "    xxCodeTxt :\u003d \"Unknown Code - \"+xxCode",
        "  ENDIF",
        "  IF \"\u0026\"$xxCodeTxt",
        "    xxCodeTxt :\u003d strtran(xxCodeTxt,\"\u0026\",\"\u0026\u0026\")",
        "  ENDIF",
        "  IF valtype(GetList)\u003d\"A\"",
        "    dc_getrefresh(GetList)",
        "  ENDIF",
        "RETURN xxCodeTxt",
        "// EOF SettleCodeTxt"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 380241",
    "offset": 380241,
    "line": 10966,
    "column": 3,
    "evidence": {
      "startLine": 10956,
      "endLine": 10976,
      "focusLine": 10966,
      "lines": [
        "//-----------------------------------------------",
        "FUNCTION SettleCodeTxt(xxCode, xxCodeTxt, GetList)",
        "LOCAL n",
        "  n:\u003daScan(aStatCode,{|x| x[cscCode]\u003d\u003dxxCode })",
        "  IF n\u003e0                               // Was code found?",
        "    xxCodeTxt :\u003d trim(aStatCode[ n,cscCodeTxt ])",
        "  ELSEIF xxCode \u003d\u003d \u0027   \u0027               // or, was it a blank code?",
        "    xxCodeTxt :\u003d Space(20)",
        "  ELSE                                 // else report code as unknown!",
        "    xxCodeTxt :\u003d \"Unknown Code - \"+xxCode",
        "  ENDIF",
        "  IF \"\u0026\"$xxCodeTxt",
        "    xxCodeTxt :\u003d strtran(xxCodeTxt,\"\u0026\",\"\u0026\u0026\")",
        "  ENDIF",
        "  IF valtype(GetList)\u003d\"A\"",
        "    dc_getrefresh(GetList)",
        "  ENDIF",
        "RETURN xxCodeTxt",
        "// EOF SettleCodeTxt",
        "",
        "//"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 380590",
    "offset": 380590,
    "line": 10980,
    "column": 23,
    "evidence": {
      "startLine": 10970,
      "endLine": 10990,
      "focusLine": 10980,
      "lines": [
        "  IF valtype(GetList)\u003d\"A\"",
        "    dc_getrefresh(GetList)",
        "  ENDIF",
        "RETURN xxCodeTxt",
        "// EOF SettleCodeTxt",
        "",
        "//",
        "//-----------------------------------------------",
        "FUNCTION GetLocalActionCode(cText)",
        "LOCAL nExit:\u003d2,oDlg1, GetList:\u003d{}, GetOptions, lOK:\u003d.F., oOK",
        "PRIVATE  xxCode:\u003d\"   \", xxCodeTxt:\u003dspace(20)",
        "",
        "  SEIStdDialog oDlg1   ;",
        "              TITLE \u0027FIND ACTION CODE\u0027 ;",
        "              SIZE {580,440}",
        "",
        "  @  2,10 DCSAY \"Enter the correct action code for:\" ;",
        "            SAYFONT BTN_FONT_B  ;",
        "            SAYSIZE 0",
        "",
        "  @  3,10 DCSAY cText ;"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 382542",
    "offset": 382542,
    "line": 11043,
    "column": 3,
    "evidence": {
      "startLine": 11033,
      "endLine": 11053,
      "focusLine": 11043,
      "lines": [
        "                 SetAppFocus(oDlg1),;",
        "                 SetAppFocus(oCode)}",
        "",
        "  GetList :\u003d {}",
        "  DestroyAll( @oDlg1 )",
        "  oDlg1 :\u003d NIL",
        "  Scn_No(0)",
        "",
        "  IF lOK",
        "    xxCode :\u003d zFill(xxCode,3)",
        "  ELSE",
        "    xxCode :\u003d \"   \"",
        "  ENDIF",
        "",
        "RETURN xxCode",
        "// EOF GetLocalActionCode",
        "",
        "//",
        "// allTrimWithNilCheck ",
        "//  Returns empty string if NIL, otherwise trims text.",
        "FUNCTION allTrimWithNilCheck(p_cTextToTrim)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 382569",
    "offset": 382569,
    "line": 11045,
    "column": 3,
    "evidence": {
      "startLine": 11035,
      "endLine": 11055,
      "focusLine": 11045,
      "lines": [
        "",
        "  GetList :\u003d {}",
        "  DestroyAll( @oDlg1 )",
        "  oDlg1 :\u003d NIL",
        "  Scn_No(0)",
        "",
        "  IF lOK",
        "    xxCode :\u003d zFill(xxCode,3)",
        "  ELSE",
        "    xxCode :\u003d \"   \"",
        "  ENDIF",
        "",
        "RETURN xxCode",
        "// EOF GetLocalActionCode",
        "",
        "//",
        "// allTrimWithNilCheck ",
        "//  Returns empty string if NIL, otherwise trims text.",
        "FUNCTION allTrimWithNilCheck(p_cTextToTrim)",
        "  LOCAL cTrimmedText",
        "  IIF(p_cTextToTrim !\u003d NIL, cTrimmedText:\u003dallTrim(p_cTextToTrim), cTrimmedText:\u003d\"\")"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 382804",
    "offset": 382804,
    "line": 11055,
    "column": 41,
    "evidence": {
      "startLine": 11045,
      "endLine": 11065,
      "focusLine": 11055,
      "lines": [
        "  ENDIF",
        "",
        "RETURN xxCode",
        "// EOF GetLocalActionCode",
        "",
        "//",
        "// allTrimWithNilCheck ",
        "//  Returns empty string if NIL, otherwise trims text.",
        "FUNCTION allTrimWithNilCheck(p_cTextToTrim)",
        "  LOCAL cTrimmedText",
        "  IIF(p_cTextToTrim !\u003d NIL, cTrimmedText:\u003dallTrim(p_cTextToTrim), cTrimmedText:\u003d\"\")",
        "RETURN cTrimmedText",
        "// EOF allTrimWithNilCheck",
        "",
        "",
        "",
        "//",
        "//---------------------------------------------",
        "FUNCTION GetOfficerForcesPipeDelimited()",
        "  LOCAL oldArea:\u003dSELE(), oldRec, oldOrder, aForces :\u003d {}, cForces :\u003d \"\"",
        ""
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 382804",
    "offset": 382804,
    "line": 11055,
    "column": 41,
    "evidence": {
      "startLine": 11045,
      "endLine": 11065,
      "focusLine": 11055,
      "lines": [
        "  ENDIF",
        "",
        "RETURN xxCode",
        "// EOF GetLocalActionCode",
        "",
        "//",
        "// allTrimWithNilCheck ",
        "//  Returns empty string if NIL, otherwise trims text.",
        "FUNCTION allTrimWithNilCheck(p_cTextToTrim)",
        "  LOCAL cTrimmedText",
        "  IIF(p_cTextToTrim !\u003d NIL, cTrimmedText:\u003dallTrim(p_cTextToTrim), cTrimmedText:\u003d\"\")",
        "RETURN cTrimmedText",
        "// EOF allTrimWithNilCheck",
        "",
        "",
        "",
        "//",
        "//---------------------------------------------",
        "FUNCTION GetOfficerForcesPipeDelimited()",
        "  LOCAL oldArea:\u003dSELE(), oldRec, oldOrder, aForces :\u003d {}, cForces :\u003d \"\"",
        ""
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 383373",
    "offset": 383373,
    "line": 11075,
    "column": 5,
    "evidence": {
      "startLine": 11065,
      "endLine": 11085,
      "focusLine": 11075,
      "lines": [
        "",
        "  DbSelectArea(\"NAMES\")",
        "  oldOrder :\u003d OrdNumber()",
        "  oldRec:\u003drecno()",
        "  OrderSet(\"A6\")",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF !empty(names-\u003eForce) .AND. !empty(names-\u003eMOTOR_ID) .AND. ;",
        "       !UPPER(NAMES-\u003eMOTOR_ID)\u003d\"R\" .AND. aScan(aForces, UPPER(names-\u003eForce)) \u003d\u003d 0",
        "        aAdd(aForces, UPPER(names-\u003eForce))",
        "    ENDIF",
        "    SKIP",
        "  ENDDO",
        "  IF AScan(aForces, UPPER(ciDefForce)) \u003d\u003d 0",
        "    AAdd(aForces, ciDefForce) // Court\u0027s default force.",
        "  ENDIF",
        "  aSort(aForces)",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(oldRec)",
        "  SELE(oldArea)",
        "  KillAlert(@oAlertBox)"
      ]
    }
  },
  {
    "message": "Unexpected ENDDO at 383390",
    "offset": 383390,
    "line": 11077,
    "column": 3,
    "evidence": {
      "startLine": 11067,
      "endLine": 11087,
      "focusLine": 11077,
      "lines": [
        "  oldOrder :\u003d OrdNumber()",
        "  oldRec:\u003drecno()",
        "  OrderSet(\"A6\")",
        "  dbGoTop()",
        "  DO WHILE !eof()",
        "    IF !empty(names-\u003eForce) .AND. !empty(names-\u003eMOTOR_ID) .AND. ;",
        "       !UPPER(NAMES-\u003eMOTOR_ID)\u003d\"R\" .AND. aScan(aForces, UPPER(names-\u003eForce)) \u003d\u003d 0",
        "        aAdd(aForces, UPPER(names-\u003eForce))",
        "    ENDIF",
        "    SKIP",
        "  ENDDO",
        "  IF AScan(aForces, UPPER(ciDefForce)) \u003d\u003d 0",
        "    AAdd(aForces, ciDefForce) // Court\u0027s default force.",
        "  ENDIF",
        "  aSort(aForces)",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(oldRec)",
        "  SELE(oldArea)",
        "  KillAlert(@oAlertBox)",
        "  ",
        "  AEval(aForces, {|x,i| cForces +\u003dx+\"|\"} )"
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 383676",
    "offset": 383676,
    "line": 11087,
    "column": 34,
    "evidence": {
      "startLine": 11077,
      "endLine": 11097,
      "focusLine": 11087,
      "lines": [
        "  ENDDO",
        "  IF AScan(aForces, UPPER(ciDefForce)) \u003d\u003d 0",
        "    AAdd(aForces, ciDefForce) // Court\u0027s default force.",
        "  ENDIF",
        "  aSort(aForces)",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(oldRec)",
        "  SELE(oldArea)",
        "  KillAlert(@oAlertBox)",
        "  ",
        "  AEval(aForces, {|x,i| cForces +\u003dx+\"|\"} )",
        "  ",
        "RETURN cForces",
        "// EOF GetOfficerForcesPipeDelimited",
        "",
        "//",
        "//Send Email Using Outlook",
        "//   Note:  If single file, can be passed in as array of one or as string",
        "//          If single recipient, can be passed in as array of one or as string",
        "// RETURNS 1 if the generated email was sent, 0 if the email was closed but not sent, -1 if there was an error.",
        "FUNCTION SendMailToOutLook( p_cSubject, p_cText, p_aFilesToAttach, p_aEmailRecipients )"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 383677",
    "offset": 383677,
    "line": 11087,
    "column": 35,
    "evidence": {
      "startLine": 11077,
      "endLine": 11097,
      "focusLine": 11087,
      "lines": [
        "  ENDDO",
        "  IF AScan(aForces, UPPER(ciDefForce)) \u003d\u003d 0",
        "    AAdd(aForces, ciDefForce) // Court\u0027s default force.",
        "  ENDIF",
        "  aSort(aForces)",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(oldRec)",
        "  SELE(oldArea)",
        "  KillAlert(@oAlertBox)",
        "  ",
        "  AEval(aForces, {|x,i| cForces +\u003dx+\"|\"} )",
        "  ",
        "RETURN cForces",
        "// EOF GetOfficerForcesPipeDelimited",
        "",
        "//",
        "//Send Email Using Outlook",
        "//   Note:  If single file, can be passed in as array of one or as string",
        "//          If single recipient, can be passed in as array of one or as string",
        "// RETURNS 1 if the generated email was sent, 0 if the email was closed but not sent, -1 if there was an error.",
        "FUNCTION SendMailToOutLook( p_cSubject, p_cText, p_aFilesToAttach, p_aEmailRecipients )"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 383677",
    "offset": 383677,
    "line": 11087,
    "column": 35,
    "evidence": {
      "startLine": 11077,
      "endLine": 11097,
      "focusLine": 11087,
      "lines": [
        "  ENDDO",
        "  IF AScan(aForces, UPPER(ciDefForce)) \u003d\u003d 0",
        "    AAdd(aForces, ciDefForce) // Court\u0027s default force.",
        "  ENDIF",
        "  aSort(aForces)",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(oldRec)",
        "  SELE(oldArea)",
        "  KillAlert(@oAlertBox)",
        "  ",
        "  AEval(aForces, {|x,i| cForces +\u003dx+\"|\"} )",
        "  ",
        "RETURN cForces",
        "// EOF GetOfficerForcesPipeDelimited",
        "",
        "//",
        "//Send Email Using Outlook",
        "//   Note:  If single file, can be passed in as array of one or as string",
        "//          If single recipient, can be passed in as array of one or as string",
        "// RETURNS 1 if the generated email was sent, 0 if the email was closed but not sent, -1 if there was an error.",
        "FUNCTION SendMailToOutLook( p_cSubject, p_cText, p_aFilesToAttach, p_aEmailRecipients )"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 383677",
    "offset": 383677,
    "line": 11087,
    "column": 35,
    "evidence": {
      "startLine": 11077,
      "endLine": 11097,
      "focusLine": 11087,
      "lines": [
        "  ENDDO",
        "  IF AScan(aForces, UPPER(ciDefForce)) \u003d\u003d 0",
        "    AAdd(aForces, ciDefForce) // Court\u0027s default force.",
        "  ENDIF",
        "  aSort(aForces)",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(oldRec)",
        "  SELE(oldArea)",
        "  KillAlert(@oAlertBox)",
        "  ",
        "  AEval(aForces, {|x,i| cForces +\u003dx+\"|\"} )",
        "  ",
        "RETURN cForces",
        "// EOF GetOfficerForcesPipeDelimited",
        "",
        "//",
        "//Send Email Using Outlook",
        "//   Note:  If single file, can be passed in as array of one or as string",
        "//          If single recipient, can be passed in as array of one or as string",
        "// RETURNS 1 if the generated email was sent, 0 if the email was closed but not sent, -1 if there was an error.",
        "FUNCTION SendMailToOutLook( p_cSubject, p_cText, p_aFilesToAttach, p_aEmailRecipients )"
      ]
    }
  },
  {
    "message": "Unexpected token RBRACE at 383682",
    "offset": 383682,
    "line": 11087,
    "column": 40,
    "evidence": {
      "startLine": 11077,
      "endLine": 11097,
      "focusLine": 11087,
      "lines": [
        "  ENDDO",
        "  IF AScan(aForces, UPPER(ciDefForce)) \u003d\u003d 0",
        "    AAdd(aForces, ciDefForce) // Court\u0027s default force.",
        "  ENDIF",
        "  aSort(aForces)",
        "  OrdSetfocus(oldOrder)  // Put things back the way they were",
        "  dbGoTo(oldRec)",
        "  SELE(oldArea)",
        "  KillAlert(@oAlertBox)",
        "  ",
        "  AEval(aForces, {|x,i| cForces +\u003dx+\"|\"} )",
        "  ",
        "RETURN cForces",
        "// EOF GetOfficerForcesPipeDelimited",
        "",
        "//",
        "//Send Email Using Outlook",
        "//   Note:  If single file, can be passed in as array of one or as string",
        "//          If single recipient, can be passed in as array of one or as string",
        "// RETURNS 1 if the generated email was sent, 0 if the email was closed but not sent, -1 if there was an error.",
        "FUNCTION SendMailToOutLook( p_cSubject, p_cText, p_aFilesToAttach, p_aEmailRecipients )"
      ]
    }
  },
  {
    "message": "Unexpected ELSEIF at 384571",
    "offset": 384571,
    "line": 11107,
    "column": 3,
    "evidence": {
      "startLine": 11097,
      "endLine": 11117,
      "focusLine": 11107,
      "lines": [
        "FUNCTION SendMailToOutLook( p_cSubject, p_cText, p_aFilesToAttach, p_aEmailRecipients )",
        "",
        "  LOCAL lInProgress, oAlertBox, currentDate, oOutlookNS_MAPI, oOutlookInboxFolder, lLaunchOutlook, ;",
        "        bSaveErrorBlock, oError, oOutlookApplication,oOutlookMailItem, nEventSend, nEventClose, cMessage, ;",
        "        oOutlookActXMailItem, i, cValType, lMessageSent :\u003d .F., lMessageClose :\u003d .F., nExitValue :\u003d 0",
        "        ",
        "",
        "  cValType :\u003d Valtype(p_aFilesToAttach)",
        "  IF Valtype(p_aFilesToAttach) \u003d \u0027C\u0027",
        "    p_aFilesToAttach :\u003d { p_aFilesToAttach }",
        "  ELSEIF cValType \u003c\u003e \u0027A\u0027  //no attachments... create blank array",
        "    p_aFilesToAttach :\u003d { }",
        "  ENDIF",
        "  ",
        "  // Define error block",
        "  error_trap :\u003d \u0027ERROR CREATING OR SENDING EMAIL!\u0027",
        "  bSaveErrorBlock :\u003d ErrorBlock( {|e| ErrTrap(e)} )",
        "  ",
        "  BEGIN SEQUENCE //Error block sequence",
        "    lInProgress :\u003d .F.",
        "    AlertBox TO oAlertBox ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 384664",
    "offset": 384664,
    "line": 11109,
    "column": 3,
    "evidence": {
      "startLine": 11099,
      "endLine": 11119,
      "focusLine": 11109,
      "lines": [
        "  LOCAL lInProgress, oAlertBox, currentDate, oOutlookNS_MAPI, oOutlookInboxFolder, lLaunchOutlook, ;",
        "        bSaveErrorBlock, oError, oOutlookApplication,oOutlookMailItem, nEventSend, nEventClose, cMessage, ;",
        "        oOutlookActXMailItem, i, cValType, lMessageSent :\u003d .F., lMessageClose :\u003d .F., nExitValue :\u003d 0",
        "        ",
        "",
        "  cValType :\u003d Valtype(p_aFilesToAttach)",
        "  IF Valtype(p_aFilesToAttach) \u003d \u0027C\u0027",
        "    p_aFilesToAttach :\u003d { p_aFilesToAttach }",
        "  ELSEIF cValType \u003c\u003e \u0027A\u0027  //no attachments... create blank array",
        "    p_aFilesToAttach :\u003d { }",
        "  ENDIF",
        "  ",
        "  // Define error block",
        "  error_trap :\u003d \u0027ERROR CREATING OR SENDING EMAIL!\u0027",
        "  bSaveErrorBlock :\u003d ErrorBlock( {|e| ErrTrap(e)} )",
        "  ",
        "  BEGIN SEQUENCE //Error block sequence",
        "    lInProgress :\u003d .F.",
        "    AlertBox TO oAlertBox ;",
        "           TEXT \u0027Creating email.  Please wait....;\u0027 ;",
        "           BUTTONS {\"NONE\"}                               ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 385361",
    "offset": 385361,
    "line": 11128,
    "column": 5,
    "evidence": {
      "startLine": 11118,
      "endLine": 11138,
      "focusLine": 11128,
      "lines": [
        "           TEXT \u0027Creating email.  Please wait....;\u0027 ;",
        "           BUTTONS {\"NONE\"}                               ;",
        "           SYSICON XBPSTATIC_SYSICON_ICONINFORMATION      ;",
        "           TITLE \"CREATING EMAIL\"                          ;",
        "           _SHOWPROGRESS .T.",
        "",
        "    IF valtype(oAlertBox)\u003d\u003d\"A\" .AND. IsObject(oAlertBox[3])",
        "      oAlertBox[3]:current :\u003d 1         // oAlertBox[3] is oProgress bar object",
        "      oAlertBox[3]:maximum :\u003d 20",
        "      lInProgress :\u003d .T.",
        "    ENDIF",
        "",
        "    IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "    cValType :\u003d Valtype(p_aEmailRecipients)",
        "    IF Valtype(p_aEmailRecipients) \u003d \u0027C\u0027",
        "      p_aEmailRecipients :\u003d { p_aEmailRecipients }",
        "    ELSEIF cValType \u003c\u003e \u0027A\u0027  //no recipients... create blank array",
        "      p_aEmailRecipients :\u003d {  }",
        "    ENDIF",
        "    aOutlookWinHandleAndVisibility:\u003dGetWindowHandleAndVisibility(\" Outlook\")"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 386492",
    "offset": 386492,
    "line": 11154,
    "column": 40,
    "evidence": {
      "startLine": 11144,
      "endLine": 11164,
      "focusLine": 11154,
      "lines": [
        "    IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "    IF !empty(ComLastError()) .OR. Valtype(oOutlookApplication) # \u0027O\u0027",
        "        KillAlert(@oAlertBox)",
        "        //Check task isn\u0027t in suspended state?  If it is then have user kill w/task manager reboot",
        "        IF aOutlookWinHandleAndVisibility !\u003d NIL .AND. !aOutlookWinHandleAndVisibility[1,2]",
        "          DisplayUnableToCreateEmail( \"Outlook is in an unusable state.;\" + ; ",
        "                   \"Please kill the Outlook program using Task Manager or reboot your computer and try again.\")",
        "        ELSE",
        "          cMessage :\u003d ComLastMessage()",
        "          IIF(empty(cMessage),cMessage :\u003d \"Unknown\", NIL)",
        "          DisplayUnableToCreateEmail(cMessage + \";Please restart Outlook and try again.\")",
        "        ENDIF",
        "      ",
        "      nExitValue :\u003d -1  // Return if there is an error.",
        "    ELSE",
        "",
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      //If outlook isn\u0027t a running visible task then open to inbox",
        "      IF Empty(oOutlookApplication:ActiveWindow) .OR. aOutlookWinHandleAndVisibility \u003d\u003d NIL"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 386492",
    "offset": 386492,
    "line": 11154,
    "column": 40,
    "evidence": {
      "startLine": 11144,
      "endLine": 11164,
      "focusLine": 11154,
      "lines": [
        "    IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "    IF !empty(ComLastError()) .OR. Valtype(oOutlookApplication) # \u0027O\u0027",
        "        KillAlert(@oAlertBox)",
        "        //Check task isn\u0027t in suspended state?  If it is then have user kill w/task manager reboot",
        "        IF aOutlookWinHandleAndVisibility !\u003d NIL .AND. !aOutlookWinHandleAndVisibility[1,2]",
        "          DisplayUnableToCreateEmail( \"Outlook is in an unusable state.;\" + ; ",
        "                   \"Please kill the Outlook program using Task Manager or reboot your computer and try again.\")",
        "        ELSE",
        "          cMessage :\u003d ComLastMessage()",
        "          IIF(empty(cMessage),cMessage :\u003d \"Unknown\", NIL)",
        "          DisplayUnableToCreateEmail(cMessage + \";Please restart Outlook and try again.\")",
        "        ENDIF",
        "      ",
        "      nExitValue :\u003d -1  // Return if there is an error.",
        "    ELSE",
        "",
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      //If outlook isn\u0027t a running visible task then open to inbox",
        "      IF Empty(oOutlookApplication:ActiveWindow) .OR. aOutlookWinHandleAndVisibility \u003d\u003d NIL"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 388219",
    "offset": 388219,
    "line": 11189,
    "column": 88,
    "evidence": {
      "startLine": 11179,
      "endLine": 11199,
      "focusLine": 11189,
      "lines": [
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      // Allows for integrating automation objects generating COM/ActiveX events.",
        "      oOutlookActXMailItem :\u003d oOutlookMailItem:dynamicCast(ActiveXObject())  ",
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      //Listen for send and close events      ",
        "      nEventSend :\u003d oOutlookActXMailItem:isEventPublished(\"Send\")",
        "      nEventClose :\u003d oOutlookActXMailItem:isEventPublished(\"Close\")",
        "      IF nEventSend !\u003d NIL .AND. nEventClose !\u003d NIL  //If the events exist in Outlook, create listeners for them.",
        "        oOutlookActXMailItem:SubscribeEvent( nEventSend, { | a, b, c, d | lMessageSent :\u003d .T. } )",
        "        oOutlookActXMailItem:SubscribeEvent( nEventClose, { | a, b, c, d | lMessageClose :\u003d .T. } )",
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        // Setting the new MailItem subject and body",
        "        oOutlookActXMailItem:Subject :\u003d p_cSubject",
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        oOutlookActXMailItem:Body :\u003d p_cText"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 388219",
    "offset": 388219,
    "line": 11189,
    "column": 88,
    "evidence": {
      "startLine": 11179,
      "endLine": 11199,
      "focusLine": 11189,
      "lines": [
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      // Allows for integrating automation objects generating COM/ActiveX events.",
        "      oOutlookActXMailItem :\u003d oOutlookMailItem:dynamicCast(ActiveXObject())  ",
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      //Listen for send and close events      ",
        "      nEventSend :\u003d oOutlookActXMailItem:isEventPublished(\"Send\")",
        "      nEventClose :\u003d oOutlookActXMailItem:isEventPublished(\"Close\")",
        "      IF nEventSend !\u003d NIL .AND. nEventClose !\u003d NIL  //If the events exist in Outlook, create listeners for them.",
        "        oOutlookActXMailItem:SubscribeEvent( nEventSend, { | a, b, c, d | lMessageSent :\u003d .T. } )",
        "        oOutlookActXMailItem:SubscribeEvent( nEventClose, { | a, b, c, d | lMessageClose :\u003d .T. } )",
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        // Setting the new MailItem subject and body",
        "        oOutlookActXMailItem:Subject :\u003d p_cSubject",
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        oOutlookActXMailItem:Body :\u003d p_cText"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 388219",
    "offset": 388219,
    "line": 11189,
    "column": 88,
    "evidence": {
      "startLine": 11179,
      "endLine": 11199,
      "focusLine": 11189,
      "lines": [
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      // Allows for integrating automation objects generating COM/ActiveX events.",
        "      oOutlookActXMailItem :\u003d oOutlookMailItem:dynamicCast(ActiveXObject())  ",
        "      IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "      //Listen for send and close events      ",
        "      nEventSend :\u003d oOutlookActXMailItem:isEventPublished(\"Send\")",
        "      nEventClose :\u003d oOutlookActXMailItem:isEventPublished(\"Close\")",
        "      IF nEventSend !\u003d NIL .AND. nEventClose !\u003d NIL  //If the events exist in Outlook, create listeners for them.",
        "        oOutlookActXMailItem:SubscribeEvent( nEventSend, { | a, b, c, d | lMessageSent :\u003d .T. } )",
        "        oOutlookActXMailItem:SubscribeEvent( nEventClose, { | a, b, c, d | lMessageClose :\u003d .T. } )",
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        // Setting the new MailItem subject and body",
        "        oOutlookActXMailItem:Subject :\u003d p_cSubject",
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        oOutlookActXMailItem:Body :\u003d p_cText"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 388860",
    "offset": 388860,
    "line": 11206,
    "column": 9,
    "evidence": {
      "startLine": 11196,
      "endLine": 11216,
      "focusLine": 11206,
      "lines": [
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        oOutlookActXMailItem:Body :\u003d p_cText",
        "",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "        ",
        "        // Setting the new MailItem recipients",
        "        FOR i :\u003d 1 TO Len(p_aEmailRecipients)",
        "          oOutlookActXMailItem:Recipients:Add(p_aEmailRecipients[i])",
        "        NEXT",
        "        ",
        "        IIF(lInProgress,oAlertBox[3]:increment(), NIL)",
        "",
        "        // Adding the new MailItem a file attachment",
        "        FOR i :\u003d 1 TO Len(p_aFilesToAttach)",
        "          IF !Empty(p_aFilesToAttach[i])",
        "            oOutlookActXMailItem:Attachments:Add(p_aFilesToAttach[i])",
        "          ENDIF",
        "        NEXT",
        "          "
      ]
    }
  },
  {
    "message": "Unexpected END at 389775",
    "offset": 389775,
    "line": 11235,
    "column": 9,
    "evidence": {
      "startLine": 11225,
      "endLine": 11245,
      "focusLine": 11235,
      "lines": [
        "        KillAlert(@oAlertBox)",
        "        ",
        "        oOutlookActXMailItem:Display()",
        "        oOutlookActXMailItem:GetInspector():Activate()",
        "        Window2Top(p_cSubject)",
        "        ",
        "        ",
        "        //Wait while the email is open and not sent.",
        "        do while !lMessageSent .AND. !lMessageClose",
        "          nEventSend:\u003dAppEvent()",
        "        end do",
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError"
      ]
    }
  },
  {
    "message": "Unexpected token DO at 389779",
    "offset": 389779,
    "line": 11235,
    "column": 13,
    "evidence": {
      "startLine": 11225,
      "endLine": 11245,
      "focusLine": 11235,
      "lines": [
        "        KillAlert(@oAlertBox)",
        "        ",
        "        oOutlookActXMailItem:Display()",
        "        oOutlookActXMailItem:GetInspector():Activate()",
        "        Window2Top(p_cSubject)",
        "        ",
        "        ",
        "        //Wait while the email is open and not sent.",
        "        do while !lMessageSent .AND. !lMessageClose",
        "          nEventSend:\u003dAppEvent()",
        "        end do",
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError"
      ]
    }
  },
  {
    "message": "Unexpected ELSE at 389880",
    "offset": 389880,
    "line": 11239,
    "column": 7,
    "evidence": {
      "startLine": 11229,
      "endLine": 11249,
      "focusLine": 11239,
      "lines": [
        "        Window2Top(p_cSubject)",
        "        ",
        "        ",
        "        //Wait while the email is open and not sent.",
        "        do while !lMessageSent .AND. !lMessageClose",
        "          nEventSend:\u003dAppEvent()",
        "        end do",
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError",
        "  END SEQUENCE ",
        "",
        "  KillAlert(@oAlertBox)",
        "    "
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 390175",
    "offset": 390175,
    "line": 11243,
    "column": 7,
    "evidence": {
      "startLine": 11233,
      "endLine": 11253,
      "focusLine": 11243,
      "lines": [
        "        do while !lMessageSent .AND. !lMessageClose",
        "          nEventSend:\u003dAppEvent()",
        "        end do",
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError",
        "  END SEQUENCE ",
        "",
        "  KillAlert(@oAlertBox)",
        "    ",
        "  // Releasing Outlook",
        "  IIF(oOutlookApplication !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookApplication:Destroy(),NIL)",
        "  IIF(oOutlookActXMailItem !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookActXMailItem:Destroy(),NIL)",
        "    "
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 390185",
    "offset": 390185,
    "line": 11244,
    "column": 5,
    "evidence": {
      "startLine": 11234,
      "endLine": 11254,
      "focusLine": 11244,
      "lines": [
        "          nEventSend:\u003dAppEvent()",
        "        end do",
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError",
        "  END SEQUENCE ",
        "",
        "  KillAlert(@oAlertBox)",
        "    ",
        "  // Releasing Outlook",
        "  IIF(oOutlookApplication !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookApplication:Destroy(),NIL)",
        "  IIF(oOutlookActXMailItem !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookActXMailItem:Destroy(),NIL)",
        "    ",
        "  ErrorBlock(bSaveErrorBlock) // Restore old error code block"
      ]
    }
  },
  {
    "message": "Unexpected RECOVER at 390194",
    "offset": 390194,
    "line": 11245,
    "column": 3,
    "evidence": {
      "startLine": 11235,
      "endLine": 11255,
      "focusLine": 11245,
      "lines": [
        "        end do",
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError",
        "  END SEQUENCE ",
        "",
        "  KillAlert(@oAlertBox)",
        "    ",
        "  // Releasing Outlook",
        "  IIF(oOutlookApplication !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookApplication:Destroy(),NIL)",
        "  IIF(oOutlookActXMailItem !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookActXMailItem:Destroy(),NIL)",
        "    ",
        "  ErrorBlock(bSaveErrorBlock) // Restore old error code block",
        "  "
      ]
    }
  },
  {
    "message": "Unexpected token USING at 390202",
    "offset": 390202,
    "line": 11245,
    "column": 11,
    "evidence": {
      "startLine": 11235,
      "endLine": 11255,
      "focusLine": 11245,
      "lines": [
        "        end do",
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError",
        "  END SEQUENCE ",
        "",
        "  KillAlert(@oAlertBox)",
        "    ",
        "  // Releasing Outlook",
        "  IIF(oOutlookApplication !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookApplication:Destroy(),NIL)",
        "  IIF(oOutlookActXMailItem !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookActXMailItem:Destroy(),NIL)",
        "    ",
        "  ErrorBlock(bSaveErrorBlock) // Restore old error code block",
        "  "
      ]
    }
  },
  {
    "message": "Unexpected END at 390217",
    "offset": 390217,
    "line": 11246,
    "column": 3,
    "evidence": {
      "startLine": 11236,
      "endLine": 11256,
      "focusLine": 11246,
      "lines": [
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError",
        "  END SEQUENCE ",
        "",
        "  KillAlert(@oAlertBox)",
        "    ",
        "  // Releasing Outlook",
        "  IIF(oOutlookApplication !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookApplication:Destroy(),NIL)",
        "  IIF(oOutlookActXMailItem !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookActXMailItem:Destroy(),NIL)",
        "    ",
        "  ErrorBlock(bSaveErrorBlock) // Restore old error code block",
        "  ",
        "RETURN  nExitValue //Returns 0 if email is closed, 1 if it is sent, -1 if an error"
      ]
    }
  },
  {
    "message": "Unexpected token SEQUENCE at 390221",
    "offset": 390221,
    "line": 11246,
    "column": 7,
    "evidence": {
      "startLine": 11236,
      "endLine": 11256,
      "focusLine": 11246,
      "lines": [
        "        ",
        "        //Set exit value",
        "        IIF(lMessageSent, nExitValue :\u003d1, nExitValue :\u003d0)",
        "      ELSE",
        "        //Display unable to create event listeners.. may indicate a bigger problem. No emails sent or archive done.",
        "        DisplayUnableToCreateEmail(\"Unable to create event listeners.;Please restart Outlook and try again.\")",
        "        nExitValue :\u003d -1  // Return if there is an error.",
        "      ENDIF",
        "    ENDIF ",
        "  RECOVER USING oError",
        "  END SEQUENCE ",
        "",
        "  KillAlert(@oAlertBox)",
        "    ",
        "  // Releasing Outlook",
        "  IIF(oOutlookApplication !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookApplication:Destroy(),NIL)",
        "  IIF(oOutlookActXMailItem !\u003d NIL .AND. Valtype(oOutlookApplication) \u003d \u0027O\u0027,oOutlookActXMailItem:Destroy(),NIL)",
        "    ",
        "  ErrorBlock(bSaveErrorBlock) // Restore old error code block",
        "  ",
        "RETURN  nExitValue //Returns 0 if email is closed, 1 if it is sent, -1 if an error"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 393593",
    "offset": 393593,
    "line": 11308,
    "column": 1,
    "evidence": {
      "startLine": 11298,
      "endLine": 11318,
      "focusLine": 11308,
      "lines": [
        "        p_cToExcel TO \"\"",
        "",
        "lpvPreview :\u003d .T.",
        "",
        "oAlertBox :\u003d Alert_Box(/*oOwner*/, \u0027;Please wait for screen....;\u0027, {\"NONE\"}, \"i\", \"Building \" + p_cFormName, /*timeout*/, /*esc_default*/, /*aLOpt_array*/, p_lShowProgress, /*cPlayWave*/, /*lPacify*/, FONT_TIMES_MEDIUM, /*cButtonFont*/, /*lModal*/)",
        "// Display a progress bar.",
        "",
        "IF p_lShowProgress",
        "  oAlertBox[3]:current :\u003d 1",
        "  oAlertBox[3]:maximum :\u003d Len(p_aDataToOutput)",
        "ENDIF",
        "",
        "cpvWinTitle :\u003d p_cFormName",
        "hDoc :\u003d PrintDlg(@aPrnVars)",
        "VpeSetEmbeddedFlagParser(hDoc,VPEFALSE) ",
        "",
        "VpeSetOutRectSP(hDoc, 150, 100, 2000, 2794)      // Set margins for this page, and",
        "VpeSetDefOutRectSP(hDoc, 150, 100, 2000, 2794)   // for all following pages",
        "",
        "//Only enable clicking if index num is passed in.",
        "IF p_iIndexColumn \u003e 0"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after expression at 394015",
    "offset": 394015,
    "line": 11320,
    "column": 24,
    "evidence": {
      "startLine": 11310,
      "endLine": 11330,
      "focusLine": 11320,
      "lines": [
        "cpvWinTitle :\u003d p_cFormName",
        "hDoc :\u003d PrintDlg(@aPrnVars)",
        "VpeSetEmbeddedFlagParser(hDoc,VPEFALSE) ",
        "",
        "VpeSetOutRectSP(hDoc, 150, 100, 2000, 2794)      // Set margins for this page, and",
        "VpeSetDefOutRectSP(hDoc, 150, 100, 2000, 2794)   // for all following pages",
        "",
        "//Only enable clicking if index num is passed in.",
        "IF p_iIndexColumn \u003e 0",
        "  oVPE:bOBJECTCLICKED:\u003d{|a,b,c,o|IIF(b\u003c\u003dlen(p_aDataToOutput),;",
        "                     (o:\u003dDataThread():new(),Sleep(5),o:start( \"CaseFromIndex\",p_aDataToOutput[b,p_iIndexColumn])),;",
        "                     NIL) }",
        "ENDIF",
        "",
        "VpeSetDevJobName(hDoc, p_cFormName)",
        "VpeSetTitle(hDoc,p_cFormName)",
        "// cCurrentErrorType :\u003d \"START PROCESSING\" // TODO future - ",
        "VpeSetAlign(hDoc,ALIGN_LEFT)",
        "",
        "ArrayToGenericFormHeader(hDoc, @yLoc, p_cFormName, p_aColumnNames)",
        "FOR i:\u003d1 TO len(p_aDataToOutput)"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 394015",
    "offset": 394015,
    "line": 11320,
    "column": 24,
    "evidence": {
      "startLine": 11310,
      "endLine": 11330,
      "focusLine": 11320,
      "lines": [
        "cpvWinTitle :\u003d p_cFormName",
        "hDoc :\u003d PrintDlg(@aPrnVars)",
        "VpeSetEmbeddedFlagParser(hDoc,VPEFALSE) ",
        "",
        "VpeSetOutRectSP(hDoc, 150, 100, 2000, 2794)      // Set margins for this page, and",
        "VpeSetDefOutRectSP(hDoc, 150, 100, 2000, 2794)   // for all following pages",
        "",
        "//Only enable clicking if index num is passed in.",
        "IF p_iIndexColumn \u003e 0",
        "  oVPE:bOBJECTCLICKED:\u003d{|a,b,c,o|IIF(b\u003c\u003dlen(p_aDataToOutput),;",
        "                     (o:\u003dDataThread():new(),Sleep(5),o:start( \"CaseFromIndex\",p_aDataToOutput[b,p_iIndexColumn])),;",
        "                     NIL) }",
        "ENDIF",
        "",
        "VpeSetDevJobName(hDoc, p_cFormName)",
        "VpeSetTitle(hDoc,p_cFormName)",
        "// cCurrentErrorType :\u003d \"START PROCESSING\" // TODO future - ",
        "VpeSetAlign(hDoc,ALIGN_LEFT)",
        "",
        "ArrayToGenericFormHeader(hDoc, @yLoc, p_cFormName, p_aColumnNames)",
        "FOR i:\u003d1 TO len(p_aDataToOutput)"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 394015",
    "offset": 394015,
    "line": 11320,
    "column": 24,
    "evidence": {
      "startLine": 11310,
      "endLine": 11330,
      "focusLine": 11320,
      "lines": [
        "cpvWinTitle :\u003d p_cFormName",
        "hDoc :\u003d PrintDlg(@aPrnVars)",
        "VpeSetEmbeddedFlagParser(hDoc,VPEFALSE) ",
        "",
        "VpeSetOutRectSP(hDoc, 150, 100, 2000, 2794)      // Set margins for this page, and",
        "VpeSetDefOutRectSP(hDoc, 150, 100, 2000, 2794)   // for all following pages",
        "",
        "//Only enable clicking if index num is passed in.",
        "IF p_iIndexColumn \u003e 0",
        "  oVPE:bOBJECTCLICKED:\u003d{|a,b,c,o|IIF(b\u003c\u003dlen(p_aDataToOutput),;",
        "                     (o:\u003dDataThread():new(),Sleep(5),o:start( \"CaseFromIndex\",p_aDataToOutput[b,p_iIndexColumn])),;",
        "                     NIL) }",
        "ENDIF",
        "",
        "VpeSetDevJobName(hDoc, p_cFormName)",
        "VpeSetTitle(hDoc,p_cFormName)",
        "// cCurrentErrorType :\u003d \"START PROCESSING\" // TODO future - ",
        "VpeSetAlign(hDoc,ALIGN_LEFT)",
        "",
        "ArrayToGenericFormHeader(hDoc, @yLoc, p_cFormName, p_aColumnNames)",
        "FOR i:\u003d1 TO len(p_aDataToOutput)"
      ]
    }
  },
  {
    "message": "Unexpected token ASSIGN at 394015",
    "offset": 394015,
    "line": 11320,
    "column": 24,
    "evidence": {
      "startLine": 11310,
      "endLine": 11330,
      "focusLine": 11320,
      "lines": [
        "cpvWinTitle :\u003d p_cFormName",
        "hDoc :\u003d PrintDlg(@aPrnVars)",
        "VpeSetEmbeddedFlagParser(hDoc,VPEFALSE) ",
        "",
        "VpeSetOutRectSP(hDoc, 150, 100, 2000, 2794)      // Set margins for this page, and",
        "VpeSetDefOutRectSP(hDoc, 150, 100, 2000, 2794)   // for all following pages",
        "",
        "//Only enable clicking if index num is passed in.",
        "IF p_iIndexColumn \u003e 0",
        "  oVPE:bOBJECTCLICKED:\u003d{|a,b,c,o|IIF(b\u003c\u003dlen(p_aDataToOutput),;",
        "                     (o:\u003dDataThread():new(),Sleep(5),o:start( \"CaseFromIndex\",p_aDataToOutput[b,p_iIndexColumn])),;",
        "                     NIL) }",
        "ENDIF",
        "",
        "VpeSetDevJobName(hDoc, p_cFormName)",
        "VpeSetTitle(hDoc,p_cFormName)",
        "// cCurrentErrorType :\u003d \"START PROCESSING\" // TODO future - ",
        "VpeSetAlign(hDoc,ALIGN_LEFT)",
        "",
        "ArrayToGenericFormHeader(hDoc, @yLoc, p_cFormName, p_aColumnNames)",
        "FOR i:\u003d1 TO len(p_aDataToOutput)"
      ]
    }
  },
  {
    "message": "Unexpected token ENDDO at 400354",
    "offset": 400354,
    "line": 11524,
    "column": 3,
    "evidence": {
      "startLine": 11514,
      "endLine": 11534,
      "focusLine": 11524,
      "lines": [
        "RETURN          ",
        "// EOP DebugIt",
        "",
        "// For diagnostic use.",
        "PROCEDURE StackTrace()",
        "LOCAL i:\u003d0, cStack:\u003d\"\"",
        "",
        "  DO WHILE ! Empty( ProcName(i) )",
        "    cStack +\u003d Trim(ProcName(i)) + \" - \" + LTrim(Str(ProcLine(i))) + \u0027;\u0027",
        "    i++",
        "  ENDDO",
        "  InfoBox(cStack, \"STACK TRACE\")",
        "",
        "RETURN",
        "// EOP StackTrace",
        "",
        "// Can be used to save the current selected database, the current record, and it\u0027s order.",
        "//  p_cNewDBF - The name of the database to switch to.",
        "//  p_cOrder - Optional string to pass into OderSet.",
        "//  RETURNs - An array with the the old database, old record number, old order, and a boolean that is true if the DBF had to be opened.",
        "//  NOTE: The return array from this function can be passed to SetOldDBF() to restore the old DBF."
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 400362",
    "offset": 400362,
    "line": 11525,
    "column": 3,
    "evidence": {
      "startLine": 11515,
      "endLine": 11535,
      "focusLine": 11525,
      "lines": [
        "// EOP DebugIt",
        "",
        "// For diagnostic use.",
        "PROCEDURE StackTrace()",
        "LOCAL i:\u003d0, cStack:\u003d\"\"",
        "",
        "  DO WHILE ! Empty( ProcName(i) )",
        "    cStack +\u003d Trim(ProcName(i)) + \" - \" + LTrim(Str(ProcLine(i))) + \u0027;\u0027",
        "    i++",
        "  ENDDO",
        "  InfoBox(cStack, \"STACK TRACE\")",
        "",
        "RETURN",
        "// EOP StackTrace",
        "",
        "// Can be used to save the current selected database, the current record, and it\u0027s order.",
        "//  p_cNewDBF - The name of the database to switch to.",
        "//  p_cOrder - Optional string to pass into OderSet.",
        "//  RETURNs - An array with the the old database, old record number, old order, and a boolean that is true if the DBF had to be opened.",
        "//  NOTE: The return array from this function can be passed to SetOldDBF() to restore the old DBF.",
        "FUNCTION GetOldDBF(p_cNewDBF, p_cOrder)"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 410555",
    "offset": 410555,
    "line": 11775,
    "column": 29,
    "evidence": {
      "startLine": 11765,
      "endLine": 11785,
      "focusLine": 11775,
      "lines": [
        "    IF (!Empty(p_axLocals) .AND. (p_axLocals[18];",
        "        .OR. (ValType(p_axLocals[5]) \u003d\u003d \u0027A\u0027 .AND. Alltrim(p_axLocals[5,5]) \u003d\u003d \u0027CIV\u0027))) .OR. p_lCiv",
        "      acDateNames :\u003d nVOD_DATE_NAMES_CIV",
        "    ELSE",
        "      acDateNames :\u003d nVOD_DATE_NAMES",
        "    ENDIF",
        "    ",
        "    // If the screen has axLocals then add its values to the array of dates.",
        "    // Otherwise the dates will be pre-loaded (for the Add New Case screen).",
        "    IF !Empty(p_axLocals)",
        "      p_adCompareDates :\u003d { ,;",
        "                           p_axLocals[1,dnDOB],;",
        "                           p_axLocals[2,p_nChgNum,dcCrimeDate],;",
        "                           p_axLocals[2,p_nChgNum,dcArrestDt],;",
        "                           p_axLocals[2,p_nChgNum,dcArraignDt],;",
        "                           p_axLocals[2,p_nChgNum,dcAdjudDate],;",
        "                           p_dDeemedDiss,;",
        "                           p_axLocals[2,p_nChgNum,dcSentDate],;",
        "                           p_axLocals[2,p_nChgNum,dcDispDate]}",
        "    ENDIF",
        "    p_adCompareDates[1] :\u003d Date()"
      ]
    }
  },
  {
    "message": "Expected expression in array literal at 410585",
    "offset": 410585,
    "line": 11776,
    "column": 28,
    "evidence": {
      "startLine": 11766,
      "endLine": 11786,
      "focusLine": 11776,
      "lines": [
        "        .OR. (ValType(p_axLocals[5]) \u003d\u003d \u0027A\u0027 .AND. Alltrim(p_axLocals[5,5]) \u003d\u003d \u0027CIV\u0027))) .OR. p_lCiv",
        "      acDateNames :\u003d nVOD_DATE_NAMES_CIV",
        "    ELSE",
        "      acDateNames :\u003d nVOD_DATE_NAMES",
        "    ENDIF",
        "    ",
        "    // If the screen has axLocals then add its values to the array of dates.",
        "    // Otherwise the dates will be pre-loaded (for the Add New Case screen).",
        "    IF !Empty(p_axLocals)",
        "      p_adCompareDates :\u003d { ,;",
        "                           p_axLocals[1,dnDOB],;",
        "                           p_axLocals[2,p_nChgNum,dcCrimeDate],;",
        "                           p_axLocals[2,p_nChgNum,dcArrestDt],;",
        "                           p_axLocals[2,p_nChgNum,dcArraignDt],;",
        "                           p_axLocals[2,p_nChgNum,dcAdjudDate],;",
        "                           p_dDeemedDiss,;",
        "                           p_axLocals[2,p_nChgNum,dcSentDate],;",
        "                           p_axLocals[2,p_nChgNum,dcDispDate]}",
        "    ENDIF",
        "    p_adCompareDates[1] :\u003d Date()",
        "    // Is the date in the future check.  Also, if the date is DOB, is it before today check."
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after array literal at 410585",
    "offset": 410585,
    "line": 11776,
    "column": 28,
    "evidence": {
      "startLine": 11766,
      "endLine": 11786,
      "focusLine": 11776,
      "lines": [
        "        .OR. (ValType(p_axLocals[5]) \u003d\u003d \u0027A\u0027 .AND. Alltrim(p_axLocals[5,5]) \u003d\u003d \u0027CIV\u0027))) .OR. p_lCiv",
        "      acDateNames :\u003d nVOD_DATE_NAMES_CIV",
        "    ELSE",
        "      acDateNames :\u003d nVOD_DATE_NAMES",
        "    ENDIF",
        "    ",
        "    // If the screen has axLocals then add its values to the array of dates.",
        "    // Otherwise the dates will be pre-loaded (for the Add New Case screen).",
        "    IF !Empty(p_axLocals)",
        "      p_adCompareDates :\u003d { ,;",
        "                           p_axLocals[1,dnDOB],;",
        "                           p_axLocals[2,p_nChgNum,dcCrimeDate],;",
        "                           p_axLocals[2,p_nChgNum,dcArrestDt],;",
        "                           p_axLocals[2,p_nChgNum,dcArraignDt],;",
        "                           p_axLocals[2,p_nChgNum,dcAdjudDate],;",
        "                           p_dDeemedDiss,;",
        "                           p_axLocals[2,p_nChgNum,dcSentDate],;",
        "                           p_axLocals[2,p_nChgNum,dcDispDate]}",
        "    ENDIF",
        "    p_adCompareDates[1] :\u003d Date()",
        "    // Is the date in the future check.  Also, if the date is DOB, is it before today check."
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 410604",
    "offset": 410604,
    "line": 11776,
    "column": 47,
    "evidence": {
      "startLine": 11766,
      "endLine": 11786,
      "focusLine": 11776,
      "lines": [
        "        .OR. (ValType(p_axLocals[5]) \u003d\u003d \u0027A\u0027 .AND. Alltrim(p_axLocals[5,5]) \u003d\u003d \u0027CIV\u0027))) .OR. p_lCiv",
        "      acDateNames :\u003d nVOD_DATE_NAMES_CIV",
        "    ELSE",
        "      acDateNames :\u003d nVOD_DATE_NAMES",
        "    ENDIF",
        "    ",
        "    // If the screen has axLocals then add its values to the array of dates.",
        "    // Otherwise the dates will be pre-loaded (for the Add New Case screen).",
        "    IF !Empty(p_axLocals)",
        "      p_adCompareDates :\u003d { ,;",
        "                           p_axLocals[1,dnDOB],;",
        "                           p_axLocals[2,p_nChgNum,dcCrimeDate],;",
        "                           p_axLocals[2,p_nChgNum,dcArrestDt],;",
        "                           p_axLocals[2,p_nChgNum,dcArraignDt],;",
        "                           p_axLocals[2,p_nChgNum,dcAdjudDate],;",
        "                           p_dDeemedDiss,;",
        "                           p_axLocals[2,p_nChgNum,dcSentDate],;",
        "                           p_axLocals[2,p_nChgNum,dcDispDate]}",
        "    ENDIF",
        "    p_adCompareDates[1] :\u003d Date()",
        "    // Is the date in the future check.  Also, if the date is DOB, is it before today check."
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 412775",
    "offset": 412775,
    "line": 11811,
    "column": 7,
    "evidence": {
      "startLine": 11801,
      "endLine": 11821,
      "focusLine": 11811,
      "lines": [
        "      //    Dispo: ACD55 needs blank sentence date.",
        "      // ** No sentence date w/an ACD validation is caught elsewhere. **",
        "    // If civil, since there can be two DoBs, skip the date in the main loop and do them separately here.",
        "    // p_adCompareDates[dDOV_DOB] will be an array of the two dates.  {dPlantif_DOB, dDefendantDOB}",
        "    IF p_lCiv",
        "      IF !Empty(p_adCompareDates[dDOV_DOB,1]) .AND. pr_dDate \u003c p_adCompareDates[dDOV_DOB,1]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + \"Plaintiff\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "      IF !Empty(p_adCompareDates[dDOV_DOB,2]) .AND. pr_dDate \u003c p_adCompareDates[dDOV_DOB,2]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + \"Defendant\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    ENDIF",
        "    FOR i:\u003dIIF(!p_lCiv, dDOV_DOB, dDOV_CRIME) TO IIF(p_nDateType \u003d dDOV_SENTENCE, p_nDateType-2, p_nDateType-1)",
        "      IF !Empty(p_adCompareDates[i]) .AND. pr_dDate \u003c p_adCompareDates[i]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 412787",
    "offset": 412787,
    "line": 11812,
    "column": 7,
    "evidence": {
      "startLine": 11802,
      "endLine": 11822,
      "focusLine": 11812,
      "lines": [
        "      // ** No sentence date w/an ACD validation is caught elsewhere. **",
        "    // If civil, since there can be two DoBs, skip the date in the main loop and do them separately here.",
        "    // p_adCompareDates[dDOV_DOB] will be an array of the two dates.  {dPlantif_DOB, dDefendantDOB}",
        "    IF p_lCiv",
        "      IF !Empty(p_adCompareDates[dDOV_DOB,1]) .AND. pr_dDate \u003c p_adCompareDates[dDOV_DOB,1]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + \"Plaintiff\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "      IF !Empty(p_adCompareDates[dDOV_DOB,2]) .AND. pr_dDate \u003c p_adCompareDates[dDOV_DOB,2]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + \"Defendant\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    ENDIF",
        "    FOR i:\u003dIIF(!p_lCiv, dDOV_DOB, dDOV_CRIME) TO IIF(p_nDateType \u003d dDOV_SENTENCE, p_nDateType-2, p_nDateType-1)",
        "      IF !Empty(p_adCompareDates[i]) .AND. pr_dDate \u003c p_adCompareDates[i]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + acDateNames[i] + \" date (\" +  DtoC(p_adCompareDates[i]) +\").;\""
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 413108",
    "offset": 413108,
    "line": 11817,
    "column": 7,
    "evidence": {
      "startLine": 11807,
      "endLine": 11827,
      "focusLine": 11817,
      "lines": [
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + \"Plaintiff\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "      IF !Empty(p_adCompareDates[dDOV_DOB,2]) .AND. pr_dDate \u003c p_adCompareDates[dDOV_DOB,2]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + \"Defendant\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    ENDIF",
        "    FOR i:\u003dIIF(!p_lCiv, dDOV_DOB, dDOV_CRIME) TO IIF(p_nDateType \u003d dDOV_SENTENCE, p_nDateType-2, p_nDateType-1)",
        "      IF !Empty(p_adCompareDates[i]) .AND. pr_dDate \u003c p_adCompareDates[i]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + acDateNames[i] + \" date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    NEXT",
        "    // Special logic for DoB."
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 413118",
    "offset": 413118,
    "line": 11818,
    "column": 5,
    "evidence": {
      "startLine": 11808,
      "endLine": 11828,
      "focusLine": 11818,
      "lines": [
        "                      + \"Plaintiff\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "      IF !Empty(p_adCompareDates[dDOV_DOB,2]) .AND. pr_dDate \u003c p_adCompareDates[dDOV_DOB,2]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + \"Defendant\u0027s Birth date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    ENDIF",
        "    FOR i:\u003dIIF(!p_lCiv, dDOV_DOB, dDOV_CRIME) TO IIF(p_nDateType \u003d dDOV_SENTENCE, p_nDateType-2, p_nDateType-1)",
        "      IF !Empty(p_adCompareDates[i]) .AND. pr_dDate \u003c p_adCompareDates[i]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + acDateNames[i] + \" date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    NEXT",
        "    // Special logic for DoB.",
        "    IF p_nDateType \u003d\u003d dDOV_DOB .AND. !Empty(p_adCompareDates[dDOV_ARREST]) .AND. pr_dDate \u003e p_adCompareDates[dDOV_ARREST]"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 413545",
    "offset": 413545,
    "line": 11825,
    "column": 7,
    "evidence": {
      "startLine": 11815,
      "endLine": 11835,
      "focusLine": 11825,
      "lines": [
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    ENDIF",
        "    FOR i:\u003dIIF(!p_lCiv, dDOV_DOB, dDOV_CRIME) TO IIF(p_nDateType \u003d dDOV_SENTENCE, p_nDateType-2, p_nDateType-1)",
        "      IF !Empty(p_adCompareDates[i]) .AND. pr_dDate \u003c p_adCompareDates[i]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + acDateNames[i] + \" date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    NEXT",
        "    // Special logic for DoB.",
        "    IF p_nDateType \u003d\u003d dDOV_DOB .AND. !Empty(p_adCompareDates[dDOV_ARREST]) .AND. pr_dDate \u003e p_adCompareDates[dDOV_ARREST]",
        "      cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" can not be after the \";",
        "                        + acDateNames[dDOV_ARREST] + \" date (\" +  DtoC(p_adCompareDates[dDOV_ARREST]) +\").;\"",
        "          alFails[dDOV_ARREST] :\u003d .T.",
        "          nNonFutureFails++",
        "    ENDIF",
        "    // If there are errors, and this is not for CDR or X/ESC, show the user the error message.",
        "    IF !Empty(cErrorMessage) .AND. !p_lCDR_X_Esc"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 413555",
    "offset": 413555,
    "line": 11826,
    "column": 5,
    "evidence": {
      "startLine": 11816,
      "endLine": 11836,
      "focusLine": 11826,
      "lines": [
        "        nNonFutureFails++",
        "      ENDIF",
        "    ENDIF",
        "    FOR i:\u003dIIF(!p_lCiv, dDOV_DOB, dDOV_CRIME) TO IIF(p_nDateType \u003d dDOV_SENTENCE, p_nDateType-2, p_nDateType-1)",
        "      IF !Empty(p_adCompareDates[i]) .AND. pr_dDate \u003c p_adCompareDates[i]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + acDateNames[i] + \" date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    NEXT",
        "    // Special logic for DoB.",
        "    IF p_nDateType \u003d\u003d dDOV_DOB .AND. !Empty(p_adCompareDates[dDOV_ARREST]) .AND. pr_dDate \u003e p_adCompareDates[dDOV_ARREST]",
        "      cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" can not be after the \";",
        "                        + acDateNames[dDOV_ARREST] + \" date (\" +  DtoC(p_adCompareDates[dDOV_ARREST]) +\").;\"",
        "          alFails[dDOV_ARREST] :\u003d .T.",
        "          nNonFutureFails++",
        "    ENDIF",
        "    // If there are errors, and this is not for CDR or X/ESC, show the user the error message.",
        "    IF !Empty(cErrorMessage) .AND. !p_lCDR_X_Esc",
        "      cErrorMessage :\u003d \"The following errors need to be corrected:;;\" + cErrorMessage"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 413555",
    "offset": 413555,
    "line": 11826,
    "column": 5,
    "evidence": {
      "startLine": 11816,
      "endLine": 11836,
      "focusLine": 11826,
      "lines": [
        "        nNonFutureFails++",
        "      ENDIF",
        "    ENDIF",
        "    FOR i:\u003dIIF(!p_lCiv, dDOV_DOB, dDOV_CRIME) TO IIF(p_nDateType \u003d dDOV_SENTENCE, p_nDateType-2, p_nDateType-1)",
        "      IF !Empty(p_adCompareDates[i]) .AND. pr_dDate \u003c p_adCompareDates[i]",
        "        cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" date can not be prior to \";",
        "                      + acDateNames[i] + \" date (\" +  DtoC(p_adCompareDates[i]) +\").;\"",
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    NEXT",
        "    // Special logic for DoB.",
        "    IF p_nDateType \u003d\u003d dDOV_DOB .AND. !Empty(p_adCompareDates[dDOV_ARREST]) .AND. pr_dDate \u003e p_adCompareDates[dDOV_ARREST]",
        "      cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" can not be after the \";",
        "                        + acDateNames[dDOV_ARREST] + \" date (\" +  DtoC(p_adCompareDates[dDOV_ARREST]) +\").;\"",
        "          alFails[dDOV_ARREST] :\u003d .T.",
        "          nNonFutureFails++",
        "    ENDIF",
        "    // If there are errors, and this is not for CDR or X/ESC, show the user the error message.",
        "    IF !Empty(cErrorMessage) .AND. !p_lCDR_X_Esc",
        "      cErrorMessage :\u003d \"The following errors need to be corrected:;;\" + cErrorMessage"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 413975",
    "offset": 413975,
    "line": 11833,
    "column": 5,
    "evidence": {
      "startLine": 11823,
      "endLine": 11843,
      "focusLine": 11833,
      "lines": [
        "        alFails[i] :\u003d .T.",
        "        nNonFutureFails++",
        "      ENDIF",
        "    NEXT",
        "    // Special logic for DoB.",
        "    IF p_nDateType \u003d\u003d dDOV_DOB .AND. !Empty(p_adCompareDates[dDOV_ARREST]) .AND. pr_dDate \u003e p_adCompareDates[dDOV_ARREST]",
        "      cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" can not be after the \";",
        "                        + acDateNames[dDOV_ARREST] + \" date (\" +  DtoC(p_adCompareDates[dDOV_ARREST]) +\").;\"",
        "          alFails[dDOV_ARREST] :\u003d .T.",
        "          nNonFutureFails++",
        "    ENDIF",
        "    // If there are errors, and this is not for CDR or X/ESC, show the user the error message.",
        "    IF !Empty(cErrorMessage) .AND. !p_lCDR_X_Esc",
        "      cErrorMessage :\u003d \"The following errors need to be corrected:;;\" + cErrorMessage",
        "      DateDrag(0,NIL,NIL,NIL,NIL,NIL,.T.)",
        "      ALERTBOX TEXT cErrorMessage;",
        "              TO nButtonClick ;",
        "              BUTTONS {\u0027FIX\u0027,\u0027CANCEL\u0027} ;",
        "              SYSICON \"?\" ;",
        "              FONT FONT_TIMES_MEDIUM ;",
        "              TITLE Upper(acDateNames[p_nDateType]) + \" DATE ERROR\" ;"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 414080",
    "offset": 414080,
    "line": 11835,
    "column": 5,
    "evidence": {
      "startLine": 11825,
      "endLine": 11845,
      "focusLine": 11835,
      "lines": [
        "      ENDIF",
        "    NEXT",
        "    // Special logic for DoB.",
        "    IF p_nDateType \u003d\u003d dDOV_DOB .AND. !Empty(p_adCompareDates[dDOV_ARREST]) .AND. pr_dDate \u003e p_adCompareDates[dDOV_ARREST]",
        "      cErrorMessage +\u003d \" * \" + acDateNames[p_nDateType] + \" can not be after the \";",
        "                        + acDateNames[dDOV_ARREST] + \" date (\" +  DtoC(p_adCompareDates[dDOV_ARREST]) +\").;\"",
        "          alFails[dDOV_ARREST] :\u003d .T.",
        "          nNonFutureFails++",
        "    ENDIF",
        "    // If there are errors, and this is not for CDR or X/ESC, show the user the error message.",
        "    IF !Empty(cErrorMessage) .AND. !p_lCDR_X_Esc",
        "      cErrorMessage :\u003d \"The following errors need to be corrected:;;\" + cErrorMessage",
        "      DateDrag(0,NIL,NIL,NIL,NIL,NIL,.T.)",
        "      ALERTBOX TEXT cErrorMessage;",
        "              TO nButtonClick ;",
        "              BUTTONS {\u0027FIX\u0027,\u0027CANCEL\u0027} ;",
        "              SYSICON \"?\" ;",
        "              FONT FONT_TIMES_MEDIUM ;",
        "              TITLE Upper(acDateNames[p_nDateType]) + \" DATE ERROR\" ;",
        "              DEFAULTBUTTON 1",
        "      IF (nButtonClick \u003d\u003d 2) // The user hit cancel, so pass the validation, but clear the date."
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 416777",
    "offset": 416777,
    "line": 11905,
    "column": 3,
    "evidence": {
      "startLine": 11895,
      "endLine": 11915,
      "focusLine": 11905,
      "lines": [
        "              BUTTONS {\u0027FIX\u0027,\u0027CANCEL\u0027} ;",
        "              SYSICON \"?\" ;",
        "              FONT FONT_TIMES_MEDIUM ;",
        "              TITLE \"ARRIGNMENT DATE ERROR\" ;",
        "              DEFAULTBUTTON 1",
        "    IF (nButtonClick \u003d\u003d 2) // The user hit cancel, so pass the validation, but clear the date.",
        "      p_dDate :\u003d StoD(\"//\")",
        "      lValid :\u003d .T.",
        "      dc_getrefresh(p_GetList)",
        "    ENDIF",
        "  ENDIF",
        "RETURN lValid",
        "",
        "FUNCTION isValidateNextCourtDate(p_dDate, p_GetList)",
        "  LOCAL lValid:\u003d.F.",
        "  IF p_dDate \u003e\u003d Date()",
        "    lValid :\u003d .T.",
        "  ELSE       ",
        "      ALERTBOX TEXT \"The next court date cannot be in the past.\";",
        "              TO nButtonClick ;",
        "              BUTTONS {\u0027FIX\u0027,\u0027CANCEL\u0027} ;"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 417394",
    "offset": 417394,
    "line": 11925,
    "column": 3,
    "evidence": {
      "startLine": 11915,
      "endLine": 11935,
      "focusLine": 11925,
      "lines": [
        "              BUTTONS {\u0027FIX\u0027,\u0027CANCEL\u0027} ;",
        "              SYSICON \"?\" ;",
        "              FONT FONT_TIMES_MEDIUM ;",
        "              TITLE \"NEXT COURT DATE ERROR\" ;",
        "              DEFAULTBUTTON 1",
        "    IF (nButtonClick \u003d\u003d 2) // The user hit cancel, so pass the validation, but clear the date.",
        "      p_dDate :\u003d StoD(\"//\")",
        "      lValid :\u003d .T.",
        "      dc_getrefresh(p_GetList)",
        "    ENDIF",
        "  ENDIF",
        "RETURN lValid",
        "",
        "",
        "",
        "",
        "// Checks all dates on a screen to see if any have focus and are invalid.",
        "// Called from ADJDISP: ScrollValidation and from ADJDISP/ED_CHRG:handlers.",
        "// p_oCurrentFocus: Currently only used from Scroll Validation.",
        "// p_lCiv: Used for cases where axLocals is not available.  If true, Civil date names are used.",
        "FUNCTION IsDateValidFull(p_oCurrentFocus, p_lCiv)"
      ]
    }
  },
  {
    "message": "Unexpected token COMMA at 419762",
    "offset": 419762,
    "line": 11985,
    "column": 25,
    "evidence": {
      "startLine": 11975,
      "endLine": 11995,
      "focusLine": 11985,
      "lines": [
        "//  p_nIDIndex: The number of the Interim Disposition (1-6) being validated.",
        "//  axLocals: The axLocals array.",
        "//  pr_cErrorText: The CDR validation error message will be added here if the validation fails.",
        "//  p_aF2List5: Interim dispositions from Dictionary.",
        "FUNCTION ValidateInterimDispositionDates(p_aCDR, p_nIDIndex, axLocals, pr_cErrorText, p_aF2List5)",
        "LOCAL lRet:\u003d.T., i, adCrimeDates:\u003d{}, cIDText, dIDDate, adArrestDates:\u003d{},;",
        "      adArraignmentDates:\u003d{}, nCrimeLen, nArrestLen, nArriagnLen,;",
        "      acBeforeDates:\u003d{}, acAfterDates:\u003d{}, acRequiresDate:\u003d{}, cBeforeDates:\u003d\"\",;",
        "      cAfterDates:\u003d\"\", cRequiresDate:\u003d\"\", lOnBirthDate:\u003d.F., nNumberClauses:\u003d0, bAndCommas",
        "",
        "  bAndCommas :\u003d {|x| x++,;",
        "                     IIF(x \u003c\u003d nNumberClauses .AND. nNumberClauses \u003e 2, \",\", \"\");",
        "                       + IIF(x \u003d\u003d nNumberClauses, \" and\", \"\")}",
        "",
        "  cIDText :\u003d Alltrim(p_aCDR[12 + (2*p_nIDIndex)])",
        "  dIDDate :\u003d p_aCDR[11 + (2*p_nIDIndex)]",
        "  ",
        "  IF Empty(cIDText) .AND. Empty(dIDDate)",
        "    RETURN lRet",
        "  ENDIF",
        ""
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 419786",
    "offset": 419786,
    "line": 11986,
    "column": 22,
    "evidence": {
      "startLine": 11976,
      "endLine": 11996,
      "focusLine": 11986,
      "lines": [
        "//  axLocals: The axLocals array.",
        "//  pr_cErrorText: The CDR validation error message will be added here if the validation fails.",
        "//  p_aF2List5: Interim dispositions from Dictionary.",
        "FUNCTION ValidateInterimDispositionDates(p_aCDR, p_nIDIndex, axLocals, pr_cErrorText, p_aF2List5)",
        "LOCAL lRet:\u003d.T., i, adCrimeDates:\u003d{}, cIDText, dIDDate, adArrestDates:\u003d{},;",
        "      adArraignmentDates:\u003d{}, nCrimeLen, nArrestLen, nArriagnLen,;",
        "      acBeforeDates:\u003d{}, acAfterDates:\u003d{}, acRequiresDate:\u003d{}, cBeforeDates:\u003d\"\",;",
        "      cAfterDates:\u003d\"\", cRequiresDate:\u003d\"\", lOnBirthDate:\u003d.F., nNumberClauses:\u003d0, bAndCommas",
        "",
        "  bAndCommas :\u003d {|x| x++,;",
        "                     IIF(x \u003c\u003d nNumberClauses .AND. nNumberClauses \u003e 2, \",\", \"\");",
        "                       + IIF(x \u003d\u003d nNumberClauses, \" and\", \"\")}",
        "",
        "  cIDText :\u003d Alltrim(p_aCDR[12 + (2*p_nIDIndex)])",
        "  dIDDate :\u003d p_aCDR[11 + (2*p_nIDIndex)]",
        "  ",
        "  IF Empty(cIDText) .AND. Empty(dIDDate)",
        "    RETURN lRet",
        "  ENDIF",
        "",
        "  pr_cErrorText :\u003d \"Interim Disposition \" + Var2Char(p_nIDIndex) + \": \""
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 419786",
    "offset": 419786,
    "line": 11986,
    "column": 22,
    "evidence": {
      "startLine": 11976,
      "endLine": 11996,
      "focusLine": 11986,
      "lines": [
        "//  axLocals: The axLocals array.",
        "//  pr_cErrorText: The CDR validation error message will be added here if the validation fails.",
        "//  p_aF2List5: Interim dispositions from Dictionary.",
        "FUNCTION ValidateInterimDispositionDates(p_aCDR, p_nIDIndex, axLocals, pr_cErrorText, p_aF2List5)",
        "LOCAL lRet:\u003d.T., i, adCrimeDates:\u003d{}, cIDText, dIDDate, adArrestDates:\u003d{},;",
        "      adArraignmentDates:\u003d{}, nCrimeLen, nArrestLen, nArriagnLen,;",
        "      acBeforeDates:\u003d{}, acAfterDates:\u003d{}, acRequiresDate:\u003d{}, cBeforeDates:\u003d\"\",;",
        "      cAfterDates:\u003d\"\", cRequiresDate:\u003d\"\", lOnBirthDate:\u003d.F., nNumberClauses:\u003d0, bAndCommas",
        "",
        "  bAndCommas :\u003d {|x| x++,;",
        "                     IIF(x \u003c\u003d nNumberClauses .AND. nNumberClauses \u003e 2, \",\", \"\");",
        "                       + IIF(x \u003d\u003d nNumberClauses, \" and\", \"\")}",
        "",
        "  cIDText :\u003d Alltrim(p_aCDR[12 + (2*p_nIDIndex)])",
        "  dIDDate :\u003d p_aCDR[11 + (2*p_nIDIndex)]",
        "  ",
        "  IF Empty(cIDText) .AND. Empty(dIDDate)",
        "    RETURN lRet",
        "  ENDIF",
        "",
        "  pr_cErrorText :\u003d \"Interim Disposition \" + Var2Char(p_nIDIndex) + \": \""
      ]
    }
  },
  {
    "message": "Unexpected token RBRACE at 419907",
    "offset": 419907,
    "line": 11987,
    "column": 62,
    "evidence": {
      "startLine": 11977,
      "endLine": 11997,
      "focusLine": 11987,
      "lines": [
        "//  pr_cErrorText: The CDR validation error message will be added here if the validation fails.",
        "//  p_aF2List5: Interim dispositions from Dictionary.",
        "FUNCTION ValidateInterimDispositionDates(p_aCDR, p_nIDIndex, axLocals, pr_cErrorText, p_aF2List5)",
        "LOCAL lRet:\u003d.T., i, adCrimeDates:\u003d{}, cIDText, dIDDate, adArrestDates:\u003d{},;",
        "      adArraignmentDates:\u003d{}, nCrimeLen, nArrestLen, nArriagnLen,;",
        "      acBeforeDates:\u003d{}, acAfterDates:\u003d{}, acRequiresDate:\u003d{}, cBeforeDates:\u003d\"\",;",
        "      cAfterDates:\u003d\"\", cRequiresDate:\u003d\"\", lOnBirthDate:\u003d.F., nNumberClauses:\u003d0, bAndCommas",
        "",
        "  bAndCommas :\u003d {|x| x++,;",
        "                     IIF(x \u003c\u003d nNumberClauses .AND. nNumberClauses \u003e 2, \",\", \"\");",
        "                       + IIF(x \u003d\u003d nNumberClauses, \" and\", \"\")}",
        "",
        "  cIDText :\u003d Alltrim(p_aCDR[12 + (2*p_nIDIndex)])",
        "  dIDDate :\u003d p_aCDR[11 + (2*p_nIDIndex)]",
        "  ",
        "  IF Empty(cIDText) .AND. Empty(dIDDate)",
        "    RETURN lRet",
        "  ENDIF",
        "",
        "  pr_cErrorText :\u003d \"Interim Disposition \" + Var2Char(p_nIDIndex) + \": \"",
        "  IF Empty(cIDText) .OR. Empty(dIDDate)"
      ]
    }
  },
  {
    "message": "Unexpected ENDIF at 420063",
    "offset": 420063,
    "line": 11994,
    "column": 3,
    "evidence": {
      "startLine": 11984,
      "endLine": 12004,
      "focusLine": 11994,
      "lines": [
        "",
        "  bAndCommas :\u003d {|x| x++,;",
        "                     IIF(x \u003c\u003d nNumberClauses .AND. nNumberClauses \u003e 2, \",\", \"\");",
        "                       + IIF(x \u003d\u003d nNumberClauses, \" and\", \"\")}",
        "",
        "  cIDText :\u003d Alltrim(p_aCDR[12 + (2*p_nIDIndex)])",
        "  dIDDate :\u003d p_aCDR[11 + (2*p_nIDIndex)]",
        "  ",
        "  IF Empty(cIDText) .AND. Empty(dIDDate)",
        "    RETURN lRet",
        "  ENDIF",
        "",
        "  pr_cErrorText :\u003d \"Interim Disposition \" + Var2Char(p_nIDIndex) + \": \"",
        "  IF Empty(cIDText) .OR. Empty(dIDDate)",
        "    pr_cErrorText +\u003d \"Missing \";",
        "                     + IIF(Empty(cIDText), \"Text\", \"\");",
        "                     + IIF(Empty(cIDText) .AND. Empty(dIDDate), \" and \", \"\");",
        "                     + IIF(Empty(dIDDate), \"Date\", \"\");",
        "                     + \".\"",
        "    lRet :\u003d .F.",
        "  ENDIF"
      ]
    }
  },
  {
    "message": "Unexpected token EQ at 426883",
    "offset": 426883,
    "line": 12159,
    "column": 51,
    "evidence": {
      "startLine": 12149,
      "endLine": 12169,
      "focusLine": 12159,
      "lines": [
        "      IF AScan(p_aF2List5, {|x,i| Alltrim(x[1]) \u003d\u003d Alltrim(p_aCDR[12 + (p_nIDIndex * 2)])}) \u003e 0",
        "        Eval(bMissingBeforeCheck, dIDDate, adArraignmentDates, \"Arraignment\")",
        "      ELSE //Interim Description not found in list - not a valid option",
        "        pr_cErrorText +\u003d cIDText + \" is not a valid option.\"",
        "        lRet :\u003d .F.",
        "      ENDIF",
        "    ENDCASE",
        "",
        "    nNumberClauses :\u003d Min(1, Len(acRequiresDate)) + Min(1, Len(acBeforeDates)) + Min(1, Len(acAfterDates)) + IIF(lOnBirthDate, 1, 0)",
        "    IF nNumberClauses \u003e 0",
        "      AEval(acRequiresDate, {|x,i| cRequiresDate +\u003d x + IIF(i \u003c Len(acRequiresDate), \"/\", \"\")})",
        "      AEval(acBeforeDates, {|x,i| cBeforeDates +\u003d x + IIF(i \u003c Len(acBeforeDates), \"/\", \"\")})",
        "      AEval(acAfterDates, {|x,i| cAfterDates +\u003d x + IIF(i \u003c Len(acAfterDates), \"/\", \"\")})",
        "      i :\u003d 1",
        "      pr_cErrorText +\u003d cIDText;",
        "                     + IIF(!Empty(cRequiresDate),;",
        "                         \" requires \" + cRequiresDate + \" date\" + IIF(Len(acRequiresDate) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");",
        "                     + IIF(!Empty(cBeforeDates),;",
        "                         \" can not be before \" + cBeforeDates + \" date\" + IIF(Len(acBeforeDates) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");"
      ]
    }
  },
  {
    "message": "Expected expression after \u0027+\u0027 at 426885",
    "offset": 426885,
    "line": 12159,
    "column": 53,
    "evidence": {
      "startLine": 12149,
      "endLine": 12169,
      "focusLine": 12159,
      "lines": [
        "      IF AScan(p_aF2List5, {|x,i| Alltrim(x[1]) \u003d\u003d Alltrim(p_aCDR[12 + (p_nIDIndex * 2)])}) \u003e 0",
        "        Eval(bMissingBeforeCheck, dIDDate, adArraignmentDates, \"Arraignment\")",
        "      ELSE //Interim Description not found in list - not a valid option",
        "        pr_cErrorText +\u003d cIDText + \" is not a valid option.\"",
        "        lRet :\u003d .F.",
        "      ENDIF",
        "    ENDCASE",
        "",
        "    nNumberClauses :\u003d Min(1, Len(acRequiresDate)) + Min(1, Len(acBeforeDates)) + Min(1, Len(acAfterDates)) + IIF(lOnBirthDate, 1, 0)",
        "    IF nNumberClauses \u003e 0",
        "      AEval(acRequiresDate, {|x,i| cRequiresDate +\u003d x + IIF(i \u003c Len(acRequiresDate), \"/\", \"\")})",
        "      AEval(acBeforeDates, {|x,i| cBeforeDates +\u003d x + IIF(i \u003c Len(acBeforeDates), \"/\", \"\")})",
        "      AEval(acAfterDates, {|x,i| cAfterDates +\u003d x + IIF(i \u003c Len(acAfterDates), \"/\", \"\")})",
        "      i :\u003d 1",
        "      pr_cErrorText +\u003d cIDText;",
        "                     + IIF(!Empty(cRequiresDate),;",
        "                         \" requires \" + cRequiresDate + \" date\" + IIF(Len(acRequiresDate) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");",
        "                     + IIF(!Empty(cBeforeDates),;",
        "                         \" can not be before \" + cBeforeDates + \" date\" + IIF(Len(acBeforeDates) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");"
      ]
    }
  },
  {
    "message": "Expected \u0027}\u0027 after block literal at 426885",
    "offset": 426885,
    "line": 12159,
    "column": 53,
    "evidence": {
      "startLine": 12149,
      "endLine": 12169,
      "focusLine": 12159,
      "lines": [
        "      IF AScan(p_aF2List5, {|x,i| Alltrim(x[1]) \u003d\u003d Alltrim(p_aCDR[12 + (p_nIDIndex * 2)])}) \u003e 0",
        "        Eval(bMissingBeforeCheck, dIDDate, adArraignmentDates, \"Arraignment\")",
        "      ELSE //Interim Description not found in list - not a valid option",
        "        pr_cErrorText +\u003d cIDText + \" is not a valid option.\"",
        "        lRet :\u003d .F.",
        "      ENDIF",
        "    ENDCASE",
        "",
        "    nNumberClauses :\u003d Min(1, Len(acRequiresDate)) + Min(1, Len(acBeforeDates)) + Min(1, Len(acAfterDates)) + IIF(lOnBirthDate, 1, 0)",
        "    IF nNumberClauses \u003e 0",
        "      AEval(acRequiresDate, {|x,i| cRequiresDate +\u003d x + IIF(i \u003c Len(acRequiresDate), \"/\", \"\")})",
        "      AEval(acBeforeDates, {|x,i| cBeforeDates +\u003d x + IIF(i \u003c Len(acBeforeDates), \"/\", \"\")})",
        "      AEval(acAfterDates, {|x,i| cAfterDates +\u003d x + IIF(i \u003c Len(acAfterDates), \"/\", \"\")})",
        "      i :\u003d 1",
        "      pr_cErrorText +\u003d cIDText;",
        "                     + IIF(!Empty(cRequiresDate),;",
        "                         \" requires \" + cRequiresDate + \" date\" + IIF(Len(acRequiresDate) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");",
        "                     + IIF(!Empty(cBeforeDates),;",
        "                         \" can not be before \" + cBeforeDates + \" date\" + IIF(Len(acBeforeDates) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");"
      ]
    }
  },
  {
    "message": "Expected \u0027)\u0027 after arguments at 426885",
    "offset": 426885,
    "line": 12159,
    "column": 53,
    "evidence": {
      "startLine": 12149,
      "endLine": 12169,
      "focusLine": 12159,
      "lines": [
        "      IF AScan(p_aF2List5, {|x,i| Alltrim(x[1]) \u003d\u003d Alltrim(p_aCDR[12 + (p_nIDIndex * 2)])}) \u003e 0",
        "        Eval(bMissingBeforeCheck, dIDDate, adArraignmentDates, \"Arraignment\")",
        "      ELSE //Interim Description not found in list - not a valid option",
        "        pr_cErrorText +\u003d cIDText + \" is not a valid option.\"",
        "        lRet :\u003d .F.",
        "      ENDIF",
        "    ENDCASE",
        "",
        "    nNumberClauses :\u003d Min(1, Len(acRequiresDate)) + Min(1, Len(acBeforeDates)) + Min(1, Len(acAfterDates)) + IIF(lOnBirthDate, 1, 0)",
        "    IF nNumberClauses \u003e 0",
        "      AEval(acRequiresDate, {|x,i| cRequiresDate +\u003d x + IIF(i \u003c Len(acRequiresDate), \"/\", \"\")})",
        "      AEval(acBeforeDates, {|x,i| cBeforeDates +\u003d x + IIF(i \u003c Len(acBeforeDates), \"/\", \"\")})",
        "      AEval(acAfterDates, {|x,i| cAfterDates +\u003d x + IIF(i \u003c Len(acAfterDates), \"/\", \"\")})",
        "      i :\u003d 1",
        "      pr_cErrorText +\u003d cIDText;",
        "                     + IIF(!Empty(cRequiresDate),;",
        "                         \" requires \" + cRequiresDate + \" date\" + IIF(Len(acRequiresDate) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");",
        "                     + IIF(!Empty(cBeforeDates),;",
        "                         \" can not be before \" + cBeforeDates + \" date\" + IIF(Len(acBeforeDates) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");"
      ]
    }
  },
  {
    "message": "Unexpected token RBRACE at 426926",
    "offset": 426926,
    "line": 12159,
    "column": 94,
    "evidence": {
      "startLine": 12149,
      "endLine": 12169,
      "focusLine": 12159,
      "lines": [
        "      IF AScan(p_aF2List5, {|x,i| Alltrim(x[1]) \u003d\u003d Alltrim(p_aCDR[12 + (p_nIDIndex * 2)])}) \u003e 0",
        "        Eval(bMissingBeforeCheck, dIDDate, adArraignmentDates, \"Arraignment\")",
        "      ELSE //Interim Description not found in list - not a valid option",
        "        pr_cErrorText +\u003d cIDText + \" is not a valid option.\"",
        "        lRet :\u003d .F.",
        "      ENDIF",
        "    ENDCASE",
        "",
        "    nNumberClauses :\u003d Min(1, Len(acRequiresDate)) + Min(1, Len(acBeforeDates)) + Min(1, Len(acAfterDates)) + IIF(lOnBirthDate, 1, 0)",
        "    IF nNumberClauses \u003e 0",
        "      AEval(acRequiresDate, {|x,i| cRequiresDate +\u003d x + IIF(i \u003c Len(acRequiresDate), \"/\", \"\")})",
        "      AEval(acBeforeDates, {|x,i| cBeforeDates +\u003d x + IIF(i \u003c Len(acBeforeDates), \"/\", \"\")})",
        "      AEval(acAfterDates, {|x,i| cAfterDates +\u003d x + IIF(i \u003c Len(acAfterDates), \"/\", \"\")})",
        "      i :\u003d 1",
        "      pr_cErrorText +\u003d cIDText;",
        "                     + IIF(!Empty(cRequiresDate),;",
        "                         \" requires \" + cRequiresDate + \" date\" + IIF(Len(acRequiresDate) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");",
        "                     + IIF(!Empty(cBeforeDates),;",
        "                         \" can not be before \" + cBeforeDates + \" date\" + IIF(Len(acBeforeDates) \u003e 1, \"s\", \"\") + Eval(bAndCommas, @i),;",
        "                         \"\");"
      ]
    }
  },
  {
    "message": "Unexpected token ENDIF at 429966",
    "offset": 429966,
    "line": 12227,
    "column": 7,
    "evidence": {
      "startLine": 12217,
      "endLine": 12237,
      "focusLine": 12227,
      "lines": [
        "  ASort(aIntDisps,,, {|x,y| x[2] \u003c y[2]})",
        "",
        "  FOR i:\u003d1 TO Len(aIntDisps)",
        "    // Checking for multiple Warrant actions on the same date.",
        "    IF dWarrantDate \u003d\u003d aIntDisps[i,nDATE] .OR. (i \u003c Len(aIntDisps) .AND. aIntDisps[i,nDATE] \u003d\u003d aIntDisps[i+1,nDATE])",
        "      dWarrantDate :\u003d aIntDisps[i,nDATE]",
        "      IF (\"|\" + aIntDisps[i,nTEXT] + \"|\")$cWARRANT_START",
        "        AAdd(adSameDateStart, aIntDisps[i])",
        "      ELSEIF (\"|\" + aIntDisps[i,nTEXT] + \"|\")$cWARRANT_END",
        "        nSameDayEnd++",
        "      ENDIF",
        "      // Handle multiple Warrant actions on the same date.",
        "      IF (i \u003d\u003d Len(aIntDisps) .OR. aIntDisps[i,nDATE] \u003c\u003e aIntDisps[i+1,nDATE]) .AND. Len(adSameDateStart) + nSameDayEnd \u003e 0",
        "        nSameDayStart :\u003d Len(adSameDateStart)",
        "        IF Abs(nSameDayStart - nSameDayEnd) \u003e 1; // Too many starts or ends.",
        "            .OR. nSameDayStart - nSameDayEnd \u003d\u003d 1 .AND. lWarrantStart; // Too many starts.",
        "            .OR. nSameDayEnd - nSameDayStart \u003d\u003d 1 .AND. !lWarrantStart // Too many ends.",
        "          lRet :\u003d .F.",
        "          EXIT",
        "        ELSEIF nSameDayStart \u003c\u003e nSameDayEnd // Update lWarrantStart.",
        "          lWarrantStart :\u003d nSameDayStart - nSameDayEnd \u003e 0"
      ]
    }
  },
  {
    "message": "Expected expression after unary \u0027+\u0027 at 430037",
    "offset": 430037,
    "line": 12229,
    "column": 7,
    "evidence": {
      "startLine": 12219,
      "endLine": 12239,
      "focusLine": 12229,
      "lines": [
        "  FOR i:\u003d1 TO Len(aIntDisps)",
        "    // Checking for multiple Warrant actions on the same date.",
        "    IF dWarrantDate \u003d\u003d aIntDisps[i,nDATE] .OR. (i \u003c Len(aIntDisps) .AND. aIntDisps[i,nDATE] \u003d\u003d aIntDisps[i+1,nDATE])",
        "      dWarrantDate :\u003d aIntDisps[i,nDATE]",
        "      IF (\"|\" + aIntDisps[i,nTEXT] + \"|\")$cWARRANT_START",
        "        AAdd(adSameDateStart, aIntDisps[i])",
        "      ELSEIF (\"|\" + aIntDisps[i,nTEXT] + \"|\")$cWARRANT_END",
        "        nSameDayEnd++",
        "      ENDIF",
        "      // Handle multiple Warrant actions on the same date.",
        "      IF (i \u003d\u003d Len(aIntDisps) .OR. aIntDisps[i,nDATE] \u003c\u003e aIntDisps[i+1,nDATE]) .AND. Len(adSameDateStart) + nSameDayEnd \u003e 0",
        "        nSameDayStart :\u003d Len(adSameDateStart)",
        "        IF Abs(nSameDayStart - nSameDayEnd) \u003e 1; // Too many starts or ends.",
        "            .OR. nSameDayStart - nSameDayEnd \u003d\u003d 1 .AND. lWarrantStart; // Too many starts.",
        "            .OR. nSameDayEnd - nSameDayStart \u003d\u003d 1 .AND. !lWarrantStart // Too many ends.",
        "          lRet :\u003d .F.",
        "          EXIT",
        "        ELSEIF nSameDayStart \u003c\u003e nSameDayEnd // Update lWarrantStart.",
        "          lWarrantStart :\u003d nSameDayStart - nSameDayEnd \u003e 0",
        "        ENDIF",
        "        adSameDateStart:\u003d{}"
      ]
    }
  },
  {
    "message": "Unexpected NEXT at 431653",
    "offset": 431653,
    "line": 12272,
    "column": 3,
    "evidence": {
      "startLine": 12262,
      "endLine": 12282,
      "focusLine": 12272,
      "lines": [
        "        IF lWarrantStart",
        "          lWarrantStart :\u003d .F.",
        "          dWarrantDate :\u003d aIntDisps[i,nDATE]",
        "          pr_cWarrantOpen :\u003d \"\"",
        "        ELSE",
        "          lRet :\u003d .F.",
        "          EXIT",
        "        ENDIF",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  IF !lRet",
        "    pr_cErrorText :\u003d \"Interim Disposition: All ROW/WV must be preceded by AW/BW, and additional AW/BW;*R*        cannot be entered without the previous warrant already ended with ROW/WV.\"",
        "    pr_cWarrantOpen :\u003d \"\"",
        "  ENDIF",
        "  ",
        "RETURN lRet",
        "// EOF ValidateInterimDispositionWarrants",
        "",
        "// Checks a string for characters that are invalid in a name."
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDDO to close DO WHILE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDDO to close DO WHILE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDDO to close DO WHILE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDDO to close DO WHILE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDDO to close DO WHILE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDDO to close DO WHILE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected ENDIF to close IF at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected NEXT to close FOR at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  },
  {
    "message": "Expected END to close SEQUENCE at 434742",
    "offset": 434742,
    "line": 12346,
    "column": 28,
    "evidence": {
      "startLine": 12336,
      "endLine": 12356,
      "focusLine": 12346,
      "lines": [
        "        AAdd(acFullStrings, p_acStrings[i])",
        "      ENDIF",
        "    ENDIF",
        "  NEXT",
        "  ",
        "  pr_nCount :\u003d Len(acFullStrings)",
        "  IF Len(acFullStrings) \u003d\u003d 0",
        "    // Do nothing.",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 1",
        "    cRet :\u003d acFullStrings[1]",
        "  ELSEIF Len(acFullStrings) \u003d\u003d 2",
        "    cRet :\u003d acFullStrings[1] + cJoinerWord + acFullStrings[2]",
        "  ELSE",
        "    FOR i:\u003d 1 TO pr_nCount",
        "      cRet +\u003d acFullStrings[i]",
        "      IF i \u003c pr_nCount - 1",
        "        cRet +\u003d \", \"",
        "      ELSEIF i \u003d\u003d pr_nCount - 1",
        "        cRet +\u003d \",\"+cJoinerWord",
        "      ENDIF",
        "    NEXT"
      ]
    }
  }
]